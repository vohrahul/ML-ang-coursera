<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>queueing</title>

<meta name="description" content="User manual for queueing, a GNU Octave package for queueing networks and Markov chains analysis. This package supports single-station queueing systems, queueing networks and Markov chains. The queueing package implements, among others, the Mean Value Analysis (MVA) and convolution algorithms for steady-state analysis of product-form queueing networks. Transient and steady-state analysis of Markov chains is also implemented.">
<meta name="keywords" content="queueing">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#Concept-Index" rel="index" title="Concept Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">queueing</h1>



















<p>Copyright &copy; 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Moreno Marzolla.
</p>
<p>Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
</p>
<p>Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.
</p>
<p>Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions.
</p>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Summary-1" href="#Summary">1 Summary</a>
  <ul class="no-bullet">
    <li><a name="toc-About-the-Queueing-Package-1" href="#About-the-Queueing-Package">1.1 About the Queueing Package</a></li>
    <li><a name="toc-Contributing-Guidelines-1" href="#Contributing-Guidelines">1.2 Contributing Guidelines</a></li>
    <li><a name="toc-Acknowledgments-1" href="#Acknowledgments">1.3 Acknowledgments</a></li>
  </ul></li>
  <li><a name="toc-Installation-and-Getting-Started-1" href="#Installation-and-Getting-Started">2 Installation and Getting Started</a>
  <ul class="no-bullet">
    <li><a name="toc-Installation-through-Octave-package-management-system-1" href="#Installation-through-Octave-package-management-system">2.1 Installation through Octave package management system</a></li>
    <li><a name="toc-Manual-installation-1" href="#Manual-installation">2.2 Manual installation</a></li>
    <li><a name="toc-Development-sources-1" href="#Development-sources">2.3 Development sources</a></li>
    <li><a name="toc-Naming-Conventions-1" href="#Naming-Conventions">2.4 Naming Conventions</a></li>
    <li><a name="toc-Quick-start-Guide-1" href="#Quick-start-Guide">2.5 Quick start Guide</a></li>
  </ul></li>
  <li><a name="toc-Markov-Chains-1" href="#Markov-Chains">3 Markov Chains</a>
  <ul class="no-bullet">
    <li><a name="toc-Discrete_002dTime-Markov-Chains-1" href="#Discrete_002dTime-Markov-Chains">3.1 Discrete-Time Markov Chains</a>
    <ul class="no-bullet">
      <li><a name="toc-State-occupancy-probabilities" href="#State-occupancy-probabilities-_0028DTMC_0029">3.1.1 State occupancy probabilities</a></li>
      <li><a name="toc-Birth_002ddeath-process" href="#Birth_002ddeath-process-_0028DTMC_0029">3.1.2 Birth-death process</a></li>
      <li><a name="toc-Expected-Number-of-Visits" href="#Expected-number-of-visits-_0028DTMC_0029">3.1.3 Expected Number of Visits</a></li>
      <li><a name="toc-Time_002daveraged-expected-sojourn-times" href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">3.1.4 Time-averaged expected sojourn times</a></li>
      <li><a name="toc-Mean-Time-to-Absorption" href="#Mean-time-to-absorption-_0028DTMC_0029">3.1.5 Mean Time to Absorption</a></li>
      <li><a name="toc-First-Passage-Times" href="#First-passage-times-_0028DTMC_0029">3.1.6 First Passage Times</a></li>
    </ul></li>
    <li><a name="toc-Continuous_002dTime-Markov-Chains-1" href="#Continuous_002dTime-Markov-Chains">3.2 Continuous-Time Markov Chains</a>
    <ul class="no-bullet">
      <li><a name="toc-State-occupancy-probabilities-1" href="#State-occupancy-probabilities-_0028CTMC_0029">3.2.1 State occupancy probabilities</a></li>
      <li><a name="toc-Birth_002dDeath-Process" href="#Birth_002ddeath-process-_0028CTMC_0029">3.2.2 Birth-Death Process</a></li>
      <li><a name="toc-Expected-Sojourn-Times" href="#Expected-sojourn-times-_0028CTMC_0029">3.2.3 Expected Sojourn Times</a></li>
      <li><a name="toc-Time_002dAveraged-Expected-Sojourn-Times" href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">3.2.4 Time-Averaged Expected Sojourn Times</a></li>
      <li><a name="toc-Mean-Time-to-Absorption-1" href="#Mean-time-to-absorption-_0028CTMC_0029">3.2.5 Mean Time to Absorption</a></li>
      <li><a name="toc-First-Passage-Times-1" href="#First-passage-times-_0028CTMC_0029">3.2.6 First Passage Times</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Single-Station-Queueing-Systems-1" href="#Single-Station-Queueing-Systems">4 Single Station Queueing Systems</a>
  <ul class="no-bullet">
    <li><a name="toc-The-M_002fM_002f1-System-1" href="#The-M_002fM_002f1-System">4.1 The <em>M/M/1</em> System</a></li>
    <li><a name="toc-The-M_002fM_002fm-System-1" href="#The-M_002fM_002fm-System">4.2 The <em>M/M/m</em> System</a></li>
    <li><a name="toc-The-Erlang_002dB-Formula-1" href="#The-Erlang_002dB-Formula">4.3 The Erlang-B Formula</a></li>
    <li><a name="toc-The-Erlang_002dC-Formula-1" href="#The-Erlang_002dC-Formula">4.4 The Erlang-C Formula</a></li>
    <li><a name="toc-The-Engset-Formula-1" href="#The-Engset-Formula">4.5 The Engset Formula</a></li>
    <li><a name="toc-The-M_002fM_002finf-System-1" href="#The-M_002fM_002finf-System">4.6 The <em>M/M/</em>inf System</a></li>
    <li><a name="toc-The-M_002fM_002f1_002fK-System-1" href="#The-M_002fM_002f1_002fK-System">4.7 The <em>M/M/1/K</em> System</a></li>
    <li><a name="toc-The-M_002fM_002fm_002fK-System-1" href="#The-M_002fM_002fm_002fK-System">4.8 The <em>M/M/m/K</em> System</a></li>
    <li><a name="toc-The-Asymmetric-M_002fM_002fm-System-1" href="#The-Asymmetric-M_002fM_002fm-System">4.9 The Asymmetric <em>M/M/m</em> System</a></li>
    <li><a name="toc-The-M_002fG_002f1-System-1" href="#The-M_002fG_002f1-System">4.10 The <em>M/G/1</em> System</a></li>
    <li><a name="toc-The-M_002fH_005fm_002f1-System" href="#The-M_002fHm_002f1-System">4.11 The <em>M/H_m/1</em> System</a></li>
  </ul></li>
  <li><a name="toc-Queueing-Networks-1" href="#Queueing-Networks">5 Queueing Networks</a>
  <ul class="no-bullet">
    <li><a name="toc-Introduction-to-QNs-1" href="#Introduction-to-QNs">5.1 Introduction to QNs</a></li>
    <li><a name="toc-Single-Class-Models-1" href="#Single-Class-Models">5.2 Single Class Models</a>
    <ul class="no-bullet">
      <li><a name="toc-Open-Networks" href="#Open-Networks">5.2.1 Open Networks</a></li>
      <li><a name="toc-Closed-Networks" href="#Closed-Networks">5.2.2 Closed Networks</a></li>
      <li><a name="toc-Non-Product_002dForm-QNs-1" href="#Non-Product_002dForm-QNs-1">5.2.3 Non Product-Form QNs</a></li>
    </ul></li>
    <li><a name="toc-Multiple-Class-Models-1" href="#Multiple-Class-Models">5.3 Multiple Class Models</a>
    <ul class="no-bullet">
      <li><a name="toc-Open-Networks-1" href="#Open-Networks-1">5.3.1 Open Networks</a></li>
      <li><a name="toc-Closed-Networks-1" href="#Closed-Networks-1">5.3.2 Closed Networks</a></li>
      <li><a name="toc-Mixed-Networks" href="#Mixed-Networks">5.3.3 Mixed Networks</a></li>
    </ul></li>
    <li><a name="toc-Generic-Algorithms-1" href="#Generic-Algorithms">5.4 Generic Algorithms</a></li>
    <li><a name="toc-Bounds-Analysis-1" href="#Bounds-Analysis">5.5 Bounds Analysis</a></li>
    <li><a name="toc-QN-Analysis-Examples-1" href="#QN-Analysis-Examples">5.6 QN Analysis Examples</a>
    <ul class="no-bullet">
      <li><a name="toc-Closed_002c-Single-Class-Network" href="#Closed_002c-Single-Class-Network">5.6.1 Closed, Single Class Network</a></li>
      <li><a name="toc-Open_002c-Single-Class-Network" href="#Open_002c-Single-Class-Network">5.6.2 Open, Single Class Network</a></li>
      <li><a name="toc-Closed-Multiclass-Network_002f1" href="#Closed-Multiclass-Network_002f1">5.6.3 Closed Multiclass Network/1</a></li>
      <li><a name="toc-Closed-Multiclass-Network_002f2" href="#Closed-Multiclass-Network_002f2">5.6.4 Closed Multiclass Network/2</a></li>
      <li><a name="toc-Closed-Multiclass-Network_002f3" href="#Closed-Multiclass-Network_002f3">5.6.5 Closed Multiclass Network/3</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-References-1" href="#References">6 References</a></li>
  <li><a name="toc-GNU-GENERAL-PUBLIC-LICENSE" href="#Copying">Appendix A GNU GENERAL PUBLIC LICENSE</a></li>
  <li><a name="toc-Concept-Index-1" href="#Concept-Index">Concept Index</a></li>
  <li><a name="toc-Function-Index-1" href="#Function-Index">Function Index</a></li>
  <li><a name="toc-Author-Index-1" href="#Author-Index">Author Index</a></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Summary" accesskey="n" rel="next">Summary</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="SEC_Top"></a>

<p>This manual documents how to install and run the Queueing package.
It corresponds to version 1.2.5 of the package.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Summary" accesskey="1">Summary</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installation-and-Getting-Started" accesskey="2">Installation and Getting Started</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Installation of the queueing package.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Markov-Chains" accesskey="3">Markov Chains</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Functions for Markov chains analysis.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Single-Station-Queueing-Systems" accesskey="4">Single Station Queueing Systems</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Functions for single-station queueing systems.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Queueing-Networks" accesskey="5">Queueing Networks</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Functions for queueing networks analysis.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#References" accesskey="6">References</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">References.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Copying" accesskey="7">Copying</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The GNU General Public License.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Concept-Index" accesskey="8">Concept Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">An item for each concept.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Function-Index" accesskey="9">Function Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">An item for each function.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Author-Index">Author Index</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">An item for each author.
</td></tr>
</table>





<hr>
<a name="Summary"></a>
<div class="header">
<p>
Next: <a href="#Installation-and-Getting-Started" accesskey="n" rel="next">Installation and Getting Started</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Summary-1"></a>
<h2 class="chapter">1 Summary</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#About-the-Queueing-Package" accesskey="1">About the Queueing Package</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">What is the Queueing package.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Contributing-Guidelines" accesskey="2">Contributing Guidelines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to contribute.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Acknowledgments" accesskey="3">Acknowledgments</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="About-the-Queueing-Package"></a>
<div class="header">
<p>
Next: <a href="#Contributing-Guidelines" accesskey="n" rel="next">Contributing Guidelines</a>, Up: <a href="#Summary" accesskey="u" rel="up">Summary</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="About-the-Queueing-Package-1"></a>
<h3 class="section">1.1 About the Queueing Package</h3>

<p>This document describes the <code>queueing</code> package for GNU Octave
(<code>queueing</code> in short). The <code>queueing</code> package, previously
known as <code>qnetworks</code> toolbox, is a collection of functions for
analyzing queueing networks and Markov chains written for GNU
Octave. Specifically, <code>queueing</code> contains functions for analyzing
Jackson networks, open, closed or mixed product-form BCMP networks,
and computing performance bounds. The following algorithms are
available
</p>
<ul>
<li> Convolution for closed, single-class product-form networks
with load-dependent service centers;

</li><li> Exact and approximate Mean Value Analysis (MVA) for single and
multiple class product-form closed networks;

</li><li> MVA for mixed, multiple class product-form networks
with load-independent service centers;

</li><li> Approximate MVA for closed, single-class networks with blocking
(MVABLO algorithm by F. Akyildiz);

</li><li> Asymptotic Bounds, Balanced System Bounds and Geometric Bounds;

</li></ul>

<p><code>queueing</code> 
provides functions for analyzing the following types of single-station
queueing systems:
</p>
<ul>
<li> <em>M/M/1</em>
</li><li> <em>M/M/m</em>
</li><li> <em>M/M/\infty</em>
</li><li> <em>M/M/1/k</em> single-server, finite capacity system
</li><li> <em>M/M/m/k</em> multiple-server, finite capacity system
</li><li> Asymmetric <em>M/M/m</em>
</li><li> <em>M/G/1</em> (general service time distribution)
</li><li> <em>M/H_m/1</em> (Hyperexponential service time distribution)
</li></ul>

<p>Functions for Markov chain analysis are also provided (discrete- and
continuous-time chains are supported):
</p>
<ul>
<li> Birth-death processes;
</li><li> Transient and stationary state occupancy probabilities;
</li><li> Mean time to absorption;
</li><li> Expected sojourn times and time-averaged sojourn times;
</li><li> Mean first passage times;

</li></ul>

<p>The <code>queueing</code> package is distributed under the terms of the GNU
General Public License (GPL), version 3 or later
(see <a href="#Copying">Copying</a>). You are encouraged to share this software with
others, and improve this package by contributing additional functions
and reporting bugs. See <a href="#Contributing-Guidelines">Contributing Guidelines</a>.
</p>
<p>If you use the <code>queueing</code> package in a technical paper, please
cite it as:
</p>
<blockquote>
<p>Moreno Marzolla, <em>The qnetworks Toolbox: A Software Package for
Queueing Networks Analysis</em>. Khalid Al-Begain, Dieter Fiems and
William J. Knottenbelt, Editors, Proceedings 17th International
Conference on Analytical and Stochastic Modeling Techniques and
Applications (ASMTA 2010) Cardiff, UK, June 14&ndash;16, 2010, volume 6148
of Lecture Notes in Computer Science, Springer, pp. 102&ndash;116, ISBN
978-3-642-13567-5
</p></blockquote>

<p>If you use BibTeX, this is the citation block:
</p>
<pre class="verbatim">@inproceedings{queueing,
  author    = {Moreno Marzolla},
  title     = {The qnetworks Toolbox: A Software Package for Queueing 
               Networks Analysis},
  booktitle = {Analytical and Stochastic Modeling Techniques and 
               Applications, 17th International Conference, 
               ASMTA 2010, Cardiff, UK, June 14-16, 2010. Proceedings},
  editor    = {Khalid Al-Begain and Dieter Fiems and William J. Knottenbelt},
  year      = {2010},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {6148},
  pages     = {102--116},
  ee        = {http://dx.doi.org/10.1007/978-3-642-13568-2_8},
  isbn      = {978-3-642-13567-5}
}
</pre>
<p>An early draft of the paper above is available as Technical Report
<a href="http://www.informatica.unibo.it/it/ricerca/technical-report/2010/UBLCS-2010-04">UBLCS-2010-04</a>, February 2010, Department of Computer Science,
University of Bologna, Italy.
</p>
<hr>
<a name="Contributing-Guidelines"></a>
<div class="header">
<p>
Next: <a href="#Acknowledgments" accesskey="n" rel="next">Acknowledgments</a>, Previous: <a href="#About-the-Queueing-Package" accesskey="p" rel="prev">About the Queueing Package</a>, Up: <a href="#Summary" accesskey="u" rel="up">Summary</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Contributing-Guidelines-1"></a>
<h3 class="section">1.2 Contributing Guidelines</h3>

<p>Contributions and bug reports are <em>always</em> welcome. If you want
to contribute to the <code>queueing</code> package, here are some
guidelines:
</p>
<ul>
<li> If you are contributing a new function, please embed proper
documentation within the function itself. The documentation must be in
<code>texinfo</code> format, so that it can be extracted and included into
the printable manual. See the existing functions for the documentation
style.

</li><li> Make sure that each new function 
validates its input parameters. For example, a function accepting
vectors should check whether the dimensions match.

</li><li> Provide bibliographic references for each new algorithm you 
contribute. Document any significant difference from the
reference. Update the <samp>doc/references.txi</samp> file if appropriate.

</li><li> Include test and demo blocks.
Test blocks are particularly important, since most algorithms are
tricky to implement correctly. If appropriate, test blocks should also
verify that the function fails on incorrect inputs.

</li></ul>

<p>Send your contribution to Moreno Marzolla
(<a href="mailto:moreno.marzolla@unibo.it">moreno.marzolla@unibo.it</a>). If you are a user of this
package and find it useful, let me know by dropping me a line. Thanks.
</p>
<hr>
<a name="Acknowledgments"></a>
<div class="header">
<p>
Previous: <a href="#Contributing-Guidelines" accesskey="p" rel="prev">Contributing Guidelines</a>, Up: <a href="#Summary" accesskey="u" rel="up">Summary</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Acknowledgments-1"></a>
<h3 class="section">1.3 Acknowledgments</h3>

<p>The following people (listed alphabetically) contributed to the
<code>queueing</code> package, either by providing feedback, reporting bugs
or contributing code: Philip Carinhas, Phil Colbourn, Diego Didona,
Yves Durand, Marco Guazzone, Dmitry Kolesnikov, Michele Mazzucco, 
Marco Paolieri.
</p>



<hr>
<a name="Installation-and-Getting-Started"></a>
<div class="header">
<p>
Next: <a href="#Markov-Chains" accesskey="n" rel="next">Markov Chains</a>, Previous: <a href="#Summary" accesskey="p" rel="prev">Summary</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Installation-and-Getting-Started-1"></a>
<h2 class="chapter">2 Installation and Getting Started</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Installation-through-Octave-package-management-system" accesskey="1">Installation through Octave package management system</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Manual-installation" accesskey="2">Manual installation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Development-sources" accesskey="3">Development sources</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Naming-Conventions" accesskey="4">Naming Conventions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Quick-start-Guide" accesskey="5">Quick start Guide</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Installation-through-Octave-package-management-system"></a>
<div class="header">
<p>
Next: <a href="#Manual-installation" accesskey="n" rel="next">Manual installation</a>, Up: <a href="#Installation-and-Getting-Started" accesskey="u" rel="up">Installation and Getting Started</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Installation-through-Octave-package-management-system-1"></a>
<h3 class="section">2.1 Installation through Octave package management system</h3>

<p>The most recent version of <code>queueing</code> is 1.2.5 and can
be downloaded from Octave-Forge
</p>
<p><a href="http://octave.sourceforge.net/queueing/">http://octave.sourceforge.net/queueing/</a>
</p>
<p>Additional information can be found at
</p>
<p><a href="http://www.moreno.marzolla.name/software/queueing/">http://www.moreno.marzolla.name/software/queueing/</a>
</p>
<p>To install <code>queueing</code>, follow these steps:
</p>
<ol>
<li> If you have a recent version of GNU Octave and a network connection,
you can install <code>queueing</code> from Octave command prompt using this
command:

<div class="example">
<pre class="example">octave:1&gt; <kbd>pkg install -forge queueing</kbd>
</pre></div>

<p>The command above will automatically download and install the latest
version of the <code>queueing</code> package from Octave Forge, and install
it on your machine.
</p>
<p>If you do not have root access, you can do a local install using:
</p>
<div class="example">
<pre class="example">octave:1&gt; <kbd>pkg install -local -forge queueing</kbd>
</pre></div>

<p>This will install <code>queueing</code> in your home directory, and the
package will be available to the current user only. 
</p>
</li><li> Alternatively, you can first download the <code>queueing</code> tarball from
Octave-Forge; to install the package in the system-wide location
issue this command at the Octave prompt:

<div class="example">
<pre class="example">octave:1&gt; <kbd>pkg install <em>queueing-1.2.5.tar.gz</em></kbd>
</pre></div>

<p>(you may need to start Octave as root in order to allow the
installation to copy the files to the target locations). After this,
all functions will be available each time Octave starts, without the
need to tweak the search path.
</p>
<p>If you do not have root access, you can do a local install using:
</p>
<div class="example">
<pre class="example">octave:1&gt; <kbd>pkg install -local queueing-1.2.5.tar.gz</kbd>
</pre></div>

<blockquote>
<p><b>Note:</b> Octave version 3.2.3 as shipped with Ubuntu 10.04 LTS seems to ignore
<samp>-local</samp> and always tries to install the package on the system
directory.
</p></blockquote>

</li><li> Verify that the package is installed using the <kbd>pkg list</kbd> command
at the Octave prompt; after successful installation you should see
something like that:

<div class="example">
<pre class="example">octave:1&gt;<kbd>pkg list queueing</kbd>
Package Name  | Version | Installation directory
--------------+---------+-----------------------
    queueing  |   1.2.5 | /home/moreno/octave/queueing-1.2.5
</pre></div>

</li><li> Starting from version 1.1.1, <code>queueing</code> is no longer
automatically loaded on Octave start. To make the functions
available for use, you need to issue the command

<div class="example">
<pre class="example">octave:1&gt;<kbd>pkg load queueing</kbd> 
</pre></div>

<p>at the Octave prompt. To automatically load <code>queueing</code> each time
Octave starts, you can add the command above to the startup script
(usually, <samp>~/.octaverc</samp> on Unix systems).
</p>
</li><li> To completely remove <code>queueing</code> from your system, use the
<kbd>pkg uninstall</kbd> command:

<div class="example">
<pre class="example">octave:1&gt; <kbd>pkg uninstall queueing</kbd>
</pre></div>

</li></ol>


<hr>
<a name="Manual-installation"></a>
<div class="header">
<p>
Next: <a href="#Development-sources" accesskey="n" rel="next">Development sources</a>, Previous: <a href="#Installation-through-Octave-package-management-system" accesskey="p" rel="prev">Installation through Octave package management system</a>, Up: <a href="#Installation-and-Getting-Started" accesskey="u" rel="up">Installation and Getting Started</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Manual-installation-1"></a>
<h3 class="section">2.2 Manual installation</h3>

<p>If you want to manually install <code>queueing</code> in a custom location,
you can download the tarball and unpack it somewhere:
</p>
<div class="example">
<pre class="example"><kbd>tar xvfz queueing-1.2.5.tar.gz</kbd>
<kbd>cd queueing-1.2.5/queueing/</kbd>
</pre></div>

<p>Copy all <code>.m</code> files from the <samp>inst/</samp> directory to some
target location. Then, start Octave with the <samp>-p</samp> option to add
the target location to the search path, so that Octave will find all
<code>queueing</code> functions automatically:
</p>
<div class="example">
<pre class="example"><kbd>octave -p <em>/path/to/queueing</em></kbd>
</pre></div>

<p>For example, if all <code>queueing</code> m-files are in
<samp>/usr/local/queueing</samp>, you can start Octave as follows:
</p>
<div class="example">
<pre class="example"><kbd>octave -p <em>/usr/local/queueing</em></kbd>
</pre></div>

<p>If you want, you can add the following line to <samp>~/.octaverc</samp>:
</p>
<div class="example">
<pre class="example"><kbd>addpath(&quot;<em>/path/to/queueing</em>&quot;);</kbd>
</pre></div>

<p>so that the path <samp>/path/to/queueing</samp> is automatically
added to the search path each time Octave is started, and you no
longer need to specify the <samp>-p</samp> option on the command line.
</p>

<hr>
<a name="Development-sources"></a>
<div class="header">
<p>
Next: <a href="#Naming-Conventions" accesskey="n" rel="next">Naming Conventions</a>, Previous: <a href="#Manual-installation" accesskey="p" rel="prev">Manual installation</a>, Up: <a href="#Installation-and-Getting-Started" accesskey="u" rel="up">Installation and Getting Started</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Development-sources-1"></a>
<h3 class="section">2.3 Development sources</h3>

<p>The source code of the <code>queueing</code> package can be found in the
Mercurial repository at the URL:
</p>
<p><a href="https://sourceforge.net/p/octave/queueing/ci/default/tree/">https://sourceforge.net/p/octave/queueing/ci/default/tree/</a>
</p>
<p>The source distribution contains additional development files which
are not present in the installation tarball. This section briefly
describes the content of the source tree. This is only relevant for
developers who want to modify the code or the documentation.
</p>
<p>The source distribution contains the following directories:
</p>
<dl compact="compact">
<dt><samp>doc/</samp></dt>
<dd><p>Documentation sources. Most of the documentation is extracted from the
comment blocks of function files from the <samp>inst/</samp> directory.
</p>
</dd>
<dt><samp>inst/</samp></dt>
<dd><p>This directory contains the <tt>m</tt>-files which implement the
various algorithms provided by <code>queueing</code>. As a notational
convention, the names of functions for Queueing Networks begin with
the &lsquo;<samp>qn</samp>&rsquo; prefix; the name of functions for Continuous-Time Markov
Chains (CTMCs) begin with the &lsquo;<samp>ctmc</samp>&rsquo; prefix, and the names of
functions for Discrete-Time Markov Chains (DTMCs) begin with the
&lsquo;<samp>dtmc</samp>&rsquo; prefix.
</p>
</dd>
<dt><samp>test/</samp></dt>
<dd><p>This directory contains the test scripts used to run all function
tests.
</p>
</dd>
<dt><samp>devel/</samp></dt>
<dd><p>This directory contains functions that are either not working
properly, or need additional testing before they are moved to the
<samp>inst/</samp> directory.
</p>
</dd>
</dl>

<p>The <code>queueing</code> package ships with a Makefile which can be used to
produce the documentation (in PDF and HTML format), and automatically
execute all function tests. The following targets are defined:
</p>
<dl compact="compact">
<dt><code>all</code></dt>
<dd><p>Running &lsquo;<samp>make</samp>&rsquo; (or &lsquo;<samp>make all</samp>&rsquo;) on the top-level directory
builds the programs used to extract the documentation from the
comments embedded in the <tt>m</tt>-files, and then produce the
documentation in PDF and HTML format (<samp>doc/queueing.pdf</samp> and
<samp>doc/queueing.html</samp>, respectively).
</p>
</dd>
<dt><code>check</code></dt>
<dd><p>Running &lsquo;<samp>make check</samp>&rsquo; will execute all tests contained in the
<tt>m</tt>-files. If you modify the code of any function in the
<samp>inst/</samp> directory, you should run the tests to ensure that no
errors have been introduced. You are also encouraged to contribute new
tests, especially for functions that are not adequately validated.
</p>
</dd>
<dt><code>clean</code></dt>
<dt><code>distclean</code></dt>
<dt><code>dist</code></dt>
<dd><p>The &lsquo;<samp>make clean</samp>&rsquo;, &lsquo;<samp>make distclean</samp>&rsquo; and &lsquo;<samp>make dist</samp>&rsquo;
commands are used to clean up the source directory and prepare the
distribution archive in compressed tar format.
</p>
</dd>
</dl>

<hr>
<a name="Naming-Conventions"></a>
<div class="header">
<p>
Next: <a href="#Quick-start-Guide" accesskey="n" rel="next">Quick start Guide</a>, Previous: <a href="#Development-sources" accesskey="p" rel="prev">Development sources</a>, Up: <a href="#Installation-and-Getting-Started" accesskey="u" rel="up">Installation and Getting Started</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Naming-Conventions-1"></a>
<h3 class="section">2.4 Naming Conventions</h3>

<p>Most of the functions in the <code>queueing</code> package obey a common
naming convention. Function names are made of several parts; the first
part is a prefix which indicates the class of problems the function
addresses:
</p>
<dl compact="compact">
<dt><strong>ctmc-</strong></dt>
<dd><p>Functions for continuous-time Markov chains
</p>
</dd>
<dt><strong>dtmc-</strong></dt>
<dd><p>Functions for discrete-time Markov chains
</p>
</dd>
<dt><strong>qs-</strong></dt>
<dd><p>Functions for analyzing single-station queueing systems (individual
service centers)
</p>
</dd>
<dt><strong>qn-</strong></dt>
<dd><p>Functions for analyzing queueing networks
</p>
</dd>
</dl>

<p>Functions dealing with Markov chains start with either the <code>ctmc</code>
or <code>dtmc</code> prefix; the prefix is optionally followed by an
additional string which hints at what the function does:
</p>
<dl compact="compact">
<dt><strong>-bd</strong></dt>
<dd><p>Birth-Death process
</p>
</dd>
<dt><strong>-mtta</strong></dt>
<dd><p>Mean Time to Absorption
</p>
</dd>
<dt><strong>-fpt</strong></dt>
<dd><p>First Passage Times
</p>
</dd>
<dt><strong>-exps</strong></dt>
<dd><p>Expected Sojourn Times
</p>
</dd>
<dt><strong>-taexps</strong></dt>
<dd><p>Time-Averaged Expected Sojourn Times
</p>
</dd>
</dl>

<p>For example, function <code>ctmcbd</code> returns the infinitesimal
generator matrix for a continuous birth-death process, while
<code>dtmcbd</code> returns the transition probability matrix for a discrete
birth-death process. Note that there exist functions <code>ctmc</code> and
<code>dtmc</code> (without any suffix) that compute steady-state and
transient state occupancy probabilities for CTMCs and DTMCs,
respectively. See <a href="#Markov-Chains">Markov Chains</a>.
</p>
<p>Functions whose name starts with <code>qs-</code> deal with single station
queueing systems. The suffix describes the type of system, e.g.,
<code>qsmm1</code> for <em>M/M/1</em>, <code>qnmmm</code> for <em>M/M/m</em> and so
on. See <a href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>.
</p>
<p>Finally, functions whose name starts with <code>qn-</code> deal with
queueing networks. The character that follows indicates whether the
function handles open (<code>'o'</code>) or closed (<code>'c'</code>) networks,
and whether there is a single customer class (<code>'s'</code>) or multiple
classes (<code>'m'</code>). The string <code>mix</code> indicates that the
function supports mixed networks with both open and closed customer
classes.
</p>
<dl compact="compact">
<dt><strong>-os-</strong></dt>
<dd><p>Open, single-class network: open network with a single class of customers
</p>
</dd>
<dt><strong>-om-</strong></dt>
<dd><p>Open, multiclass network: open network with multiple job classes
</p>
</dd>
<dt><strong>-cs-</strong></dt>
<dd><p>Closed, single-class network
</p>
</dd>
<dt><strong>-cm-</strong></dt>
<dd><p>Closed, multiclass network
</p>
</dd>
<dt><strong>-mix-</strong></dt>
<dd><p>Mixed network with open and closed classes of customers
</p>
</dd>
</dl>

<p>The last part of the function name indicates the algorithm implemented
by the function. See <a href="#Queueing-Networks">Queueing Networks</a>.
</p>
<dl compact="compact">
<dt><strong>-aba</strong></dt>
<dd><p>Asymptotic Bounds Analysis
</p>
</dd>
<dt><strong>-bsb</strong></dt>
<dd><p>Balanced System Bounds
</p>
</dd>
<dt><strong>-gb</strong></dt>
<dd><p>Geometric Bounds
</p>
</dd>
<dt><strong>-pb</strong></dt>
<dd><p>PB Bounds
</p>
</dd>
<dt><strong>-cb</strong></dt>
<dd><p>Composite Bounds (CB)
</p>
</dd>
<dt><strong>-mva</strong></dt>
<dd><p>Mean Value Analysis (MVA) algorithm
</p>
</dd>
<dt><strong>-cmva</strong></dt>
<dd><p>Conditional MVA
</p>
</dd>
<dt><strong>-mvald</strong></dt>
<dd><p>MVA with general load-dependent servers
</p>
</dd>
<dt><strong>-mvaap</strong></dt>
<dd><p>Approximate MVA
</p>
</dd>
<dt><strong>-mvablo</strong></dt>
<dd><p>MVABLO approximation for blocking queueing networks
</p>
</dd>
<dt><strong>-conv</strong></dt>
<dd><p>Convolution algorithm
</p>
</dd>
<dt><strong>-convld</strong></dt>
<dd><p>Convolution algorithm with general load-dependent servers
</p>
</dd>
</dl>

<a name="index-deprecated-functions"></a>

<p>The current version (1.2.5) of the <code>queueing</code> package
still supports the naming convention used in old releases of
<code>queueing</code>. These old functions are no longer documented and will
be removed in future releases. Calling one of the deprecate functions
results in a warning message being displayed; the message appears only
one time per session:
</p>
<div class="example">
<pre class="example">octave:1&gt; <kbd>qnclosedab(10,[1 2 3])</kbd>
    -| warning: qnclosedab is deprecated. Please use qncsaba instead
    &rArr; ans =  0.16667
</pre></div>

<p>Therefore, your legacy code should run with the current version of the
<code>queueing</code> package. You can turn off all warning messages with
the following command:
</p>
<div class="example">
<pre class="example">octave:1&gt; <kbd>warning (&quot;off&quot;, &quot;qn:deprecated-function&quot;);</kbd>
</pre></div>

<p>However, it is recommended to update your code to the new API and not
ignore the warnings above. To help you catch usages of deprecated
functions you can transform warnings into errors so that your
application will stop immediately:
</p>
<div class="example">
<pre class="example">octave:1&gt; <kbd>warning (&quot;error&quot;, &quot;qn:deprecated-function&quot;);</kbd>
</pre></div>

<hr>
<a name="Quick-start-Guide"></a>
<div class="header">
<p>
Previous: <a href="#Naming-Conventions" accesskey="p" rel="prev">Naming Conventions</a>, Up: <a href="#Installation-and-Getting-Started" accesskey="u" rel="up">Installation and Getting Started</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Quick-start-Guide-1"></a>
<h3 class="section">2.5 Quick start Guide</h3>

<p>You can use all functions by simply invoking their name with the
appropriate parameters; the <code>queueing</code> package should display an
error in case of missing/wrong parameters. Extensive documentation is
provided for each function, and can be displayed with the
<code>help</code> command. For example:
</p>
<div class="example">
<pre class="example">octave:2&gt; <kbd>help qncsmvablo</kbd>
</pre></div>

<p>prints the documentation for the <code>qncsmvablo</code> function.
Additional information can be found in the <code>queueing</code> manual,
which is available in PDF format in <samp>doc/queueing.pdf</samp> and in
HTML format in <samp>doc/queueing.html</samp>.
</p>
<p>Many functions have demo blocks showing usage examples. To execute the
demos for the <code>qnclosed</code> function, use the <code>demo</code>
command:
</p>
<div class="example">
<pre class="example">octave:4&gt; <kbd>demo qnclosed</kbd>
</pre></div>

<p>We now illustrate a few examples of how the <code>queueing</code> package
can be used. More examples are provided in the manual.
</p>
<p><strong>Example 1</strong>
Compute the stationary state occupancy probabilities of a continuous-time
Markov chain with infinitesimal generator matrix
</p>
<div class="example">
<pre class="example">    / -0.8   0.6   0.2 \
Q = |  0.3  -0.7   0.4 |
    \  0.2   0.2  -0.4 /
</pre></div>

<div class="example">
<pre class="example">Q = [ -0.8  0.6  0.2; \
       0.3 -0.7  0.4; \
       0.2  0.2 -0.4 ];
q = ctmc(Q)
    &rArr; q = 0.23256   0.32558   0.44186
</pre></div>

<p><strong>Example 2</strong>
Compute the transient state occupancy probability after <em>n=3</em>
transitions of a three state discrete-time birth-death process, with
birth probabilities <em>\lambda_{01} = 0.3</em> and <em>\lambda_{12} =
0.5</em> and death probabilities <em>\mu_{10} = 0.5</em> and <em>\mu_{21}
= 0.7</em>, assuming that the system is initially in state zero (i.e., the
initial state occupancy probabilities are <em>(1, 0, 0)</em>).
</p>
<div class="example">
<pre class="example">n = 3;
p0 = [1 0 0];
P = dtmcbd( [0.3 0.5], [0.5 0.7] );
p = dtmc(P,n,p0)
    &rArr; p = 0.55300   0.29700   0.15000
</pre></div>

<p><strong>Example 3</strong>
Compute server utilization, response time, mean number of requests and
throughput of a closed queueing network with <em>N=4</em> requests and
three <em>M/M/1</em>&ndash;FCFS queues with mean service times <em>{\bf S}
= (1.0, 0.8, 1.4)</em> and average number of visits <em>{\bf V} = (1.0,
0.8, 0.8)</em>
</p>
<div class="example">
<pre class="example">S = [1.0 0.8 1.4];
V = [1.0 0.8 0.8];
N = 4;
[U R Q X] = qncsmva(N, S, V)
    &rArr; 
     U = 0.70064   0.44841   0.78471
     R = 2.1030    1.2642    3.2433
     Q = 1.47346   0.70862   1.81792
     X = 0.70064   0.56051   0.56051
</pre></div>

<p><strong>Example 4</strong>
Compute server utilization, response time, mean number of requests and
throughput of an open queueing network with three <em>M/M/1</em>&ndash;FCFS
queues with mean service times <em>{\bf S} = (1.0, 0.8, 1.4)</em> and
average number of visits <em>{\bf V} = (1.0, 0.8, 0.8)</em>. The overall
arrival rate is <em>\lambda = 0.8</em> requests/second.
</p>
<div class="example">
<pre class="example">S = [1.0 0.8 1.4];
V = [1.0 0.8 0.8];
lambda = 0.8;
[U R Q X] = qnos(lambda, S, V)
    &rArr; 
     U = 0.80000   0.51200   0.89600
     R = 5.0000    1.6393   13.4615
     Q = 4.0000    1.0492    8.6154
     X = 0.80000   0.64000   0.64000
</pre></div>




<hr>
<a name="Markov-Chains"></a>
<div class="header">
<p>
Next: <a href="#Single-Station-Queueing-Systems" accesskey="n" rel="next">Single Station Queueing Systems</a>, Previous: <a href="#Installation-and-Getting-Started" accesskey="p" rel="prev">Installation and Getting Started</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Markov-Chains-1"></a>
<h2 class="chapter">3 Markov Chains</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Discrete_002dTime-Markov-Chains" accesskey="1">Discrete-Time Markov Chains</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Continuous_002dTime-Markov-Chains" accesskey="2">Continuous-Time Markov Chains</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Discrete_002dTime-Markov-Chains"></a>
<div class="header">
<p>
Next: <a href="#Continuous_002dTime-Markov-Chains" accesskey="n" rel="next">Continuous-Time Markov Chains</a>, Up: <a href="#Markov-Chains" accesskey="u" rel="up">Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Discrete_002dTime-Markov-Chains-1"></a>
<h3 class="section">3.1 Discrete-Time Markov Chains</h3>

<p>Let <em>X_0, X_1, &hellip;, X_n, &hellip; </em> be a sequence of random
variables defined over the discrete state space <em>1, 2,
&hellip;</em>. The sequence <em>X_0, X_1, &hellip;, X_n, &hellip;</em>  is a
<em>stochastic process</em> with discrete time <em>0, 1, 2,
&hellip;</em>. A <em>Markov chain</em> is a stochastic process <em>{X_n,
n=0, 1, 2, &hellip;}</em> which satisfies the following Markov property:
</p>
<p><em>P(X_{n+1} = x_{n+1} | X_n = x_n, X_{n-1} = x_{n-1}, &hellip;, X_0 = x_0) = P(X_{n+1} = x_{n+1} | X_n = x_n)</em>
</p>
<p>which basically means that the probability that the system is in
a particular state at time <em>n+1</em> only depends on the state the
system was at time <em>n</em>.
</p>
<p>The evolution of a Markov chain with finite state space <em>{1, 2,
&hellip;, N}</em> can be fully described by a stochastic matrix <em>{\bf
P}(n) = [ P_{i,j}(n) ]</em> where <em>P_{i, j}(n) = P( X_{n+1} = j\
|\ X_n = i )</em>.  If the Markov chain is homogeneous (that is, the
transition probability matrix <em>{\bf P}(n)</em> is time-independent),
we can write <em>{\bf P} = [P_{i, j}]</em>, where <em>P_{i, j} = P(
X_{n+1} = j\ |\ X_n = i )</em> for all <em>n=0, 1, &hellip;</em>.
</p>
<p>The transition probability matrix <em>\bf P</em> must satisfy the
following two properties:
</p>
<ol>
<li> <em>P_{i, j} &ge; 0</em> for all <em>1 &le; i, j &le; N</em>;
</li><li> <em>\sum_{j=1}^N P_{i,j} = 1</em> for all <em>i</em>
</li></ol>

<a name="doc_002ddtmcchkP"></a>

<dl>
<dt><a name="index-dtmcchkP"></a>Function File: <em>[<var>r</var> <var>err</var>] =</em> <strong>dtmcchkP</strong> <em>(<var>P</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-discrete-time"></a>
<a name="index-DTMC"></a>
<a name="index-discrete-time-Markov-chain"></a>

<p>Check whether <var>P</var> is a valid transition probability matrix. 
</p>
<p>If <var>P</var> is valid, <var>r</var> is the size (number of rows or columns)
of <var>P</var>. If <var>P</var> is not a transition probability matrix,
<var>r</var> is set to zero, and <var>err</var> to an appropriate error string.
</p>
</dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#State-occupancy-probabilities-_0028DTMC_0029" accesskey="1">State occupancy probabilities (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Birth_002ddeath-process-_0028DTMC_0029" accesskey="2">Birth-death process (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Expected-number-of-visits-_0028DTMC_0029" accesskey="3">Expected number of visits (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029" accesskey="4">Time-averaged expected sojourn times (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mean-time-to-absorption-_0028DTMC_0029" accesskey="5">Mean time to absorption (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#First-passage-times-_0028DTMC_0029" accesskey="6">First passage times (DTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="State-occupancy-probabilities-_0028DTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Birth_002ddeath-process-_0028DTMC_0029" accesskey="n" rel="next">Birth-death process (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="State-occupancy-probabilities"></a>
<h4 class="subsection">3.1.1 State occupancy probabilities</h4>

<p>Given a discrete-time Markov chain with state space <em>{1, 2,
&hellip;, N}</em>, we denote with <em>{\bf \pi}(n) = \left(\pi_1(n),
\pi_2(n), &hellip;, \pi_N(n) \right)</em> the <em>state occupancy
probability vector</em> at step <em>n</em>, <em>n = 0, 1, &hellip;</em>.
<em>\pi_i(n)</em> is the probability that the system is in state
<em>i</em> after <em>n</em> transitions.
</p>
<p>Given the transition probability matrix <em>\bf P</em> and the initial
state occupancy probability vector <em>{\bf \pi}(0) =
\left(\pi_1(0), \pi_2(0), &hellip;, \pi_N(0)\right)</em>, <em>{\bf
\pi}(n)</em> can be computed as:
</p>
<p><em>\pi(n) = \pi(0) P^n</em>
</p>
<p>Under certain conditions, there exists a <em>stationary state
occupancy probability</em> <em>{\bf \pi} = \lim_{n \rightarrow +\infty}
{\bf \pi}(n)</em>, which is independent from <em>{\bf \pi}(0)</em>. The
vector <em>\bf \pi</em> is the solution of the following linear system:
</p>
<div class="example">
<pre class="example">/
| \pi P   = \pi
| \pi 1^T = 1
\
</pre></div>

<p>where <em>\bf 1</em> is the row vector of ones, and <em>( \cdot )^T</em>
the transpose operator.
</p>
<a name="doc_002ddtmc"></a>

<dl>
<dt><a name="index-dtmc"></a>Function File: <em><var>p</var> =</em> <strong>dtmc</strong> <em>(<var>P</var>)</em></dt>
<dt><a name="index-dtmc-1"></a>Function File: <em><var>p</var> =</em> <strong>dtmc</strong> <em>(<var>P</var>, <var>n</var>, <var>p0</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-discrete-time-1"></a>
<a name="index-discrete-time-Markov-chain-1"></a>
<a name="index-DTMC-1"></a>
<a name="index-Markov-chain_002c-stationary-probabilities"></a>
<a name="index-Markov-chain_002c-transient-probabilities"></a>

<p>Compute stationary or transient state occupancy probabilities for a discrete-time Markov chain.
</p>
<p>With a single argument, compute the stationary state occupancy
probabilities <code><var>p</var>(1), &hellip;, <var>p</var>(N)</code> for a
discrete-time Markov chain with state space <em>{1, 2, &hellip;,
N}</em> and with <em>N \times N</em> transition matrix
<var>P</var>. With three arguments, compute the transient state occupancy
probabilities <code><var>p</var>(1), &hellip;, <var>p</var>(N)</code> that the system is in
state <em>i</em> after <var>n</var> steps, given initial occupancy
probabilities <var>p0</var>(1), &hellip;, <var>p0</var>(N).
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>transition probability from state <em>i</em> to state <em>j</em>.
<var>P</var> must be an <em>N \times N</em> irreducible stochastic matrix,
which means that the sum of each row must be 1 (<em>\sum_{j=1}^N
P_{i, j} = 1</em>), and the rank of <var>P</var> must be <em>N</em>.
</p>
</dd>
<dt><code><var>n</var></code></dt>
<dd><p>Number of transitions after which compute the state occupancy probabilities
(scalar, <em>n &ge; 0</em>)
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>probability that at step 0 the system is in state <em>i</em> (vector
of length <em>N</em>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>p</var>(i)</code></dt>
<dd><p>If this function is called with a single argument, <code><var>p</var>(i)</code>
is the steady-state probability that the system is in state <em>i</em>.
If this function is called with three arguments, <code><var>p</var>(i)</code>
is the probability that the system is in state <em>i</em>
after <var>n</var> transitions, given the initial probabilities
<code><var>p0</var>(i)</code> that the initial state is <em>i</em>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> ctmc.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<p>The following example is from <a href="#GrSn97">GrSn97</a>. Let us consider a maze
with nine rooms, as shown in the following figure
</p>
<div class="example">
<pre class="example">+-----+-----+-----+
|     |     |     |
|  1     2     3  |
|     |     |     |
+-   -+-   -+-   -+
|     |     |     |
|  4     5     6  |
|     |     |     |
+-   -+-   -+-   -+
|     |     |     |
|  7     8     9  |
|     |     |     |
+-----+-----+-----+
</pre></div>

<p>A mouse is placed in one of the rooms and can wander around. At each
step, the mouse moves from the current room to a neighboring one with
equal probability. For example, if it is in room 1, it can move to
room 2 and 4 with probability <em>1/2</em>, respectively; if the mouse
is in room 8, it can move to either 7, 5 or 9 with probability
<em>1/3</em>.
</p>
<p>The transition probabilities <em>P_{i, j}</em> from room <em>i</em> to
room <em>j</em> can be summarized in the following matrix:
</p>
<div class="example">
<pre class="example">        / 0     1/2   0     1/2   0     0     0     0     0   \
        | 1/3   0     1/3   0     1/3   0     0     0     0   |
        | 0     1/2   0     0     0     1/2   0     0     0   |
        | 1/3   0     0     0     1/3   0     1/3   0     0   |
    P = | 0     1/4   0     1/4   0     1/4   0     1/4   0   |
        | 0     0     1/3   0     1/3   0     0     0     1/3 |
        | 0     0     0     1/2   0     0     0     1/2   0   |
        | 0     0     0     0     1/3   0     1/3   0     1/3 |
        \ 0     0     0     0     0     1/2   0     1/2   0   /
</pre></div>

<p>The stationary state occupancy probabilities can then be computed
with the following code:
</p>
<div class="example">
<pre class="verbatim"> P = zeros(9,9);
 P(1,[2 4]    ) = 1/2;
 P(2,[1 5 3]  ) = 1/3;
 P(3,[2 6]    ) = 1/2;
 P(4,[1 5 7]  ) = 1/3;
 P(5,[2 4 6 8]) = 1/4;
 P(6,[3 5 9]  ) = 1/3;
 P(7,[4 8]    ) = 1/2;
 P(8,[7 5 9]  ) = 1/3;
 P(9,[6 8]    ) = 1/2;
 p = dtmc(P);
 disp(p)
</pre><pre class="example">    &rArr; 0.083333   0.125000   0.083333   0.125000   
       0.166667   0.125000   0.083333   0.125000   
       0.083333
</pre></div>

<hr>
<a name="Birth_002ddeath-process-_0028DTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Expected-number-of-visits-_0028DTMC_0029" accesskey="n" rel="next">Expected number of visits (DTMC)</a>, Previous: <a href="#State-occupancy-probabilities-_0028DTMC_0029" accesskey="p" rel="prev">State occupancy probabilities (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Birth_002ddeath-process"></a>
<h4 class="subsection">3.1.2 Birth-death process</h4>

<a name="doc_002ddtmcbd"></a>

<dl>
<dt><a name="index-dtmcbd"></a>Function File: <em><var>P</var> =</em> <strong>dtmcbd</strong> <em>(<var>b</var>, <var>d</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-discrete-time-2"></a>
<a name="index-DTMC-2"></a>
<a name="index-discrete-time-Markov-chain-2"></a>
<a name="index-birth_002ddeath-process_002c-DTMC"></a>

<p>Returns the transition probability matrix <em>P</em> for a discrete
birth-death process over state space <em>1, 2, &hellip;, N</em>.
<code><var>b</var>(i)</code> is the transition probability from state
<em>i</em> to <em>i+1</em>, and <code><var>d</var>(i)</code> is the transition
probability from state <em>i+1</em> to state <em>i</em>, <em>i=1, 2,
&hellip;, N-1</em>.
</p>
<p>Matrix <em>\bf P</em> is therefore defined as:
</p>
<div class="example">
<pre class="example">/                                                             \
| 1-b(1)     b(1)                                             |
|  d(1)  (1-d(1)-b(2))     b(2)                               |
|            d(2)      (1-d(2)-b(3))     b(3)                 |
|                                                             |
|                 ...           ...          ...              |
|                                                             |
|                         d(N-2)   (1-d(N-2)-b(N-1))  b(N-1)  |
|                                        d(N-1)      1-d(N-1) |
\                                                             /
</pre></div>

<p>where <em>\lambda_i</em> and <em>\mu_i</em> are the birth and
death probabilities, respectively.
</p>
<br>
<p><strong>See also:</strong> ctmcbd.
</p>
</dd></dl>


<hr>
<a name="Expected-number-of-visits-_0028DTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029" accesskey="n" rel="next">Time-averaged expected sojourn times (DTMC)</a>, Previous: <a href="#Birth_002ddeath-process-_0028DTMC_0029" accesskey="p" rel="prev">Birth-death process (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Expected-Number-of-Visits"></a>
<h4 class="subsection">3.1.3 Expected Number of Visits</h4>

<p>Given a <em>N</em> state discrete-time Markov chain with transition
matrix <em>\bf P</em> and an integer <em>n &ge; 0</em>, we let
<em>L_i(n)</em> be the the expected number of visits to state <em>i</em>
during the first <em>n</em> transitions. The vector <em>{\bf L}(n) =
( L_1(n), L_2(n), &hellip;, L_N(n) )</em> is defined as
</p>
<div class="example">
<pre class="example">         n            n
        ___          ___
       \            \           i
L(n) =  &gt;   pi(i) =  &gt;   pi(0) P
       /___         /___
        i=0          i=0
</pre></div>

<p>where <em>{\bf \pi}(i) = {\bf \pi}(0){\bf P}^i</em> is the state 
occupancy probability after <em>i</em> transitions, and <em>{\bf
\pi}(0) = (\pi_1(0), \pi_2(0), &hellip;, \pi_N(0))</em> are the initial
state occupancy probabilities.
</p>
<p>If <em>\bf P</em> is absorbing, i.e., the stochastic process eventually
enters a state with no outgoing transitions with probability 1, then
we can compute the expected number of visits until absorption
<em>\bf L</em>. To do so, we first rearrange the states by rewriting
<em>\bf P</em> as:
</p>
<div class="example">
<pre class="example">    / Q | R \
P = |---+---|
    \ 0 | I /
</pre></div>

<p>where the first <em>t</em> states are transient
and the last <em>r</em> states are absorbing (<em>t+r = N</em>). The
matrix <em>{\bf N} = ({\bf I} - {\bf Q})^{-1}</em> is called the
<em>fundamental matrix</em>; <em>N_{i,j}</em> is the expected number of
times the process is in the <em>j</em>-th transient state assuming it
started in the <em>i</em>-th transient state. If we reshape <em>\bf N</em>
to the size of <em>\bf P</em> (filling missing entries with zeros), we
have that, for absorbing chains, <em>{\bf L} = {\bf \pi}(0){\bf N}</em>.
</p>
<a name="doc_002ddtmcexps"></a>

<dl>
<dt><a name="index-dtmcexps"></a>Function File: <em><var>L</var> =</em> <strong>dtmcexps</strong> <em>(<var>P</var>, <var>n</var>, <var>p0</var>)</em></dt>
<dt><a name="index-dtmcexps-1"></a>Function File: <em><var>L</var> =</em> <strong>dtmcexps</strong> <em>(<var>P</var>, <var>p0</var>)</em></dt>
<dd>
<a name="index-expected-sojourn-times_002c-DTMC"></a>
<a name="index-DTMC-3"></a>
<a name="index-discrete-time-Markov-chain-3"></a>
<a name="index-Markov-chain_002c-discrete-time-3"></a>

<p>Compute the expected number of visits to each state during the first
<var>n</var> transitions, or until abrosption.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p><em>N \times N</em> transition matrix. <code><var>P</var>(i,j)</code> is the
transition probability from state <em>i</em> to state <em>j</em>.
</p>
</dd>
<dt><code><var>n</var></code></dt>
<dd><p>Number of steps during which the expected number of visits are
computed (<em><var>n</var> &ge; 0</em>). If <code><var>n</var>=0</code>, returns
<var>p0</var>. If <code><var>n</var> &gt; 0</code>, returns the expected number of
visits after exactly <var>n</var> transitions.
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>Initial state occupancy probabilities; <code><var>p0</var>(i)</code> is
the probability that the system is in state <em>i</em> at step 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>L</var>(i)</code></dt>
<dd><p>When called with two arguments, <code><var>L</var>(i)</code> is the expected
number of visits to transient state <em>i</em> before absorption. When
called with three arguments, <code><var>L</var>(i)</code> is the expected number
of visits to state <em>i</em> during the first <var>n</var> transitions,
given initial occupancy probability <var>p0</var>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> ctmcexps.
</p>
</dd></dl>


<hr>
<a name="Time_002daveraged-expected-sojourn-times-_0028DTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Mean-time-to-absorption-_0028DTMC_0029" accesskey="n" rel="next">Mean time to absorption (DTMC)</a>, Previous: <a href="#Expected-number-of-visits-_0028DTMC_0029" accesskey="p" rel="prev">Expected number of visits (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Time_002daveraged-expected-sojourn-times"></a>
<h4 class="subsection">3.1.4 Time-averaged expected sojourn times</h4>

<a name="doc_002ddtmctaexps"></a>

<dl>
<dt><a name="index-dtmctaexps"></a>Function File: <em><var>M</var> =</em> <strong>dtmctaexps</strong> <em>(<var>P</var>, <var>n</var>, <var>p0</var>)</em></dt>
<dt><a name="index-dtmctaexps-1"></a>Function File: <em><var>M</var> =</em> <strong>dtmctaexps</strong> <em>(<var>P</var>, <var>p0</var>)</em></dt>
<dd>
<a name="index-time_002dalveraged-sojourn-time_002c-DTMC"></a>
<a name="index-discrete-time-Markov-chain-4"></a>
<a name="index-Markov-chain_002c-discrete-time-4"></a>
<a name="index-DTMC-4"></a>

<p>Compute the <em>time-averaged sojourn times</em> <code><var>M</var>(i)</code>,
defined as the fraction of time spent in state <em>i</em> during the
first steps <em>{0, 1, &hellip;, n}</em> (or until absorption),
assuming that the state occupancy probabilities at time 0 are
<var>p0</var>.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p><em>N \times N</em> transition probability matrix.
</p>
</dd>
<dt><code><var></var></code></dt>
<dd><p>Number of transitions during which the time-averaged expected sojourn times
are computed (<em><var>n</var> &ge; 0</em>). if <em><var>n</var> = 0</em>,
returns <var>p0</var>.
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>Initial state occupancy probabilities.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>M</var>(i)</code></dt>
<dd><p>If this function is called with three arguments, <code><var>M</var>(i)</code> is
the expected fraction of steps <em>{0, 1, &hellip;, n}</em> spent in
state <em>i</em>, assuming that the state occupancy probabilities at
time zero are <var>p0</var>. If this function is called with two
arguments, <code><var>M</var>(i)</code> is the expected fraction of steps spent
in state <em>i</em> until absorption.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> ctmctaexps.
</p>
</dd></dl>


<hr>
<a name="Mean-time-to-absorption-_0028DTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#First-passage-times-_0028DTMC_0029" accesskey="n" rel="next">First passage times (DTMC)</a>, Previous: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029" accesskey="p" rel="prev">Time-averaged expected sojourn times (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Mean-Time-to-Absorption"></a>
<h4 class="subsection">3.1.5 Mean Time to Absorption</h4>

<p>The <em>mean time to absorption</em> is defined as the average number of
transitions that are required to enter an absorbing state, starting
from a transient state (or given initial state occupancy probabilities
<em>{\bf \pi}(0)</em>).
</p>
<p>Let <em>{\bf t}_i</em> be the expected number of transitions before
being absorbed in any absorbing state, starting from state <em>i</em>.
The vector <em>\bf t</em> can be computed from the fundamental matrix
<em>\bf N</em> (see <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>) as
</p>
<p><em>t = 1 N</em>
</p>
<p>where <em>{\bf 1} = {1, 1, &hellip; 1}</em>.
</p>
<p>Let <em>{\bf B} = [ B_{i, j} ]</em> be a matrix where <em>B_{i, j}</em> is
the probability of being absorbed in state <em>j</em>, starting from
transient state <em>i</em>. Again, using matrices <em>\bf N</em> and
<em>\bf R</em> (see <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>) we can write
</p>
<p><em>B = N R</em>
</p>
<a name="doc_002ddtmcmtta"></a>

<dl>
<dt><a name="index-dtmcmtta"></a>Function File: <em>[<var>t</var> <var>N</var> <var>B</var>] =</em> <strong>dtmcmtta</strong> <em>(<var>P</var>)</em></dt>
<dt><a name="index-dtmcmtta-1"></a>Function File: <em>[<var>t</var> <var>N</var> <var>B</var>] =</em> <strong>dtmcmtta</strong> <em>(<var>P</var>, <var>p0</var>)</em></dt>
<dd>
<a name="index-mean-time-to-absorption_002c-DTMC"></a>
<a name="index-absorption-probabilities_002c-DTMC"></a>
<a name="index-fundamental-matrix"></a>
<a name="index-DTMC-5"></a>
<a name="index-discrete-time-Markov-chain-5"></a>
<a name="index-Markov-chain_002c-discrete-time-5"></a>

<p>Compute the expected number of steps before absorption for a
DTMC with state space <em>{1, 2, &hellip; N}</em> 
and transition probability matrix <var>P</var>.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p><em>N \times N</em> transition probability matrix.
<code><var>P</var>(i,j)</code> is the transition probability from state
<em>i</em> to state <em>j</em>.
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>Initial state occupancy probabilities (vector of length <em>N</em>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong> 
</p>
<dl compact="compact">
<dt><code><var>t</var></code></dt>
<dt><code><var>t</var>(i)</code></dt>
<dd><p>When called with a single argument, <var>t</var> is a vector of length
<em>N</em> such that <code><var>t</var>(i)</code> is the expected number of steps
before being absorbed in any absorbing state, starting from state
<em>i</em>; if <em>i</em> is absorbing, <code><var>t</var>(i) = 0</code>. When
called with two arguments, <var>t</var> is a scalar, and represents the
expected number of steps before absorption, starting from the initial
state occupancy probability <var>p0</var>.
</p>
</dd>
<dt><code><var>N</var>(i)</code></dt>
<dt><code><var>N</var>(i,j)</code></dt>
<dd><p>When called with a single argument, <var>N</var> is the <em>N \times N</em>
fundamental matrix for <var>P</var>. <code><var>N</var>(i,j)</code> is the expected
number of visits to transient state <var>j</var> before absorption, if it
is started in transient state <var>i</var>. The initial state is counted
if <em>i = j</em>. When called with two arguments, <var>N</var> is a vector
of size <em>N</em> such that <code><var>N</var>(j)</code> is the expected number
of visits to transient state <var>j</var> before absorption, given initial
state occupancy probability <var>P0</var>.
</p>
</dd>
<dt><code><var>B</var>(i)</code></dt>
<dt><code><var>B</var>(i,j)</code></dt>
<dd><p>When called with a single argument, <var>B</var> is a <em>N \times N</em>
matrix where <code><var>B</var>(i,j)</code> is the probability of being
absorbed in state <em>j</em>, starting from transient state <em>i</em>;
if <em>j</em> is not absorbing, <code><var>B</var>(i,j) = 0</code>; if <em>i</em>
is absorbing, <code><var>B</var>(i,i) = 1</code> and <code><var>B</var>(i,j) = 0</code>
for all <em>j \neq j</em>. When called with two arguments, <var>B</var> is
a vector of size <em>N</em> where <code><var>B</var>(j)</code> is the
probability of being absorbed in state <var>j</var>, given initial state
occupancy probabilities <var>p0</var>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> ctmcmtta.
</p>
</dd></dl>


<hr>
<a name="First-passage-times-_0028DTMC_0029"></a>
<div class="header">
<p>
Previous: <a href="#Mean-time-to-absorption-_0028DTMC_0029" accesskey="p" rel="prev">Mean time to absorption (DTMC)</a>, Up: <a href="#Discrete_002dTime-Markov-Chains" accesskey="u" rel="up">Discrete-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="First-Passage-Times"></a>
<h4 class="subsection">3.1.6 First Passage Times</h4>

<p>The First Passage Time <em>M_{i, j}</em> is the average number of
transitions needed to enter state <em>j</em> for the first time,
starting from state <em>i</em>. Matrix <em>\bf M</em> satisfies the
property
</p>
<div class="example">
<pre class="example">           ___
          \
M_ij = 1 + &gt;   P_ij * M_kj
          /___
          k!=j
</pre></div>

<p>To compute <em>{\bf M} = [ M_{i, j}]</em> a different formulation is
used.  Let <em>\bf W</em> be the <em>N \times N</em> matrix having each
row equal to the stationary state occupancy probability vector
<em>\bf \pi</em> for <em>\bf P</em>; let <em>\bf I</em> be the <em>N
\times N</em> identity matrix (i.e., the matrix of all ones). Define
<em>\bf Z</em> as follows:
</p>
<div class="example">
<pre class="example">               -1
Z = (I - P + W)
</pre></div>

<p>Then, we have that
</p>
<div class="example">
<pre class="example">       Z_jj - Z_ij
M_ij = -----------
          \pi_j
</pre></div>

<p>According to the definition above, <em>M_{i,i} = 0</em>. We arbitrarily
set <em>M_{i,i}</em> to the <em>mean recurrence time</em> <em>r_i</em> for
state <em>i</em>, that is the average number of transitions needed to
return to state <em>i</em> starting from it. <em>r_i</em> is:
</p>
<div class="example">
<pre class="example">        1
r_i = -----
      \pi_i
</pre></div>

<a name="doc_002ddtmcfpt"></a>

<dl>
<dt><a name="index-dtmcfpt"></a>Function File: <em><var>M</var> =</em> <strong>dtmcfpt</strong> <em>(<var>P</var>)</em></dt>
<dd>
<a name="index-first-passage-times"></a>
<a name="index-mean-recurrence-times"></a>
<a name="index-discrete-time-Markov-chain-6"></a>
<a name="index-Markov-chain_002c-discrete-time-6"></a>
<a name="index-DTMC-6"></a>

<p>Compute mean first passage times and mean recurrence times
for an irreducible discrete-time Markov chain over the state space
<em>{, 1, &hellip;, N}</em>.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>transition probability from state <em>i</em> to state <em>j</em>.
<var>P</var> must be an irreducible stochastic matrix, which means that
the sum of each row must be 1 (<em>\sum_{j=1}^N P_{i j} = 1</em>),
and the rank of <var>P</var> must be <em>N</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>M</var>(i,j)</code></dt>
<dd><p>For all <em>1 &le; i \neq j &le; N</em>, <code><var>M</var>(i,j)</code> is
the average number of transitions before state <var>j</var> is entered
for the first time, starting from state <var>i</var>.
<code><var>M</var>(i,i)</code> is the <em>mean recurrence time</em> of state
<em>i</em>, and represents the average time needed to return to state
<var>i</var>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> ctmcfpt.
</p>
</dd></dl>


<hr>
<a name="Continuous_002dTime-Markov-Chains"></a>
<div class="header">
<p>
Previous: <a href="#Discrete_002dTime-Markov-Chains" accesskey="p" rel="prev">Discrete-Time Markov Chains</a>, Up: <a href="#Markov-Chains" accesskey="u" rel="up">Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Continuous_002dTime-Markov-Chains-1"></a>
<h3 class="section">3.2 Continuous-Time Markov Chains</h3>

<p>A stochastic process <em>{X(t), t &ge; 0}</em> is a continuous-time
Markov chain if, for all integers <em>n</em>, and for any sequence
<em>t_0, t_1 , &hellip;, t_n, t_{n+1}</em> such that <em>t_0 &lt; t_1 &lt;
&hellip; &lt; t_n &lt; t_{n+1}</em>, we have
</p>
<p><em>P(X_{n+1} = x_{n+1} | X_n = x_n, X_{n-1} = x_{n-1}, ..., X_0 = x_0) = P(X_{n+1} = x_{n+1} | X_n = x_n)</em>
</p>
<p>A continuous-time Markov chain is defined according to an
<em>infinitesimal generator matrix</em> <em>{\bf Q} = [Q_{i,j}]</em>,
where for each <em>i \neq j</em>, <em>Q_{i, j}</em> is the transition rate
from state <em>i</em> to state <em>j</em>. The matrix <em>\bf Q</em> must
satisfy the property that, for all <em>i</em>, <em>\sum_{j=1}^N Q_{i,
j} = 0</em>.
</p>
<a name="doc_002dctmcchkQ"></a>

<dl>
<dt><a name="index-ctmcchkQ"></a>Function File: <em>[<var>result</var> <var>err</var>] =</em> <strong>ctmcchkQ</strong> <em>(<var>Q</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time"></a>

<p>If <var>Q</var> is a valid infinitesimal generator matrix, return
the size (number of rows or columns) of <var>Q</var>. If <var>Q</var> is not
an infinitesimal generator matrix, set <var>result</var> to zero, and
<var>err</var> to an appropriate error string.
</p>
</dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#State-occupancy-probabilities-_0028CTMC_0029" accesskey="1">State occupancy probabilities (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Birth_002ddeath-process-_0028CTMC_0029" accesskey="2">Birth-death process (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Expected-sojourn-times-_0028CTMC_0029" accesskey="3">Expected sojourn times (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029" accesskey="4">Time-averaged expected sojourn times (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Mean-time-to-absorption-_0028CTMC_0029" accesskey="5">Mean time to absorption (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#First-passage-times-_0028CTMC_0029" accesskey="6">First passage times (CTMC)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="State-occupancy-probabilities-_0028CTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Birth_002ddeath-process-_0028CTMC_0029" accesskey="n" rel="next">Birth-death process (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="State-occupancy-probabilities-1"></a>
<h4 class="subsection">3.2.1 State occupancy probabilities</h4>

<p>Similarly to the discrete case, we denote with <em>{\bf \pi}(t) =
(\pi_1(t), \pi_2(t), &hellip;, \pi_N(t) )</em> the <em>state occupancy
probability vector</em> at time <em>t</em>. <em>\pi_i(t)</em> is the
probability that the system is in state <em>i</em> at time <em>t
&ge; 0</em>.
</p>
<p>Given the infinitesimal generator matrix <em>\bf Q</em> and initial
state occupancy probabilities <em>{\bf \pi}(0) = (\pi_1(0),
\pi_2(0), &hellip;, \pi_N(0))</em>, the occupancy probabilities
<em>{\bf \pi}(t)</em> at time <em>t</em> can be computed as:
</p>
<div class="example">
<pre class="example">\pi(t) = \pi(0) exp(Qt)
</pre></div>

<p>where <em>\exp( {\bf Q} t )</em> is the matrix exponential
of <em>{\bf Q} t</em>. Under certain conditions, there exists a
<em>stationary state occupancy probability</em> <em>{\bf \pi} =
\lim_{t \rightarrow +\infty} {\bf \pi}(t)</em> that is independent from
<em>{\bf \pi}(0)</em>.  <em>\bf \pi</em> is the solution of the following
linear system:
</p>
<div class="example">
<pre class="example">/
| \pi Q   = 0
| \pi 1^T = 1
\
</pre></div>

<a name="doc_002dctmc"></a>

<dl>
<dt><a name="index-ctmc"></a>Function File: <em><var>p</var> =</em> <strong>ctmc</strong> <em>(<var>Q</var>)</em></dt>
<dt><a name="index-ctmc-1"></a>Function File: <em><var>p</var> =</em> <strong>ctmc</strong> <em>(<var>Q</var>, <var>t</var>. <var>p0</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time-1"></a>
<a name="index-continuous-time-Markov-chain"></a>
<a name="index-Markov-chain_002c-state-occupancy-probabilities"></a>
<a name="index-stationary-probabilities"></a>
<a name="index-CTMC"></a>

<p>Compute stationary or transient state occupancy probabilities for a continuous-time Markov chain.
</p>
<p>With a single argument, compute the stationary state occupancy
probabilitiesr <em><var>p</var>(1), &hellip;, <var>p</var>(N)</em> for a
continuous-time Markov chain with state space <em>{1, 2, &hellip;,
N}</em> and <em>N \times N</em> infinitesimal generator matrix <var>Q</var>.
With three arguments, compute the state occupancy probabilities
<em><var>p</var>(1), &hellip;, <var>p</var>(N)</em> that the system is in state <em>i</em>
at time <var>t</var>, given initial state occupancy probabilities
<em><var>p0</var>(1), &hellip;, <var>p0</var>(N)</em> at time 0.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Q</var>(i,j)</code></dt>
<dd><p>Infinitesimal generator matrix. <var>Q</var> is a <em>N \times N</em> square
matrix where <code><var>Q</var>(i,j)</code> is the transition rate from state
<em>i</em> to state <em>j</em>, for <em>1 &le; i \neq j &le; N</em>.
<var>Q</var> must satisfy the property that <em>\sum_{j=1}^N Q_{i, j} =
0</em>
</p>
</dd>
<dt><code><var>t</var></code></dt>
<dd><p>Time at which to compute the transient probability (<em>t &ge;
0</em>). If omitted, the function computes the steady state occupancy
probability vector.
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>probability that the system is in state <em>i</em> at time 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>p</var>(i)</code></dt>
<dd><p>If this function is invoked with a single argument, <code><var>p</var>(i)</code>
is the steady-state probability that the system is in state <em>i</em>,
<em>i = 1, &hellip;, N</em>. If this function is invoked with three
arguments, <code><var>p</var>(i)</code> is the probability that the system is in
state <em>i</em> at time <var>t</var>, given the initial occupancy
probabilities <var>p0</var>(1), &hellip;, <var>p0</var>(N).
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> dtmc.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<p>Consider a two-state CTMC where all transition rates between states
are equal to 1. The stationary state occupancy probabilities can be
computed as follows:
</p>
<div class="example">
<pre class="verbatim"> Q = [ -1  1; ...
        1 -1  ];
 q = ctmc(Q)
</pre><pre class="example">    &rArr; q = 0.50000   0.50000
</pre></div>

<hr>
<a name="Birth_002ddeath-process-_0028CTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Expected-sojourn-times-_0028CTMC_0029" accesskey="n" rel="next">Expected sojourn times (CTMC)</a>, Previous: <a href="#State-occupancy-probabilities-_0028CTMC_0029" accesskey="p" rel="prev">State occupancy probabilities (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Birth_002dDeath-Process"></a>
<h4 class="subsection">3.2.2 Birth-Death Process</h4>

<a name="doc_002dctmcbd"></a>

<dl>
<dt><a name="index-ctmcbd"></a>Function File: <em><var>Q</var> =</em> <strong>ctmcbd</strong> <em>(<var>b</var>, <var>d</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time-2"></a>
<a name="index-continuous-time-Markov-chain-1"></a>
<a name="index-CTMC-1"></a>
<a name="index-birth_002ddeath-process_002c-CTMC"></a>

<p>Returns the infinitesimal generator matrix <em>Q</em> for a continuous
birth-death process over the state space <em>{1, 2, &hellip;, N}</em>.
<code><var>b</var>(i)</code> is the transition rate from state <em>i</em> to
<em>i+1</em>, and <code><var>d</var>(i)</code> is the transition rate from state
<em>i+1</em> to state <em>i</em>, <em>i=1, 2, &hellip;, N-1</em>.
</p>
<p>Matrix <em>\bf Q</em> is therefore defined as:
</p>

<div class="example">
<pre class="example">/                                                          \
| -b(1)     b(1)                                           |
|  d(1) -(d(1)+b(2))     b(2)                              |
|           d(2)     -(d(2)+b(3))        b(3)              |
|                                                          |
|                ...           ...          ...            |
|                                                          |
|                       d(N-2)    -(d(N-2)+b(N-1))  b(N-1) |
|                                       d(N-1)     -d(N-1) |
\                                                          /
</pre></div>

<p>where <em>\lambda_i</em> and <em>\mu_i</em> are the birth and
death rates, respectively.
</p>
<br>
<p><strong>See also:</strong> dtmcbd.
</p>
</dd></dl>


<hr>
<a name="Expected-sojourn-times-_0028CTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029" accesskey="n" rel="next">Time-averaged expected sojourn times (CTMC)</a>, Previous: <a href="#Birth_002ddeath-process-_0028CTMC_0029" accesskey="p" rel="prev">Birth-death process (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Expected-Sojourn-Times"></a>
<h4 class="subsection">3.2.3 Expected Sojourn Times</h4>

<p>Given a <em>N</em> state continuous-time Markov Chain with infinitesimal
generator matrix <em>\bf Q</em>, we define the vector <em>{\bf L}(t) =
(L_1(t), L_2(t), &hellip;, L_N(t))</em> such that <em>L_i(t)</em> is the
expected sojourn time in state <em>i</em> during the interval
<em>[0,t)</em>, assuming that the initial occupancy probability at time
0 was <em>{\bf \pi}(0)</em>. <em>{\bf L}(t)</em> can be expressed as the
solution of the following differential equation:
</p>
<div class="example">
<pre class="example"> dL
 --(t) = L(t) Q + pi(0),    L(0) = 0
 dt
</pre></div>

<p>Alternatively, <em>{\bf L}(t)</em> can also be expressed in integral
form as:
</p>
<div class="example">
<pre class="example">       / t
L(t) = |   pi(u) du
       / 0
</pre></div>

<p>where <em>{\bf \pi}(t) = {\bf \pi}(0) \exp({\bf Q}t)</em> is
the state occupancy probability at time <em>t</em>; <em>\exp({\bf Q}t)</em>
is the matrix exponential of <em>{\bf Q}t</em>.
</p>
<p>If there are absorbing states, we can define the vector of
<em>expected sojourn times until absorption</em> <em>{\bf L}(\infty)</em>,
where for each transient state <em>i</em>, <em>L_i(\infty)</em> is the
expected total time spent in state <em>i</em> until absorption, assuming
that the system started with given state occupancy probabilities
<em>{\bf \pi}(0)</em>. Let <em>\tau</em> be the set of transient (i.e.,
non absorbing) states; let <em>{\bf Q}_\tau</em> be the restriction of
<em>\bf Q</em> to the transient sub-states only. Similarly, let
<em>{\bf \pi}_\tau(0)</em> be the restriction of the initial state
occupancy probability vector <em>{\bf \pi}(0)</em> to transient states
<em>\tau</em>.
</p>
<p>The expected time to absorption <em>{\bf L}_\tau(\infty)</em> is defined as
the solution of the following equation:
</p>
<div class="example">
<pre class="example">L_T( inf ) Q_T = -pi_T(0)
</pre></div>

<a name="doc_002dctmcexps"></a>

<dl>
<dt><a name="index-ctmcexps"></a>Function File: <em><var>L</var> =</em> <strong>ctmcexps</strong> <em>(<var>Q</var>, <var>t</var>, <var>p</var> )</em></dt>
<dt><a name="index-ctmcexps-1"></a>Function File: <em><var>L</var> =</em> <strong>ctmcexps</strong> <em>(<var>Q</var>, <var>p</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time-3"></a>
<a name="index-expected-sojourn-time_002c-CTMC"></a>

<p>With three arguments, compute the expected times <code><var>L</var>(i)</code>
spent in each state <em>i</em> during the time interval <em>[0,t]</em>,
assuming that the initial occupancy vector is <var>p</var>. With two
arguments, compute the expected time <code><var>L</var>(i)</code> spent in each
transient state <em>i</em> until absorption.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Q</var>(i,j)</code></dt>
<dd><p><em>N \times N</em> infinitesimal generator matrix. <code><var>Q</var>(i,j)</code>
is the transition rate from state <em>i</em> to state <em>j</em>, <em>1
&le; i \neq j &le; N</em>. The matrix <var>Q</var> must also satisfy the
condition <em>\sum_{j=1}^N Q_{ij} = 0</em>.
</p>
</dd>
<dt><code><var>t</var></code></dt>
<dd><p>If given, compute the expected sojourn times in <em>[0,t]</em>
</p>
</dd>
<dt><code><var>p</var>(i)</code></dt>
<dd><p>Initial occupancy probability vector; <code><var>p</var>(i)</code> is the
probability the system is in state <em>i</em> at time 0, <em>i = 1,
&hellip;, N</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>L</var>(i)</code></dt>
<dd><p>If this function is called with three arguments, <code><var>L</var>(i)</code> is
the expected time spent in state <em>i</em> during the interval
<em>[0,t]</em>. If this function is called with two arguments
<code><var>L</var>(i)</code> is the expected time spent in transient state
<em>i</em> until absorption; if state <em>i</em> is absorbing,
<code><var>L</var>(i)</code> is zero.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> dtmcexps.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<p>Let us consider a 4-states pure birth continuous process where the
transition rate from state <em>i</em> to state <em>i+1</em> is
<em>\lambda_i = i \lambda</em> (<em>i=1, 2, 3</em>), with <em>\lambda =
0.5</em>. The following code computes the expected sojourn time for each
state <em>i</em>, given initial occupancy probabilities <em>{\bf
\pi}_0=(1,0,0,0)</em>.
</p>
<div class="example">
<pre class="verbatim"> lambda = 0.5;
 N = 4;
 b = lambda*[1:N-1];
 d = zeros(size(b));
 Q = ctmcbd(b,d);
 t = linspace(0,10,100);
 p0 = zeros(1,N); p0(1)=1;
 L = zeros(length(t),N);
 for i=1:length(t)
   L(i,:) = ctmcexps(Q,t(i),p0);
 endfor
 plot( t, L(:,1), &quot;;State 1;&quot;, &quot;linewidth&quot;, 2, ...
       t, L(:,2), &quot;;State 2;&quot;, &quot;linewidth&quot;, 2, ...
       t, L(:,3), &quot;;State 3;&quot;, &quot;linewidth&quot;, 2, ...
       t, L(:,4), &quot;;State 4;&quot;, &quot;linewidth&quot;, 2 );
 legend(&quot;location&quot;,&quot;northwest&quot;); legend(&quot;boxoff&quot;);
 xlabel(&quot;Time&quot;);
 ylabel(&quot;Expected sojourn time&quot;);
</pre></div>

<hr>
<a name="Time_002daveraged-expected-sojourn-times-_0028CTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#Mean-time-to-absorption-_0028CTMC_0029" accesskey="n" rel="next">Mean time to absorption (CTMC)</a>, Previous: <a href="#Expected-sojourn-times-_0028CTMC_0029" accesskey="p" rel="prev">Expected sojourn times (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Time_002dAveraged-Expected-Sojourn-Times"></a>
<h4 class="subsection">3.2.4 Time-Averaged Expected Sojourn Times</h4>

<a name="doc_002dctmctaexps"></a>

<dl>
<dt><a name="index-ctmctaexps"></a>Function File: <em><var>M</var> =</em> <strong>ctmctaexps</strong> <em>(<var>Q</var>, <var>t</var>, <var>p0</var>)</em></dt>
<dt><a name="index-ctmctaexps-1"></a>Function File: <em><var>M</var> =</em> <strong>ctmctaexps</strong> <em>(<var>Q</var>, <var>p0</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time-4"></a>
<a name="index-time_002dalveraged-sojourn-time_002c-CTMC"></a>
<a name="index-continuous-time-Markov-chain-2"></a>
<a name="index-CTMC-2"></a>

<p>Compute the <em>time-averaged sojourn time</em> <code><var>M</var>(i)</code>,
defined as the fraction of the time interval <em>[0,t]</em> (or until
absorption) spent in state <em>i</em>, assuming that the state
occupancy probabilities at time 0 are <var>p</var>.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Q</var>(i,j)</code></dt>
<dd><p>Infinitesimal generator matrix. <code><var>Q</var>(i,j)</code> is the transition
rate from state <em>i</em> to state <em>j</em>,
<em>1 &le; i \neq j &le; N</em>. The
matrix <var>Q</var> must also satisfy the condition <em>\sum_{j=1}^N Q_{ij} = 0</em>
</p>
</dd>
<dt><code><var>t</var></code></dt>
<dd><p>Time. If omitted, the results are computed until absorption.
</p>
</dd>
<dt><code><var>p0</var>(i)</code></dt>
<dd><p>initial state occupancy probabilities. <code><var>p0</var>(i)</code> is the
probability that the system is in state <em>i</em> at time 0, <em>i
= 1, &hellip;, N</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>M</var>(i)</code></dt>
<dd><p>When called with three arguments, <code><var>M</var>(i)</code> is the expected
fraction of the interval <em>[0,t]</em> spent in state <em>i</em>
assuming that the state occupancy probability at time zero is
<var>p</var>. When called with two arguments, <code><var>M</var>(i)</code> is the
expected fraction of time until absorption spent in state <em>i</em>;
in this case the mean time to absorption is <code>sum(<var>M</var>)</code>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> dtmctaexps.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<div class="example">
<pre class="verbatim"> lambda = 0.5;
 N = 4;
 birth = lambda*linspace(1,N-1,N-1);
 death = zeros(1,N-1);
 Q = diag(birth,1)+diag(death,-1);
 Q -= diag(sum(Q,2));
 t = linspace(1e-5,30,100);
 p = zeros(1,N); p(1)=1;
 M = zeros(length(t),N);
 for i=1:length(t)
   M(i,:) = ctmctaexps(Q,t(i),p);
 endfor
 clf;
 plot(t, M(:,1), &quot;;State 1;&quot;, &quot;linewidth&quot;, 2, ...
      t, M(:,2), &quot;;State 2;&quot;, &quot;linewidth&quot;, 2, ...
      t, M(:,3), &quot;;State 3;&quot;, &quot;linewidth&quot;, 2, ...
      t, M(:,4), &quot;;State 4 (absorbing);&quot;, &quot;linewidth&quot;, 2 );
 legend(&quot;location&quot;,&quot;east&quot;); legend(&quot;boxoff&quot;);
 xlabel(&quot;Time&quot;);
 ylabel(&quot;Time-averaged Expected sojourn time&quot;);
</pre></div>

<hr>
<a name="Mean-time-to-absorption-_0028CTMC_0029"></a>
<div class="header">
<p>
Next: <a href="#First-passage-times-_0028CTMC_0029" accesskey="n" rel="next">First passage times (CTMC)</a>, Previous: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029" accesskey="p" rel="prev">Time-averaged expected sojourn times (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Mean-Time-to-Absorption-1"></a>
<h4 class="subsection">3.2.5 Mean Time to Absorption</h4>

<a name="doc_002dctmcmtta"></a>

<dl>
<dt><a name="index-ctmcmtta"></a>Function File: <em><var>t</var> =</em> <strong>ctmcmtta</strong> <em>(<var>Q</var>, <var>p</var>)</em></dt>
<dd>
<a name="index-Markov-chain_002c-continuous-time-5"></a>
<a name="index-continuous-time-Markov-chain-3"></a>
<a name="index-CTMC-3"></a>
<a name="index-mean-time-to-absorption_002c-CTMC"></a>

<p>Compute the Mean-Time to Absorption (MTTA) of the CTMC described by
the infinitesimal generator matrix <var>Q</var>, starting from initial
occupancy probabilities <var>p</var>. If there are no absorbing states, this
function fails with an error.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Q</var>(i,j)</code></dt>
<dd><p><em>N \times N</em> infinitesimal generator matrix. <code><var>Q</var>(i,j)</code>
is the transition rate from state <em>i</em> to state <em>j</em>, <em>i
\neq j</em>. The matrix <var>Q</var> must satisfy the condition
<em>\sum_{j=1}^N Q_{i j} = 0</em>
</p>
</dd>
<dt><code><var>p</var>(i)</code></dt>
<dd><p>probability that the system is in state <em>i</em>
at time 0, for each <em>i=1, &hellip;, N</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>t</var></code></dt>
<dd><p>Mean time to absorption of the process represented by matrix <var>Q</var>.
If there are no absorbing states, this function fails.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> dtmcmtta.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<p>Let us consider a simple model of redundant disk array. We assume that
the array is made of 5 independent disks and can tolerate up to 2 disk
failures without losing data. If three or more disks break, the array
is dead and unrecoverable. We want to estimate the
Mean-Time-To-Failure (MTTF) of the disk array.
</p>
<p>We model this system as a 4 states continuous Markov chain with state
space <em>{ 2, 3, 4, 5 }</em>. In state <em>i</em> there are exactly
<em>i</em> active (i.e., non failed) disks; state <em>2</em> is
absorbing. Let <em>\mu</em> be the failure rate of a single disk. The
system starts in state <em>5</em> (all disks are operational). We use a
pure death process, where the death rate from state <em>i</em> to state
<em>i-1</em> is <em>\mu i</em>, for <em>i = 3, 4, 5</em>).
</p>
<p>The MTTF of the disk array is the MTTA of the Markov Chain, and can be
computed as follows:
</p>
<div class="example">
<pre class="verbatim"> mu = 0.01;
 death = [ 3 4 5 ] * mu;
 birth = 0*death;
 Q = ctmcbd(birth,death);
 t = ctmcmtta(Q,[0 0 0 1])
</pre><pre class="example">    &rArr; t = 78.333
</pre></div>

<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998.

<a name="index-Bolch_002c-G_002e"></a>
<a name="index-Greiner_002c-S_002e"></a>
<a name="index-de-Meer_002c-H_002e"></a>
<a name="index-Trivedi_002c-K_002e"></a>

</li></ul>

<hr>
<a name="First-passage-times-_0028CTMC_0029"></a>
<div class="header">
<p>
Previous: <a href="#Mean-time-to-absorption-_0028CTMC_0029" accesskey="p" rel="prev">Mean time to absorption (CTMC)</a>, Up: <a href="#Continuous_002dTime-Markov-Chains" accesskey="u" rel="up">Continuous-Time Markov Chains</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="First-Passage-Times-1"></a>
<h4 class="subsection">3.2.6 First Passage Times</h4>

<a name="doc_002dctmcfpt"></a>

<dl>
<dt><a name="index-ctmcfpt"></a>Function File: <em><var>M</var> =</em> <strong>ctmcfpt</strong> <em>(<var>Q</var>)</em></dt>
<dt><a name="index-ctmcfpt-1"></a>Function File: <em><var>m</var> =</em> <strong>ctmcfpt</strong> <em>(<var>Q</var>, <var>i</var>, <var>j</var>)</em></dt>
<dd>
<a name="index-first-passage-times_002c-CTMC"></a>
<a name="index-CTMC-4"></a>
<a name="index-continuous-time-Markov-chain-4"></a>
<a name="index-Markov-chain_002c-continuous-time-6"></a>

<p>Compute mean first passage times for an irreducible continuous-time
Markov chain.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Q</var>(i,j)</code></dt>
<dd><p>Infinitesimal generator matrix. <var>Q</var> is a <em>N \times N</em> square
matrix where <code><var>Q</var>(i,j)</code> is the transition rate from state
<em>i</em> to state <em>j</em>, for <em>1 &le; i \neq j &le; N</em>.
Transition rates must be nonnegative, and <em>\sum_{j=1}^N Q_{i j} = 0</em>
</p>
</dd>
<dt><code><var>i</var></code></dt>
<dd><p>Initial state.
</p>
</dd>
<dt><code><var>j</var></code></dt>
<dd><p>Destination state.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>M</var>(i,j)</code></dt>
<dd><p>average time before state
<var>j</var> is visited for the first time, starting from state <var>i</var>.
We let <code><var>M</var>(i,i) = 0</code>.
</p>
</dd>
<dt><code>m</code></dt>
<dd><p><var>m</var> is the average time before state <var>j</var> is visited for the first 
time, starting from state <var>i</var>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> dtmcfpt.
</p>
</dd></dl>





<hr>
<a name="Single-Station-Queueing-Systems"></a>
<div class="header">
<p>
Next: <a href="#Queueing-Networks" accesskey="n" rel="next">Queueing Networks</a>, Previous: <a href="#Markov-Chains" accesskey="p" rel="prev">Markov Chains</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Single-Station-Queueing-Systems-1"></a>
<h2 class="chapter">4 Single Station Queueing Systems</h2>

<p>Single Station Queueing Systems contain a single station, and can
usually be analyzed easily. The <code>queueing</code> package contains
functions for handling the following types of queues:
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fM_002f1-System" accesskey="1">The M/M/1 System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Single-server queueing station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fM_002fm-System" accesskey="2">The M/M/m System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Multiple-server queueing station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Erlang_002dB-Formula" accesskey="3">The Erlang-B Formula</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Erlang_002dC-Formula" accesskey="4">The Erlang-C Formula</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Engset-Formula" accesskey="5">The Engset Formula</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fM_002finf-System" accesskey="6">The M/M/inf System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Infinite-server (delay center) station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fM_002f1_002fK-System" accesskey="7">The M/M/1/K System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Single-server, finite-capacity queueing station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fM_002fm_002fK-System" accesskey="8">The M/M/m/K System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Multiple-server, finite-capacity queueing station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Asymmetric-M_002fM_002fm-System" accesskey="9">The Asymmetric M/M/m System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Asymmetric multiple-server queueing station.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fG_002f1-System">The M/G/1 System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Single-server with general service time distribution.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Single-server with hyperexponential service time distribution.
</td></tr>
</table>

<hr>
<a name="The-M_002fM_002f1-System"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fM_002fm-System" accesskey="n" rel="next">The M/M/m System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fM_002f1-System-1"></a>
<h3 class="section">4.1 The <em>M/M/1</em> System</h3>

<p>The <em>M/M/1</em> system contains a single server connected to an
unbounded FCFS queue. Requests arrive according to a Poisson process
with rate <em>\lambda</em>; the service time is exponentially
distributed with average service rate <em>\mu</em>. The system is stable
if <em>\lambda &lt; \mu</em>.
</p>
<a name="doc_002dqsmm1"></a>

<dl>
<dt><a name="index-qsmm1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] =</em> <strong>qsmm1</strong> <em>(<var>lambda</var>, <var>mu</var>)</em></dt>
<dd>
<a name="index-M_002fM_002f1-system"></a>

<p>Compute utilization, response time, average number of requests and throughput for a <em>M/M/1</em> queue.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var> &ge; 0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p>Service rate (<code><var>mu</var> &gt; <var>lambda</var></code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Server utilization
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Server response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Server throughput. If the system is ergodic (<code><var>mu</var> &gt;
<var>lambda</var></code>), we always have <code><var>X</var> = <var>lambda</var></code>
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>Steady-state probability that there are no requests in the system.
</p>
</dd>
</dl>

<p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmmm, qsmminf, qsmmmk.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.3.

<a name="index-Bolch_002c-G_002e-1"></a>
<a name="index-Greiner_002c-S_002e-1"></a>
<a name="index-de-Meer_002c-H_002e-1"></a>
<a name="index-Trivedi_002c-K_002e-1"></a>

</li></ul>

<hr>
<a name="The-M_002fM_002fm-System"></a>
<div class="header">
<p>
Next: <a href="#The-Erlang_002dB-Formula" accesskey="n" rel="next">The Erlang-B Formula</a>, Previous: <a href="#The-M_002fM_002f1-System" accesskey="p" rel="prev">The M/M/1 System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fM_002fm-System-1"></a>
<h3 class="section">4.2 The <em>M/M/m</em> System</h3>

<p>The <em>M/M/m</em> system is similar to the <em>M/M/1</em> system, except
that there are <em>m \geq 1</em> identical servers connected to a shared
FCFS queue. Thus, at most <em>m</em> requests can be served at the same
time. The <em>M/M/m</em> system can be seen as a single server with
load-dependent service rate <em>\mu(n)</em>, which is a function of the
number <em>n</em> of requests in the system:
</p>
<div class="example">
<pre class="example">mu(n) = min(m,n)*mu
</pre></div>

<p>where <em>\mu</em> is the service rate of each individual server.
</p>
<a name="doc_002dqsmmm"></a>

<dl>
<dt><a name="index-qsmmm"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] =</em> <strong>qsmmm</strong> <em>(<var>lambda</var>, <var>mu</var>)</em></dt>
<dt><a name="index-qsmmm-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] =</em> <strong>qsmmm</strong> <em>(<var>lambda</var>, <var>mu</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-M_002fM_002fm-system"></a>

<p>Compute utilization, response time, average number of requests in
service and throughput for a <em>M/M/m</em> queue, a queueing system
with <em>m</em> identical servers connected to a single FCFS
queue.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p>Service rate (<code><var>mu</var>&gt;<var>lambda</var></code>).
</p>
</dd>
<dt><var>m</var></dt>
<dd><p>Number of servers (<code><var>m</var> &ge; 1</code>).
If omitted, it is assumed <code><var>m</var>=1</code>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Service center utilization, <em>U = \lambda / (m \mu)</em>.
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Service center throughput. If the system is ergodic, 
we will always have <code><var>X</var> = <var>lambda</var></code>
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>Steady-state probability that there are 0 requests in the system
</p>
</dd>
<dt><var>pm</var></dt>
<dd><p>Steady-state probability that an arriving request has to wait in the
queue
</p>
</dd>
</dl>

<p><var>lambda</var>, <var>mu</var> and <var>m</var> can be vectors of the same size. In this
case, the results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> erlangc,qsmm1,qsmminf,qsmmmk.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.5.

<a name="index-Bolch_002c-G_002e-2"></a>
<a name="index-Greiner_002c-S_002e-2"></a>
<a name="index-de-Meer_002c-H_002e-2"></a>
<a name="index-Trivedi_002c-K_002e-2"></a>

</li></ul>

<hr>
<a name="The-Erlang_002dB-Formula"></a>
<div class="header">
<p>
Next: <a href="#The-Erlang_002dC-Formula" accesskey="n" rel="next">The Erlang-C Formula</a>, Previous: <a href="#The-M_002fM_002fm-System" accesskey="p" rel="prev">The M/M/m System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-Erlang_002dB-Formula-1"></a>
<h3 class="section">4.3 The Erlang-B Formula</h3>

<a name="doc_002derlangb"></a>

<dl>
<dt><a name="index-erlangb"></a>Function File: <em><var>B</var> =</em> <strong>erlangb</strong> <em>(<var>A</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-Erlang_002dB-formula"></a>

<p>Compute the value of the Erlang-B formula <em>E_B(A, m)</em> giving the
probability that an open system with <em>m</em> identical servers,
arrival rate <em>\lambda</em>, individual service rate <em>\mu</em>
and offered load <em>A = \lambda / \mu</em> has all servers busy.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>A</var></dt>
<dd><p>Offered load, defined as <em>A = \lambda / \mu</em> where
<em>\lambda</em> is the mean arrival rate and <em>\mu</em> the mean
service rate of each individual server (real, <em>A &gt; 0</em>).
</p>
</dd>
<dt><var>m</var></dt>
<dd><p>Number of identical servers (integer, <em>m &ge; 1</em>). Default <em>m = 1</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>B</var></dt>
<dd><p>The value <em>E_B(A, m)</em>
</p>
</dd>
</dl>

<p><var>A</var> or <var>m</var> can be vectors, and in this case, the results will
be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmmm.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Zeng, <cite>Two common properties of the erlang-B function, erlang-C function, and Engset blocking function</cite>, Mathematical and Computer Modelling, Volume 37, Issues 12-13, June 2003, Pages 1287-1296

<a name="index-Zeng_002c-G_002e"></a>

</li></ul>

<hr>
<a name="The-Erlang_002dC-Formula"></a>
<div class="header">
<p>
Next: <a href="#The-Engset-Formula" accesskey="n" rel="next">The Engset Formula</a>, Previous: <a href="#The-Erlang_002dB-Formula" accesskey="p" rel="prev">The Erlang-B Formula</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-Erlang_002dC-Formula-1"></a>
<h3 class="section">4.4 The Erlang-C Formula</h3>

<a name="doc_002derlangc"></a>

<dl>
<dt><a name="index-erlangc"></a>Function File: <em><var>C</var> =</em> <strong>erlangc</strong> <em>(<var>A</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-Erlang_002dC-formula"></a>

<p>Compute the steady-state probability <em>E_C(A, m)</em> that an open
queueing system with <em>m</em> identical servers, infinite wating
space, arrival rate <em>\lambda</em>, individual service rate
<em>\mu</em> and offered load <em>A = \lambda / \mu</em> has all the
servers busy.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>A Offered load. <em>A = \lambda / \mu</em> where</var></dt>
<dd><p><em>\lambda</em> is the mean arrival rate and <em>\mu</em> the mean
service rate of each individual server (real, <em>0 &lt; A &lt; m</em>).
</p>
</dd>
<dt><var>m Number of identical servers (integer, <em>m &ge; 1</em>).</var></dt>
<dd><p>Default <em>m = 1</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>B The value <em>E_C(A, m)</em></var></dt>
</dl>

<p><var>A</var> or <var>m</var> can be vectors, and in this case, the results will
be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmmm.
</p>
</dd></dl>


<hr>
<a name="The-Engset-Formula"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fM_002finf-System" accesskey="n" rel="next">The M/M/inf System</a>, Previous: <a href="#The-Erlang_002dC-Formula" accesskey="p" rel="prev">The Erlang-C Formula</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-Engset-Formula-1"></a>
<h3 class="section">4.5 The Engset Formula</h3>

<a name="doc_002dengset"></a>

<dl>
<dt><a name="index-engset"></a>Function File: <em><var>B</var> =</em> <strong>engset</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>)</em></dt>
<dd>
<a name="index-Engset-loss-formula"></a>

<p>Compute the Engset blocking probability <em>P_b(A, m, n)</em> for a system
with a finite population of <em>n</em> users, <em>m</em> identical
servers, no queue, individual service rate <em>\mu</em>, individual
arrival rate <em>\lambda</em> (i.e., the time until a user tries to
request service is exponentially distributed with mean <em>1 /
\lambda</em>), and offered load <em>A = \lambda / \mu</em>.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>A</var></dt>
<dd><p>Offered load, defined as <em>A = \lambda / \mu</em> where
<em>\lambda</em> is the mean arrival rate and <em>\mu</em> the mean
service rate of each individual server (real, <em>A &gt; 0</em>).
</p>
</dd>
<dt><var>m</var></dt>
<dd><p>Number of identical servers (integer, <em>m &ge; 1</em>). Default <em>m = 1</em>
</p>
</dd>
<dt><var>n</var></dt>
<dd><p>Number of requests (integer, <em>n &ge; 1</em>). Default <em>n = 1</em>
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>B</var></dt>
<dd><p>The value <em>P_b(A, m, n)</em>
</p>
</dd>
</dl>

<p><var>A</var>, <var>m</var> or <em>n</em> can be vectors, and in this case, the
results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> erlangb, erlangc.
</p>
</dd></dl>


<hr>
<a name="The-M_002fM_002finf-System"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fM_002f1_002fK-System" accesskey="n" rel="next">The M/M/1/K System</a>, Previous: <a href="#The-Engset-Formula" accesskey="p" rel="prev">The Engset Formula</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fM_002finf-System-1"></a>
<h3 class="section">4.6 The <em>M/M/</em>inf System</h3>

<p>The <em>M/M/\infty</em> system is a special case of <em>M/M/m</em> system
with infinitely many identical servers (i.e., <em>m = \infty</em>). Each
new request is always assigned to a new server, so that queueing never
occurs. The <em>M/M/\infty</em> system is always stable.
</p>
<a name="doc_002dqsmminf"></a>

<dl>
<dt><a name="index-qsmminf"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] =</em> <strong>qsmminf</strong> <em>(<var>lambda</var>, <var>mu</var>)</em></dt>
<dd>
<p>Compute utilization, response time, average number of requests and throughput for a <em>M/M/\infty</em> queue.
</p>
<p>The <em>M/M/\infty</em> system has an infinite number of identical
servers; this kind of system is always stable for every arrival and
service rates.
</p>
<a name="index-M_002fM_002finf-system"></a>


<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p>Service rate (<code><var>mu</var>&gt;0</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Traffic intensity (defined as <em>\lambda/\mu</em>). Note that this is
different from the utilization, which in the case of <em>M/M/\infty</em>
centers is always zero.
</p>
<a name="index-traffic-intensity"></a>

</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time.
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system (which is equal to the
traffic intensity <em>\lambda/\mu</em>).
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Throughput (which is always equal to <code><var>X</var> = <var>lambda</var></code>).
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>Steady-state probability that there are no requests in the system
</p>
</dd>
</dl>

<p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmm1,qsmmm,qsmmmk.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.4.

<a name="index-Bolch_002c-G_002e-3"></a>
<a name="index-Greiner_002c-S_002e-3"></a>
<a name="index-de-Meer_002c-H_002e-3"></a>
<a name="index-Trivedi_002c-K_002e-3"></a>

</li></ul>

<hr>
<a name="The-M_002fM_002f1_002fK-System"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fM_002fm_002fK-System" accesskey="n" rel="next">The M/M/m/K System</a>, Previous: <a href="#The-M_002fM_002finf-System" accesskey="p" rel="prev">The M/M/inf System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fM_002f1_002fK-System-1"></a>
<h3 class="section">4.7 The <em>M/M/1/K</em> System</h3>

<p>In a <em>M/M/1/K</em> finite capacity system there is a single server,
and there can be at most <em>K</em> jobs at any time (including the job
currently in service), <em>K &gt; 1</em>. If a new request tries to join
the system when there are already <em>K</em> other requests, the request
is lost. The queue has <em>K-1</em> slots. The <em>M/M/1/K</em> system is
always stable, regardless of the arrival and service rates.
</p>
<a name="doc_002dqsmm1k"></a>

<dl>
<dt><a name="index-qsmm1k"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] =</em> <strong>qsmm1k</strong> <em>(<var>lambda</var>, <var>mu</var>, <var>K</var>)</em></dt>
<dd>
<a name="index-M_002fM_002f1_002fK-system"></a>

<p>Compute utilization, response time, average number of requests and
throughput for a <em>M/M/1/K</em> finite capacity system. In a
<em>M/M/1/K</em> queue there is a single server; the maximum number of
requests in the system is <em>K</em>, and the maximum queue length is
<em>K-1</em>.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p>Service rate (<code><var>mu</var>&gt;0</code>).
</p>
</dd>
<dt><var>K</var></dt>
<dd><p>Maximum number of requests allowed in the system (<code><var>K</var> &ge; 1</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Service center utilization, which is defined as <code><var>U</var> = 1-<var>p0</var></code>
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Service center throughput
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>Steady-state probability that there are no requests in the system
</p>
</dd>
<dt><var>pK</var></dt>
<dd><p>Steady-state probability that there are <em>K</em> requests in the system
(i.e., that the system is full)
</p>
</dd>
</dl>

<p><var>lambda</var>, <var>mu</var> and <var>K</var> can be vectors of the
same size. In this case, the results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmm1,qsmminf,qsmmm.
</p>
</dd></dl>


<hr>
<a name="The-M_002fM_002fm_002fK-System"></a>
<div class="header">
<p>
Next: <a href="#The-Asymmetric-M_002fM_002fm-System" accesskey="n" rel="next">The Asymmetric M/M/m System</a>, Previous: <a href="#The-M_002fM_002f1_002fK-System" accesskey="p" rel="prev">The M/M/1/K System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fM_002fm_002fK-System-1"></a>
<h3 class="section">4.8 The <em>M/M/m/K</em> System</h3>

<p>The <em>M/M/m/K</em> finite capacity system is similar to the
<em>M/M/1/k</em> system except that the number of servers is <em>m</em>,
where <em>1 \leq m \leq K</em>. The queue has <em>K-m</em> slots. The
<em>M/M/m/K</em> system is always stable.
</p>
<a name="doc_002dqsmmmk"></a>

<dl>
<dt><a name="index-qsmmmk"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] =</em> <strong>qsmmmk</strong> <em>(<var>lambda</var>, <var>mu</var>, <var>m</var>, <var>K</var>)</em></dt>
<dd>
<a name="index-M_002fM_002fm_002fK-system"></a>

<p>Compute utilization, response time, average number of requests and
throughput for a <em>M/M/m/K</em> finite capacity system. In a
<em>M/M/m/K</em> system there are <em>m \geq 1</em> identical service
centers sharing a fixed-capacity queue. At any time, at most <em>K &ge; m</em> requests can be in the system. The maximum queue length
is <em>K-m</em>. This function generates and
solves the underlying CTMC.
</p>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p>Service rate (<code><var>mu</var>&gt;0</code>).
</p>
</dd>
<dt><var>m</var></dt>
<dd><p>Number of servers (<code><var>m</var> &ge; 1</code>).
</p>
</dd>
<dt><var>K</var></dt>
<dd><p>Maximum number of requests allowed in the system,
including those inside the service centers
(<code><var>K</var> &ge; <var>m</var></code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Service center utilization
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Service center throughput
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>Steady-state probability that there are no requests in the system.
</p>
</dd>
<dt><var>pK</var></dt>
<dd><p>Steady-state probability that there are <var>K</var> requests in the system
(i.e., probability that the system is full).
</p>
</dd>
</dl>

<p><var>lambda</var>, <var>mu</var>, <var>m</var> and <var>K</var> can be either scalars, or
vectors of the  same size. In this case, the results will be vectors
as well.
</p>
<br>
<p><strong>See also:</strong> qsmm1,qsmminf,qsmmm.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.6.

<a name="index-Bolch_002c-G_002e-4"></a>
<a name="index-Greiner_002c-S_002e-4"></a>
<a name="index-de-Meer_002c-H_002e-4"></a>
<a name="index-Trivedi_002c-K_002e-4"></a>

</li></ul>

<hr>
<a name="The-Asymmetric-M_002fM_002fm-System"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fG_002f1-System" accesskey="n" rel="next">The M/G/1 System</a>, Previous: <a href="#The-M_002fM_002fm_002fK-System" accesskey="p" rel="prev">The M/M/m/K System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-Asymmetric-M_002fM_002fm-System-1"></a>
<h3 class="section">4.9 The Asymmetric <em>M/M/m</em> System</h3>

<p>The Asymmetric <em>M/M/m</em> system contains <em>m</em> servers connected
to a single queue. Differently from the <em>M/M/m</em> system, in the
asymmetric <em>M/M/m</em> each server may have a different service time.
</p>
<a name="doc_002dqsammm"></a>

<dl>
<dt><a name="index-qsammm"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qsammm</strong> <em>(<var>lambda</var>, <var>mu</var>)</em></dt>
<dd>
<a name="index-asymmetric-M_002fM_002fm-system"></a>

<p>Compute <em>approximate</em> utilization, response time, average
number of requests in service and throughput for an asymmetric
<em>M/M/m</em> queue. In this system there are <em>m</em> different
servers connected to a single queue. Each server has its own
(possibly different) service rate. If there is more than one server
available, requests are routed to a randomly-chosen one.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p><code><var>mu</var>(i)</code> is the service rate of server
<em>i</em>, <em>1 &le; i &le; m</em>.
The system must be ergodic (<code><var>lambda</var> &lt; sum(<var>mu</var>)</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Approximate service center utilization,
<em>U = \lambda / ( \sum_i \mu_i )</em>.
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Approximate service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Approximate number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Approximate system throughput. If the system is ergodic, 
<code><var>X</var> = <var>lambda</var></code>
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qsmmm.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998

<a name="index-Bolch_002c-G_002e-5"></a>
<a name="index-Greiner_002c-S_002e-5"></a>
<a name="index-de-Meer_002c-H_002e-5"></a>
<a name="index-Trivedi_002c-K_002e-5"></a>

</li></ul>

<hr>
<a name="The-M_002fG_002f1-System"></a>
<div class="header">
<p>
Next: <a href="#The-M_002fHm_002f1-System" accesskey="n" rel="next">The M/Hm/1 System</a>, Previous: <a href="#The-Asymmetric-M_002fM_002fm-System" accesskey="p" rel="prev">The Asymmetric M/M/m System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fG_002f1-System-1"></a>
<h3 class="section">4.10 The <em>M/G/1</em> System</h3>

<a name="doc_002dqsmg1"></a>

<dl>
<dt><a name="index-qsmg1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] =</em> <strong>qsmg1</strong> <em>(<var>lambda</var>, <var>xavg</var>, <var>x2nd</var>)</em></dt>
<dd>
<a name="index-M_002fG_002f1-system"></a>

<p>Compute utilization, response time, average number of requests and
throughput for a <em>M/G/1</em> system. The service time distribution
is described by its mean <var>xavg</var>, and by its second moment
<var>x2nd</var>. The computations are based on results from L. Kleinrock,
<cite>Queuing Systems</cite>, Wiley, Vol 2, and Pollaczek-Khinchine formula.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate.
</p>
</dd>
<dt><var>xavg</var></dt>
<dd><p>Average service time
</p>
</dd>
<dt><var>x2nd</var></dt>
<dd><p>Second moment of service time distribution
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Service center utilization
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Service center throughput
</p>
</dd>
<dt><var>p0</var></dt>
<dd><p>probability that there is not any request at system
</p>
</dd>
</dl>

<p><var>lambda</var>, <var>xavg</var>, <var>t2nd</var> can be vectors of the
same size. In this case, the results will be vectors as well.
</p>
<br>
<p><strong>See also:</strong> qsmh1.
</p>
</dd></dl>


<hr>
<a name="The-M_002fHm_002f1-System"></a>
<div class="header">
<p>
Previous: <a href="#The-M_002fG_002f1-System" accesskey="p" rel="prev">The M/G/1 System</a>, Up: <a href="#Single-Station-Queueing-Systems" accesskey="u" rel="up">Single Station Queueing Systems</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-M_002fH_005fm_002f1-System"></a>
<h3 class="section">4.11 The <em>M/H_m/1</em> System</h3>
<a name="doc_002dqsmh1"></a>

<dl>
<dt><a name="index-qsmh1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] =</em> <strong>qsmh1</strong> <em>(<var>lambda</var>, <var>mu</var>, <var>alpha</var>)</em></dt>
<dd>
<a name="index-M_002fH_005fm_002f1-system"></a>

<p>Compute utilization, response time, average number of requests and
throughput for a <em>M/H_m/1</em> system. In this system, the customer
service times have hyper-exponential distribution:
</p>

<div class="example">
<pre class="example">       ___ m
       \
B(x) =  &gt;  alpha(j) * (1-exp(-mu(j)*x))   x&gt;0
       /__ 
           j=1
</pre></div>

<p>where <em>\alpha_j</em> is the probability that the request is served
at phase <em>j</em>, in which case the average service rate is
<em>\mu_j</em>. After completing service at phase <em>j</em>, for
some <em>j</em>, the request exits the system.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>lambda</var></dt>
<dd><p>Arrival rate.
</p>
</dd>
<dt><var>mu</var></dt>
<dd><p><code><var>mu</var>(j)</code> is the phase <em>j</em> service rate. The total
number of phases <em>m</em> is <code>length(<var>mu</var>)</code>.
</p>
</dd>
<dt><var>alpha</var></dt>
<dd><p><code><var>alpha</var>(j)</code> is the probability that a request
is served at phase <em>j</em>. <var>alpha</var> must have the same size
as <var>mu</var>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><var>U</var></dt>
<dd><p>Service center utilization
</p>
</dd>
<dt><var>R</var></dt>
<dd><p>Service center response time
</p>
</dd>
<dt><var>Q</var></dt>
<dd><p>Average number of requests in the system
</p>
</dd>
<dt><var>X</var></dt>
<dd><p>Service center throughput
</p>
</dd>
</dl>

</dd></dl>





<hr>
<a name="Queueing-Networks"></a>
<div class="header">
<p>
Next: <a href="#References" accesskey="n" rel="next">References</a>, Previous: <a href="#Single-Station-Queueing-Systems" accesskey="p" rel="prev">Single Station Queueing Systems</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Queueing-Networks-1"></a>
<h2 class="chapter">5 Queueing Networks</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-QNs" accesskey="1">Introduction to QNs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">A brief introduction to Queueing Networks
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Single-Class-Models" accesskey="2">Single Class Models</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Queueing models with a single job class
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Multiple-Class-Models" accesskey="3">Multiple Class Models</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Queueing models with multiple job classes
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Generic-Algorithms" accesskey="4">Generic Algorithms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">High-level functions for QN analysis
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bounds-Analysis" accesskey="5">Bounds Analysis</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Computation of asymptotic performance bounds
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#QN-Analysis-Examples" accesskey="6">QN Analysis Examples</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Queueing Networks analysis examples
</td></tr>
</table>

<a name="index-queueing-networks"></a>

<hr>
<a name="Introduction-to-QNs"></a>
<div class="header">
<p>
Next: <a href="#Single-Class-Models" accesskey="n" rel="next">Single Class Models</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Introduction-to-QNs-1"></a>
<h3 class="section">5.1 Introduction to QNs</h3>

<p>Queueing Networks (QN) are a simple modeling notation that can be used
to analyze many kinds of systems. In its simplest form, a QN is made
of <em>K</em> service centers; center <em>k</em> has a queue connected to
<em>m_k</em> (usually identical) servers. Arriving customers (requests)
join the queue if there is at least one slot available. Requests are
served according to a (de)queueing policy (e.g., FIFO). After service
completes, requests leave the server and can join another queue or
exit from the system.
</p>
<p>Service centers where <em>m_k = \infty</em> are called <em>delay
centers</em> or <em>infinite servers</em>. In this kind of centers, there is
always one available server, so that queueing never occurs.
</p>
<p>Requests join the queue according to a <em>queueing policy</em>, such as:
</p>
<dl compact="compact">
<dt><strong>FCFS</strong></dt>
<dd><p>First-Come-First-Served
</p>
</dd>
<dt><strong>LCFS-PR</strong></dt>
<dd><p>Last-Come-First-Served, Preemptive Resume
</p>
</dd>
<dt><strong>PS</strong></dt>
<dd><p>Processor Sharing
</p>
</dd>
<dt><strong>IS</strong></dt>
<dd><p>Infinite Server (<em>m_k = \infty</em>).
</p>
</dd>
</dl>

<p>Queueing networks can be <em>open</em> or <em>closed</em>. In open
networks there is an infinite population of requests; new customers
are generated outside the system, and eventually leave the network. In
closed networks there is a fixed population of request that never
leave the system.
</p>
<p>Queueing models can have a single request class (<em>single class
models</em>), meaning that all requests behave in the same way (e.g., they
spend the same average time on each particular server). In
<em>multiple class models</em> there are multiple request classes, each
with its own parameters (e.g., with different service times or
different routing probabilities). Furthermore, in multiclass models
there can be open and closed chains of requests at the same time.
</p>
<p>A particular class of QN models, <em>product-form</em> networks, is of
particular interest. Product-form networks fulfill the following
assumptions:
</p>
<ul>
<li> The network can consist of open and closed job classes.

</li><li> The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

</li><li> Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

</li><li> The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

</li><li> In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate <em>\lambda</em> that can
depend on the number of jobs in the network. ii) the arrival process
consists of <em>C</em> independent Poisson arrival streams where the
<em>C</em> job sources are assigned to the <em>C</em> chains; the arrival
rate can be load dependent.

</li></ul>

<p>Product-form networks are attractive because steady-state performance
measures can be efficiently computed.
</p>

<hr>
<a name="Single-Class-Models"></a>
<div class="header">
<p>
Next: <a href="#Multiple-Class-Models" accesskey="n" rel="next">Multiple Class Models</a>, Previous: <a href="#Introduction-to-QNs" accesskey="p" rel="prev">Introduction to QNs</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Single-Class-Models-1"></a>
<h3 class="section">5.2 Single Class Models</h3>

<p>In single class models, all requests are indistinguishable and belong
to the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.
</p>
<p><strong>Model Inputs</strong>
</p>
<dl compact="compact">
<dt><em>lambda_k</em></dt>
<dd><p>(Open models only) External arrival rate to service center <em>k</em>.
</p>
</dd>
<dt><em>lambda</em></dt>
<dd><p>(Open models only) Overall external arrival rate to the system as a whole: <em>\lambda = \sum_k \lambda_k</em>.
</p>
</dd>
<dt><em>N</em></dt>
<dd><p>(Closed models only) Total number of requests in the system.
</p>
</dd>
<dt><em>S_k</em></dt>
<dd><p>Average service time. <em>S_k</em> is the average service time at center
<em>k</em>. In other words, <em>S_k</em> is the average time elapsed from
service start to service completion at center <em>k</em>.
</p>
</dd>
<dt><em>P_{i, j}</em></dt>
<dd><p>Routing probability matrix. <em>{\bf P} = [P_{i, j}]</em> is a <em>K
\times K</em> matrix where <em>P_{i, j}</em> is the probability that a
request completing service at server <em>i</em> will move directly to
server <em>j</em>. The probability that a request leaves the system
after being served at center <em>i</em> is <em>1-\sum_{j=1}^K P_{i,
j}</em>.
</p>
</dd>
<dt><em>V_k</em></dt>
<dd><p>Mean number of visits to center <em>k</em> (also called <em>visit
ratio</em> or <em>relative arrival rate</em>).
</p>
</dd>
</dl>

<p><strong>Model Outputs</strong>
</p>
<dl compact="compact">
<dt><em>U_k</em></dt>
<dd><p>Service center utilization. <em>U_k</em> is center <em>k</em>
utilization. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).
If center <em>k</em> is a single-server or multiserver node, then
<em>0 &le; U_k &le; 1</em>. If center <em>k</em> is an infinite server
node (delay center), then <em>U_k</em> denotes the <em>traffic
intensity</em> and is defined as <em>U_k = X_k S_k</em>; in this case the
utilization may be greater than one.
</p>
</dd>
<dt><em>R_k</em></dt>
<dd><p>Average response time. <em>R_k</em> is the average response time of
center <em>k</em>. The average response time is defined as the average
time between the arrival of a request in the queue and service
completion of the same request.
</p>
</dd>
<dt><em>Q_k</em></dt>
<dd><p>Average number of customers. <em>Q_k</em> is the average number of
requests in center <em>k</em>. This includes both the requests in the
queue, and those being served.
</p>
</dd>
<dt><em>X_k</em></dt>
<dd><p>Throughput. <em>X_k</em> is center <em>k</em> throughput.  The throughput
is the ratio of job completions over time, i.e., the average number of
jobs completed over a fixed time interval.
</p>
</dd>
</dl>

<p>Given the output parameters above, additional performance measures can
be computed:
</p>
<dl compact="compact">
<dt><em>X</em></dt>
<dd><p>System throughput, <em>X = X_k / V_k</em> for any <em>k</em> for 
which <em>V_k \neq 0</em>
</p>
</dd>
<dt><em>R</em></dt>
<dd><p>System response time, <em>R = \sum_{k=1}^K R_k V_k</em>
</p>
</dd>
<dt><em>Q</em></dt>
<dd><p>Average number of requests in the system, <em>Q = \sum_{k=1} Q_k</em>; for
closed systems, this can be written as <em>Q = N-XZ</em>;
</p>
</dd>
</dl>

<p>For open, single class models, the scalar <em>\lambda</em> denotes the
external arrival rate of requests to the system. The average number of
visits <em>V_j</em> satisfy the following equation:
</p>
<div class="example">
<pre class="example">                  K
                 ___
                \
V_j = P_(0, j) + &gt;   V_i P_(i, j)    j=1,...,K
                /___
                 i=1
</pre></div>

<p>where <em>P_{0, j}</em> is the probability that an external
request goes to center <em>j</em>. If we denote with <em>\lambda_j</em>
the external arrival rate to center <em>j</em>, and <em>\lambda =
\sum_j \lambda_j</em> the overall external arrival rate, then <em>P_{0,
j} = \lambda_j / \lambda</em>.
</p>
<p>For closed models, the visit ratios satisfy the following equation:
</p>
<div class="example">
<pre class="example">/
|         K
|        ___
|       \
| V_j =  &gt;   V_i P_(i, j)     j=1,...,K
|       /___
|        i=1
|
| V_r = 1                     for a selected reference station r
\
</pre></div>

<p>Note that the set of traffic equations <em>V_j = \sum_{i=1}^K V_i
P_{i, j}</em> alone can only be solved up to a multiplicative constant; to
get a unique solution we impose an additional constraint <em>V_r =
1</em> for some <em>1 &le; r &le; K</em>. This constraint is equivalent
to defining station <em>r</em> as the <em>reference station</em>; the
default is <em>r=1</em>, see <a href="#doc_002dqncsvisits">doc-qncsvisits</a>. A job that returns to
the reference station is assumed to have completed its activity
cycle. The network throughput is set to the throughput of the
reference station.
</p>
<a name="doc_002dqncsvisits"></a>

<dl>
<dt><a name="index-qncsvisits"></a>Function File: <em><var>V</var> =</em> <strong>qncsvisits</strong> <em>(<var>P</var>)</em></dt>
<dt><a name="index-qncsvisits-1"></a>Function File: <em><var>V</var> =</em> <strong>qncsvisits</strong> <em>(<var>P</var>, <var>r</var>)</em></dt>
<dd>
<p>Compute the mean number of visits to the service centers of a
single class, closed network with <em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>probability that a request which completed service at center
<em>i</em> is routed to center <em>j</em> (<em>K \times K</em> matrix).
For closed networks it must hold that <code>sum(<var>P</var>,2)==1</code>. The
routing graph must be strongly connected, meaning that each node
must be reachable from every other node.
</p>
</dd>
<dt><code><var>r</var></code></dt>
<dd><p>Index of the reference station, <em>r \in {1, &hellip;, K}</em>;
Default <code><var>r</var>=1</code>. The traffic equations are solved by
imposing the condition <code><var>V</var>(r) = 1</code>. A request returning to
the reference station completes its activity cycle.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to service center <em>k</em>, assuming
<em>r</em> as the reference station.
</p>
</dd>
</dl>

</dd></dl>


<a name="doc_002dqnosvisits"></a>

<dl>
<dt><a name="index-qnosvisits"></a>Function File: <em><var>V</var> =</em> <strong>qnosvisits</strong> <em>(<var>P</var>, <var>lambda</var>)</em></dt>
<dd>
<p>Compute the average number of visits to the service centers of a single 
class open Queueing Network with <em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>is the probability that a request which completed service at center
<em>i</em> is routed to center <em>j</em> (<em>K \times K</em> matrix).
</p>
</dd>
<dt><code><var>lambda</var>(k)</code></dt>
<dd><p>external arrival rate to center <em>k</em>. 
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to server <em>k</em>.
</p>
</dd>
</dl>

</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<div class="float"><a name="fig_003aqn_005fclosed_005fsingle"></a>
<div align="center"><img src="qn_closed_single.png" alt="qn_closed_single">
</div>
<div class="float-caption"><p><strong>Figure 5.1: </strong>Closed network with a single class of requests</p></div></div>
<p><a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a> shows a closed queueing network with a
single class of requests. The network has three service centers,
labeled <em>CPU</em>, <em>Disk1</em> and <em>Disk2</em>, and is known as a
<em>central server</em> model of a computer system. Requests spend some
time at the CPU, which is represented by a PS (Processor Sharing)
node. After that, requests are routed to Disk1 with probability
<em>0.3</em>, and to Disk2 with probability <em>0.7</em>. Both Disk1 and
Disk2 are FCFS nodes.
</p>
<p>If we label the servers as CPU=1, Disk1=2, Disk2=3, we can define the
routing matrix as follows:
</p>
<div class="example">
<pre class="example">    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
</pre></div>

<p>The visit ratios <em>V</em>, using station 1 as the reference
station, can be computed with:
</p>
<div class="example">
<pre class="verbatim"> P = [0 0.3 0.7; ...
      1 0   0  ; ...
      1 0   0  ];
 V = qncsvisits(P)
</pre><pre class="example">   &rArr; V = 1.00000   0.30000   0.70000
</pre></div>

<p><strong>EXAMPLE</strong>
</p>
<div class="float"><a name="fig_003aqn_005fopen_005fsingle"></a>
<div align="center"><img src="qn_open_single.png" alt="qn_open_single">
</div>
<div class="float-caption"><p><strong>Figure 5.2: </strong>Open Queueing Network with a single class of requests</p></div></div>
<p><a href="#fig_003aqn_005fopen_005fsingle">Figure 5.2</a> shows a open QN with a single class of
requests. The network has the same structure as the one in
<a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a>, with the difference that here we have a
stream of jobs arriving from outside the system, at a rate
<em>\lambda</em>. After service completion at the CPU, a job can leave
the system with probability <em>0.2</em>, or be transferred to other
nodes with the probabilities shown in the figure.
</p>
<p>The routing matrix is
</p>
<div class="example">
<pre class="example">    / 0  0.3  0.5 \
P = | 1  0    0   |
    \ 1  0    0   /
</pre></div>

<p>If we let <em>\lambda = 1.2</em>, we can compute the visit ratios
<em>V</em> as follows:
</p>
<div class="example">
<pre class="verbatim"> p = 0.3;
 lambda = 1.2
 P = [0 0.3 0.5; ...
      1 0   0  ; ...
      1 0   0  ];
 V = qnosvisits(P,[1.2 0 0])
</pre><pre class="example">   &rArr; V = 5.0000   1.5000   2.5000
</pre></div>

<p>Function <code>qnosvisits</code> expects a vector with <em>K</em> elements
as a second parameter, for open networks only. The vector contains the
arrival rates at each individual node; since in our example external
arrivals exist only for node <em>S_1</em> with rate <em>\lambda =
1.2</em>, the second parameter is <code>[1.2, 0, 0]</code>.
</p>
<a name="Open-Networks"></a>
<h4 class="subsection">5.2.1 Open Networks</h4>

<p>Jackson networks satisfy the following conditions:
</p>
<ul>
<li> There is only one job class in the network; the total number of jobs
in the system is unbounded.

</li><li> There are <em>K</em> service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

</li><li> Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

</li><li> External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

</li><li> Service discipline at each node is FCFS

</li></ul>

<p>We define the <em>joint probability vector</em> <em>\pi(n_1, n_2,
&hellip;, n_K)</em> as the steady-state probability that there are <em>n_k</em>
requests at service center <em>k</em>, for all <em>k=1, 2, &hellip;, N</em>.
Jackson networks have the property that the joint probability is the
product of the marginal probabilities <em>\pi_k</em>:
</p>
<div class="example">
<pre class="example"><var>joint_prob</var> = prod( <var>pi</var> )
</pre></div>

<p>where <em>\pi_k(n_k)</em> is the steady-state probability
that there are <em>n_k</em> requests at service center <em>k</em>.
</p>
<a name="doc_002dqnos"></a>

<dl>
<dt><a name="index-qnos"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnos</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>) </em></dt>
<dt><a name="index-qnos-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnos</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-open-network_002c-single-class"></a>
<a name="index-BCMP-network"></a>

<p>Analyze open, single class BCMP queueing networks with <em>K</em> service centers.
</p>
<p>This function works for a subset of BCMP single-class open networks
satisfying the following properties:
</p>
<ul>
<li> The allowed service disciplines at network nodes are: FCFS,
PS, LCFS-PR, IS (infinite server);

</li><li> Service times are exponentially distributed and
load-independent; 

</li><li> Center <em>k</em> can consist of <code><var>m</var>(k) &ge; 1</code> 
identical servers.

</li><li> Routing is load-independent

</li></ul>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var></code></dt>
<dd><p>Overall external arrival rate (<code><var>lambda</var>&gt;0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>average service time at center <em>k</em> (<code><var>S</var>(k)&gt;0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>i</em>. If <code><var>m</var>(k) &lt; 1</code>,
enter <em>k</em> is a delay center (IS); otherwise it is a regular
queueing center with <code><var>m</var>(k)</code> servers. Default is
<code><var>m</var>(k) = 1</code> for all <em>k</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>If <em>k</em> is a queueing center, 
<code><var>U</var>(k)</code> is the utilization of center <em>k</em>.
If <em>k</em> is an IS node, then <code><var>U</var>(k)</code> is the
<em>traffic intensity</em> defined as <code><var>X</var>(k)*<var>S</var>(k)</code>.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>center <em>k</em> average response time.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests at center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>k</em> throughput.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnopen,qnclosed,qnosvisits.
</p>
</dd></dl>


<p>From the results computed by this function, it is possible to derive
other quantities of interest as follows:
</p>
<ul>
<li> <strong>System Response Time</strong>: The overall system response time
can be computed as
<code>R_s = dot(V,R);</code>

</li><li> <strong>Average number of requests</strong>: The average number of requests
in the system can be computed as:
<code>Q_avg = sum(Q)</code>

</li></ul>

<p><strong>EXAMPLE</strong>
</p>
<div class="example">
<pre class="verbatim"> lambda = 3;
 V = [16 7 8];
 S = [0.01 0.02 0.03];
 [U R Q X] = qnos( lambda, S, V );
 R_s = dot(R,V) # System response time
 N = sum(Q) # Average number in system
</pre><pre class="example">-| R_s =  1.4062
-| N =  4.2186
</pre></div>

<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications</cite>, Wiley, 1998.

<a name="index-Bolch_002c-G_002e-6"></a>
<a name="index-Greiner_002c-S_002e-6"></a>
<a name="index-de-Meer_002c-H_002e-6"></a>
<a name="index-Trivedi_002c-K_002e-6"></a>

</li></ul>

<a name="Closed-Networks"></a>
<h4 class="subsection">5.2.2 Closed Networks</h4>

<a name="doc_002dqncsmva"></a>

<dl>
<dt><a name="index-qncsmva"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsmva-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncsmva-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029"></a>
<a name="index-closed-network_002c-single-class"></a>
<a name="index-normalization-constant"></a>

<p>Analyze closed, single class queueing networks using the exact Mean Value Analysis (MVA) algorithm. 
</p>
<p>The following queueing disciplines are supported: FCFS, LCFS-PR, PS
and IS (Infinite Server). This function supports fixed-rate service
centers or multiple server nodes. For general load-dependent service
centers, use the function <code>qncsmvald</code> instead.
</p>
<p>Additionally, the normalization constant <em>G(n)</em>, <em>n=0,
&hellip;, N</em> is computed; <em>G(n)</em> can be used in conjunction with
the BCMP theorem to compute steady-state probabilities.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Population size (number of requests in the system, <code><var>N</var> &ge; 0</code>).
If <code><var>N</var> == 0</code>, this function returns
<code><var>U</var> = <var>R</var> = <var>Q</var> = <var>X</var> = 0</code>
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em> (<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to service center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay for customers (<code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em> (if <var>m</var> is a scalar, all
centers have that number of servers). If <code><var>m</var>(k) &lt; 1</code>,
center <em>k</em> is a delay center (IS); otherwise it is a regular
queueing center (FCFS, LCFS-PR or PS) with <code><var>m</var>(k)</code>
servers. Default is <code><var>m</var>(k) = 1</code> for all <em>k</em> (each
service center has a single server).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>If <em>k</em> is a FCFS, LCFS-PR or PS node (<code><var>m</var>(k) &ge;
1</code>), then <code><var>U</var>(k)</code> is the utilization of center <em>k</em>,
<em>0 &le; U(k) &le; 1</em>. If <em>k</em> is an IS node
(<code><var>m</var>(k) &lt; 1</code>), then <code><var>U</var>(k)</code> is the <em>traffic
intensity</em> defined as <code><var>X</var>(k)*<var>S</var>(k)</code>. In this case the
value of <code><var>U</var>(k)</code> may be greater than one.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>center <em>k</em> response time. The <em>Residence Time</em> at center
<em>k</em> is <code><var>R</var>(k) * <var>V</var>(k)</code>. The system response
time <var>Rsys</var> can be computed either as <code><var>Rsys</var> =
<var>N</var>/<var>Xsys</var> - Z</code> or as <code><var>Rsys</var> =
dot(<var>R</var>,<var>V</var>)</code>
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests at center <em>k</em>. The number of
requests in the system can be computed either as
<code>sum(<var>Q</var>)</code>, or using the formula
<code><var>N</var>-<var>Xsys</var>*<var>Z</var></code>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>K</em> throughput. The system throughput <var>Xsys</var> can be
computed as <code><var>Xsys</var> = <var>X</var>(1) / <var>V</var>(1)</code>
</p>
</dd>
<dt><code><var>G</var>(n)</code></dt>
<dd><p>Normalization constants. <code><var>G</var>(n+1)</code> contains the value of
the normalization constant <em>G(n)</em>, <em>n=0, &hellip;, N</em> as
array indexes in Octave start from 1. <em>G(n)</em> can be used in
conjunction with the BCMP theorem to compute steady-state
probabilities.
</p>
</dd>
</dl>

<blockquote>
<p><b>Note on numerical stability:</b> In presence of load-dependent servers (i.e., if <code><var>m</var>(k)&gt;1</code>
for some <em>k</em>), the MVA algorithm is known to be numerically
unstable. Generally the issue manifests itself as negative values
for the response times or utilizations. This is not a problem of
the <code>queueing</code> toolbox, but of the MVA algorithm, and
therefore has currently no known workaround (apart from using a
different solution technique, if available). This function prints a
warning if numerical problems are detected; the warning can be disabled
with the command <code>warning(&quot;off&quot;, &quot;qn:numerical-instability&quot;)</code>.
</p></blockquote>

<br>
<p><strong>See also:</strong> qncsmvald,qncscmva.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

<a name="index-Reiser_002c-M_002e"></a>
<a name="index-Lavenberg_002c-S_002e-S_002e"></a>

</li></ul>

<p>This implementation is described in R. Jain , <cite>The Art of
Computer Systems Performance Analysis</cite>, Wiley, 1991, p. 577.
Multi-server nodes are treated according to G. Bolch, S. Greiner,
H. de Meer and K. Trivedi, <cite>Queueing Networks and Markov Chains:
Modeling and Performance Evaluation with Computer Science
Applications</cite>, Wiley, 1998, Section 8.2.1, &quot;Single Class Queueing
Networks&quot;.
</p>
<a name="index-Jain_002c-R_002e"></a>
<a name="index-Bolch_002c-G_002e-7"></a>
<a name="index-Greiner_002c-S_002e-7"></a>
<a name="index-de-Meer_002c-H_002e-7"></a>
<a name="index-Trivedi_002c-K_002e-7"></a>

<p><strong>EXAMPLE</strong>
</p>
<div class="example">
<pre class="verbatim"> S = [ 0.125 0.3 0.2 ];
 V = [ 16 10 5 ];
 N = 20;
 m = ones(1,3);
 Z = 4;
 [U R Q X] = qncsmva(N,S,V,m,Z);
 X_s = X(1)/V(1); # System throughput
 R_s = dot(R,V); # System response time
 printf(&quot;\t    Util      Qlen     RespT      Tput\n&quot;);
 printf(&quot;\t--------  --------  --------  --------\n&quot;);
 for k=1:length(S)
   printf(&quot;Dev%d\t%8.4f  %8.4f  %8.4f  %8.4f\n&quot;, k, U(k), Q(k), R(k), X(k) );
 endfor
 printf(&quot;\nSystem\t          %8.4f  %8.4f  %8.4f\n\n&quot;, N-X_s*Z, R_s, X_s );
</pre></div>

<a name="doc_002dqncsmvald"></a>

<dl>
<dt><a name="index-qncsmvald"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvald</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsmvald-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvald</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029-1"></a>
<a name="index-MVA"></a>
<a name="index-closed-network_002c-single-class-1"></a>
<a name="index-load_002ddependent-service-center"></a>

<p>Mean Value Analysis algorithm for closed, single class queueing
networks with <em>K</em> service centers and load-dependent service
times. This function supports FCFS, LCFS-PR, PS and IS nodes. For
networks with only fixed-rate centers and multiple-server
nodes, the function <code>qncsmva</code> is more efficient.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Population size (number of requests in the system, <code><var>N</var> &ge; 0</code>).
If <code><var>N</var> == 0</code>, this function returns <code><var>U</var> = <var>R</var> = <var>Q</var> = <var>X</var> = 0</code>
</p>
</dd>
<dt><code><var>S</var>(k,n)</code></dt>
<dd><p>mean service time at center <em>k</em>
where there are <em>n</em> requests, <em>1 &le; n
&le; N</em>. <code><var>S</var>(k,n)</code> <em>= 1 / \mu_{k}(n)</em>,
where <em>\mu_{k}(n)</em> is the service rate of center <em>k</em>
when there are <em>n</em> requests.
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to service center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>external delay (&quot;think time&quot;, <code><var>Z</var> &ge; 0</code>); default 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>utilization of service center <em>k</em>. The
utilization is defined as the probability that service center
<em>k</em> is not empty, that is, <em>U_k = 1-\pi_k(0)</em> where
<em>\pi_k(0)</em> is the steady-state probability that there are 0
jobs at service center <em>k</em>.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>response time on service center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests in service center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>throughput of service center <em>k</em>.
</p>
</dd>
</dl>

<blockquote>
<p><b>Note:</b> In presence of load-dependent servers, the MVA algorithm is known
to be numerically unstable. Generally the problem manifests itself
as negative response times or utilization.
</p></blockquote>

</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

<a name="index-Reiser_002c-M_002e-1"></a>
<a name="index-Lavenberg_002c-S_002e-S_002e-1"></a>

</li></ul>

<p>This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, Section 8.2.4.1, &ldquo;Networks with Load-Dependent Service: Closed
Networks&rdquo;.
</p>
<a name="index-Bolch_002c-G_002e-8"></a>
<a name="index-Greiner_002c-S_002e-8"></a>
<a name="index-de-Meer_002c-H_002e-8"></a>
<a name="index-Trivedi_002c-K_002e-8"></a>

<a name="doc_002dqncscmva"></a>

<dl>
<dt><a name="index-qncscmva"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncscmva</strong> <em>(<var>N</var>, <var>S</var>, <var>Sld</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncscmva-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncscmva</strong> <em>(<var>N</var>, <var>S</var>, <var>Sld</var>, <var>V</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-conditional-MVA-_0028CMVA_0029"></a>
<a name="index-Mean-Value-Analysis_002c-conditional-_0028CMVA_0029"></a>
<a name="index-closed-network_002c-single-class-2"></a>
<a name="index-CMVA"></a>

<p>Conditional MVA (CMVA) algorithm, a numerically stable variant of
MVA. This function supports a network of <em>M &ge; 1</em> service
centers and a single delay center. Servers <em>1, &hellip;, M-1</em>
are load-independent; server <em>M</em> is load-dependent.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Number of requests in the system, <code><var>N</var> &ge; 0</code>. If
<code><var>N</var> == 0</code>, this function returns <code><var>U</var> = <var>R</var>
= <var>Q</var> = <var>X</var> = 0</code>
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time on server <em>k = 1, &hellip;, M-1</em>
(<code><var>S</var>(k) &gt; 0</code>). If there are no fixed-rate servers, then
<code>S = []</code>
</p>
</dd>
<dt><code><var>Sld</var>(n)</code></dt>
<dd><p>inverse service rate at server <em>M</em> (the load-dependent server)
when there are <em>n</em> requests, <em>n=1, &hellip;, N</em>.
<code><var>Sld</var>(n) = </code> <em>1 / \mu(n)</em>.
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to service center <em>k=1, &hellip;, M</em>,
where <code><var>V</var>(k) &ge; 0</code>. <code><var>V</var>(1:M-1)</code> are the
visit rates to the fixed rate servers; <code><var>V</var>(M)</code> is the
visit rate to the load dependent server.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay for customers (<code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>center <em>k</em> utilization (<em>k=1, &hellip;, M</em>)
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>response time of center <em>k</em> (<em>k=1, &hellip;, M</em>). The
system response time <var>Rsys</var> can be computed as <code><var>Rsys</var>
= <var>N</var>/<var>Xsys</var> - Z</code>
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests at center <em>k</em> (<em>k=1, &hellip;, M</em>).
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>k</em> throughput (<em>k=1, &hellip;, M</em>).
</p>
</dd>
</dl>

</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Casale. <cite>A note on stable flow-equivalent aggregation in
closed networks</cite>. Queueing Syst. Theory Appl., 60:193-202, December
2008, <a href="http://dx.doi.org/10.1007/s11134-008-9093-6">10.1007/s11134-008-9093-6</a>

<a name="index-Casale_002c-G_002e"></a>

</li></ul>


<a name="doc_002dqncsmvaap"></a>

<dl>
<dt><a name="index-qncsmvaap"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsmvaap-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncsmvaap-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dt><a name="index-qncsmvaap-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>, <var>tol</var>)</em></dt>
<dt><a name="index-qncsmvaap-4"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>, <var>tol</var>, <var>iter_max</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate"></a>
<a name="index-MVA_002c-approximate"></a>
<a name="index-approximate-MVA"></a>
<a name="index-closed-network_002c-single-class-3"></a>
<a name="index-closed-network_002c-approximate-analysis"></a>

<p>Analyze closed, single class queueing networks using the Approximate
Mean Value Analysis (MVA) algorithm. This function is based on
approximating the number of customers seen at center <em>k</em> when a
new request arrives as <em>Q_k(N) \times (N-1)/N</em>. This function
only handles single-server and delay centers; if your network
contains general load-dependent service centers, use the function
<code>qncsmvald</code> instead.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Population size (number of requests in the system, <code><var>N</var> &gt; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time on server <em>k</em>
(<code><var>S</var>(k)&gt;0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to service center
<em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>
(if <var>m</var> is a scalar, all centers have that number of servers). If
<code><var>m</var>(k) &lt; 1</code>, center <em>k</em> is a delay center (IS); if
<code><var>m</var>(k) == 1</code>, center <em>k</em> is a regular queueing
center (FCFS, LCFS-PR or PS) with one server (default). This function
does not support multiple server nodes (<code><var>m</var>(k) &gt; 1</code>).
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay for customers (<code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
<dt><code><var>tol</var></code></dt>
<dd><p>Stopping tolerance. The algorithm stops when the maximum relative
difference between the new and old value of the queue lengths
<var>Q</var> becomes less than the tolerance. Default is <em>10^{-5}</em>.
</p>
</dd>
<dt><code><var>iter_max</var></code></dt>
<dd><p>Maximum number of iterations (<code><var>iter_max</var>&gt;0</code>.
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>If <em>k</em> is a FCFS, LCFS-PR or PS node (<code><var>m</var>(k) == 1</code>),
then <code><var>U</var>(k)</code> is the utilization of center <em>k</em>. If
<em>k</em> is an IS node (<code><var>m</var>(k) &lt; 1</code>), then
<code><var>U</var>(k)</code> is the <em>traffic intensity</em> defined as
<code><var>X</var>(k)*<var>S</var>(k)</code>.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>response time at center <em>k</em>.
The system response time <var>Rsys</var>
can be computed as <code><var>Rsys</var> = <var>N</var>/<var>Xsys</var> - Z</code>
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests at center <em>k</em>. The number of
requests in the system can be computed either as
<code>sum(<var>Q</var>)</code>, or using the formula
<code><var>N</var>-<var>Xsys</var>*<var>Z</var></code>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>k</em> throughput. The system throughput <var>Xsys</var> can be
computed as <code><var>Xsys</var> = <var>X</var>(1) / <var>V</var>(1)</code>
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsmva,qncsmvald.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<p>This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 6.4.2.2 (&quot;Approximate Solution Techniques&quot;).
</p>
<a name="index-Lazowska_002c-E_002e-D_002e"></a>
<a name="index-Zahorjan_002c-J_002e"></a>
<a name="index-Graham_002c-G_002e-S_002e"></a>
<a name="index-Sevcik_002c-K_002e-C_002e"></a>


<p>According to the BCMP theorem, the state probability of a closed
single class queueing network with <em>K</em> nodes and <em>N</em> requests
can be expressed as:
</p>
<div class="example">
<pre class="example">n = [n1, n2, &hellip; nK]; <span class="roman">population vector</span>
p = 1/G(N+1) \prod F(k,k);
</pre></div>

<p>Here <em>\pi(n_1, n_2, &hellip;, n_K)</em> is the joint probability of
having <em>n_k</em> requests at node <em>k</em>, for all <em>k=1, 2,
&hellip;, K</em>; <em>\sum_{k=1}^K n_k = N</em>
</p>
<p>The <em>convolution algorithms</em> computes the normalization constants
<em>{\bf G} = \left(G(0), G(1), &hellip;, G(N)\right)</em> for
single-class, closed networks with <em>N</em> requests.  The
normalization constants are returned as vector
<code><var>G</var>=[<var>G</var>(1), <var>G</var>(2), &hellip; <var>G</var>(N+1)]</code> where
<code><var>G</var>(i+1)</code> is the value of <em>G(i)</em> (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).
</p>
<p><code>queueing</code> implements the convolution algorithm, in the function
<code>qncsconv</code> and <code>qncsconvld</code>. The first one
supports single-station nodes, multiple-station nodes and IS nodes.
The second one supports networks with general load-dependent service
centers.
</p>

<a name="doc_002dqncsconv"></a>

<dl>
<dt><a name="index-qncsconv"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsconv</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsconv-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsconv</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-closed-network_002c-single-class-4"></a>
<a name="index-normalization-constant-1"></a>
<a name="index-convolution-algorithm"></a>

<p>Analyze product-form, single class closed networks with <em>K</em> service centers using the convolution algorithm.
</p>
<p>Load-independent service centers, multiple servers (<em>M/M/m</em>
queues) and IS nodes are supported. For general load-dependent
service centers, use <code>qncsconvld</code> instead.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Number of requests in the system (<code><var>N</var>&gt;0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>average service time on center <em>k</em> (<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>visit count of service center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. If <code><var>m</var>(k) &lt; 1</code>,
center <em>k</em> is a delay center (IS); if <code><var>m</var>(k) &ge;
1</code>, center <em>k</em> it is a regular <em>M/M/m</em> queueing center
with <code><var>m</var>(k)</code> identical servers. Default is
<code><var>m</var>(k) = 1</code> for all <em>k</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUT</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>center <em>k</em> utilization.
For IS nodes, <code><var>U</var>(k)</code> is the <em>traffic intensity</em>
<code><var>X</var>(k) * <var>S</var>(k)</code>.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>average response time of center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of customers at center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>throughput of center <em>k</em>.
</p>
</dd>
<dt><code><var>G</var>(n)</code></dt>
<dd><p>Vector of normalization constants. <code><var>G</var>(n+1)</code> contains the value of
the normalization constant with <em>n</em> requests
<em>G(n)</em>, <em>n=0, &hellip;, N</em>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsconvld.
</p>
</dd></dl>


<p><strong>NOTE</strong>
</p>
<p>For a network with <em>K</em> service centers and <em>N</em> requests,
this implementation of the convolution algorithm has time and space
complexity <em>O(NK)</em>.
</p>
<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Jeffrey P. Buzen, <cite>Computational Algorithms for Closed Queueing
Networks with Exponential Servers</cite>, Communications of the ACM, volume
16, number 9, September 1973,
pp. 527&ndash;531. <a href="http://doi.acm.org/10.1145/362342.362345">10.1145/362342.362345</a>

<a name="index-Buzen_002c-J_002e-P_002e"></a>

</li></ul>

<p>This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317.
</p>
<a name="index-Bolch_002c-G_002e-9"></a>
<a name="index-Greiner_002c-S_002e-9"></a>
<a name="index-de-Meer_002c-H_002e-9"></a>
<a name="index-Trivedi_002c-K_002e-9"></a>

<p><strong>EXAMPLE</strong>
</p>
<p>The normalization constant <em>G</em> can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with <em>K</em> nodes and <em>N</em> requests. Let
<code><var>n</var>=[<em>n_1, n_2, &hellip;, n_K</em>]</code> be a valid population
vector, <em>\sum_{k=1}^K n_k = N</em>. Then, the steady-state
probability <code><var>p</var>(k)</code> to have <code><var>n</var>(k)</code> requests at
service center <em>k</em> can be computed as:
</p>

<div class="example">
<pre class="verbatim"> n = [1 2 0];
 N = sum(n); # Total population size
 S = [ 1/0.8 1/0.6 1/0.4 ];
 m = [ 2 3 1 ];
 V = [ 1 .667 .2 ];
 [U R Q X G] = qncsconv( N, S, V, m );
 p = [0 0 0]; # initialize p
 # Compute the probability to have n(k) jobs at service center k
 for k=1:3
   p(k) = (V(k)*S(k))^n(k) / G(N+1) * ...
          (G(N-n(k)+1) - V(k)*S(k)*G(N-n(k)) );
   printf(&quot;Prob( n(%d) = %d )=%f\n&quot;, k, n(k), p(k) );
 endfor
</pre><pre class="example">-| Prob( n(1) = 1 ) = 0.17975
-| Prob( n(2) = 2 ) = 0.48404
-| Prob( n(3) = 0 ) = 0.52779
</pre></div>

<p>(recall that <code><var>G</var>(<var>N</var>+1)</code> represents <em>G(N)</em>, since
in Octave array indices start at one).
</p>

<a name="doc_002dqncsconvld"></a>

<dl>
<dt><a name="index-qncsconvld"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] =</em> <strong>qncsconvld</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dd>
<a name="index-closed-network"></a>
<a name="index-normalization-constant-2"></a>
<a name="index-convolution-algorithm-1"></a>
<a name="index-load_002ddependent-service-center-1"></a>

<p>Convolution algorithm for product-form, single-class closed
queueing networks with <em>K</em> general load-dependent service
centers.
</p>
<p>This function computes steady-state performance measures for
single-class, closed networks with load-dependent service centers
using the convolution algorithm; the normalization constants are also
computed. The normalization constants are returned as vector
<code><var>G</var>=[<var>G</var>(1), &hellip;, <var>G</var>(N+1)]</code> where
<code><var>G</var>(i+1)</code> is the value of <em>G(i)</em>.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>Number of requests in the system (<code><var>N</var>&gt;0</code>).
</p>
</dd>
<dt><code><var>S</var>(k,n)</code></dt>
<dd><p>mean service time at center <em>k</em> where there are <em>n</em>
requests, <em>1 &le; n &le; N</em>. <code><var>S</var>(k,n)</code> <em>= 1 / \mu_{k,n}</em>, where <em>\mu_{k,n}</em> is the service rate of center
<em>k</em> when there are <em>n</em> requests.
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>visit count of service center <em>k</em>
(<code><var>V</var>(k) &ge; 0</code>). The length of <var>V</var> is the number of
servers <em>K</em> in the network.
</p>
</dd>
</dl>

<p><strong>OUTPUT</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>center <em>k</em> utilization.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>average response time at center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests in center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>k</em> throughput.
</p>
</dd>
<dt><code><var>G</var>(n)</code></dt>
<dd><p>Normalization constants (vector). <code><var>G</var>(n+1)</code>
corresponds to <em>G(n)</em>, as array indexes in Octave start
from 1.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsconv.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Herb Schwetman, <cite>Some Computational Aspects of Queueing Network
Models</cite>, Technical Report
<a href="http://docs.lib.purdue.edu/cstech/285/">CSD-TR-354</a>, Department
of Computer Sciences, Purdue University, February 1981 (revised).

<a name="index-Schwetman_002c-H_002e"></a>

</li><li> M. Reiser, H. Kobayashi, <cite>On The Convolution Algorithm for
Separable Queueing Networks</cite>, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29&ndash;31,
1976). SIGMETRICS &rsquo;76. ACM, New York, NY,
pp. 109&ndash;117. <a href="http://doi.acm.org/10.1145/800200.806187">10.1145/800200.806187</a>

<a name="index-Reiser_002c-M_002e-2"></a>
<a name="index-Kobayashi_002c-H_002e"></a>

</li></ul>

<p>This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317. Function <code>qncsconvld</code> is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
<code>F()</code> in <code>qncsconvld</code> which has been made similar to
function <em>f_i</em> defined in Schwetman, <cite>Some Computational
Aspects of Queueing Network Models</cite>.
</p>
<a name="index-Bolch_002c-G_002e-10"></a>
<a name="index-Greiner_002c-S_002e-10"></a>
<a name="index-de-Meer_002c-H_002e-10"></a>
<a name="index-Trivedi_002c-K_002e-10"></a>

<a name="Non-Product_002dForm-QNs-1"></a>
<h4 class="subsection">5.2.3 Non Product-Form QNs</h4>
<a name="Non-Product_002dForm-QNs"></a><a name="doc_002dqncsmvablo"></a>

<dl>
<dt><a name="index-qncsmvablo"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncsmvablo</strong> <em>(<var>N</var>, <var>S</var>, <var>M</var>, <var>P</var> )</em></dt>
<dd>
<a name="index-queueing-network-with-blocking"></a>
<a name="index-blocking-queueing-network"></a>
<a name="index-closed-network_002c-finite-capacity"></a>
<a name="index-MVABLO"></a>

<p>Approximate MVA algorithm for closed queueing networks with blocking.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>number of requests in the system. <var>N</var> must be strictly greater
than zero, and less than the overall network capacity: <code>0 &lt;
<var>N</var> &lt; sum(<var>M</var>)</code>.
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>average service time on server <em>k</em> (<code><var>S</var>(k) &gt; 0</code>).
</p>
</dd>
<dt><code><var>M</var>(k)</code></dt>
<dd><p>capacity of center <em>k</em>. The capacity is the maximum number of requests in a service
center, including the request in service (<code><var>M</var>(k) &ge; 1</code>).
</p>
</dd>
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>probability that a request which completes
service at server <em>i</em> will be transferred to server <em>j</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>center <em>k</em> utilization.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>average response time of service center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of requests in service center <em>k</em> (including
the request in service).
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>center <em>k</em> throughput.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnopen, qnclosed.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Ian F. Akyildiz, <cite>Mean Value Analysis for Blocking Queueing
Networks</cite>, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418&ndash;428.  <a href="http://dx.doi.org/10.1109/32.4663">10.1109/32.4663</a>

<a name="index-Akyildiz_002c-I_002e-F_002e"></a>

</li></ul>

<a name="doc_002dqnmarkov"></a>

<dl>
<dt><a name="index-qnmarkov"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnmarkov</strong> <em>(<var>lambda</var>, <var>S</var>, <var>C</var>, <var>P</var>)</em></dt>
<dt><a name="index-qnmarkov-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnmarkov</strong> <em>(<var>lambda</var>, <var>S</var>, <var>C</var>, <var>P</var>, <var>m</var>)</em></dt>
<dt><a name="index-qnmarkov-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnmarkov</strong> <em>(<var>N</var>, <var>S</var>, <var>C</var>, <var>P</var>)</em></dt>
<dt><a name="index-qnmarkov-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnmarkov</strong> <em>(<var>N</var>, <var>S</var>, <var>C</var>, <var>P</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-closed-network_002c-multiple-classes"></a>
<a name="index-closed-network_002c-finite-capacity-1"></a>
<a name="index-blocking-queueing-network-1"></a>
<a name="index-RS-blocking"></a>

<p>Compute utilization, response time, average queue length and
throughput for open or closed queueing networks with finite capacity.
Blocking type is Repetitive-Service (RS). This function explicitly
generates and solve the underlying Markov chain, and thus might
require a large amount of memory.
</p>
<p>More specifically, networks which can me analyzed by this
function have the following properties:
</p>
<ul>
<li> There exists only a single class of customers.

</li><li> The network has <em>K</em> service centers. Center
<em>k</em> has <em>m_k &gt; 0</em> servers, and has a total (finite) capacity of
<em>C_k \geq m_k</em> which includes both buffer space and servers.
The buffer space at service center <em>k</em> is therefore
<em>C_k - m_k</em>.

</li><li> The network can be open, with external arrival rate to
center <em>k</em> equal to 
<em>\lambda_k</em>, or closed with fixed
population size <em>N</em>. For closed networks, the population size
<em>N</em> must be strictly less than the network capacity: <em>N &lt; \sum_i C_i</em>.

</li><li> Average service times are load-independent.

</li><li> <em>P_{i, j}</em> is the probability that requests completing
execution at center <em>i</em> are transferred to
center <em>j</em>, <em>i \neq j</em>. For open networks, a request may leave the system
from any node <em>i</em> with probability <em>1-\sum_j P_{i, j}</em>.

</li><li> Blocking type is Repetitive-Service (RS). Service
center <em>j</em> is <em>saturated</em> if the number of requests is equal
to its capacity <em>C_j</em>. Under the RS blocking discipline,
a request completing service at center <em>i</em> which is being
transferred to a saturated server <em>j</em> is put back at the end of
the queue of <em>i</em> and will receive service again. Center <em>i</em>
then processes the next request in queue. External arrivals to a
saturated servers are dropped.

</li></ul>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var>(k)</code></dt>
<dt><code><var>N</var></code></dt>
<dd><p>If the first argument is a vector <var>lambda</var>, it is considered to be
the external arrival rate <code><var>lambda</var>(k) &ge; 0</code> to service center
<em>k</em> of an open network. If the first argument is a scalar, it is
considered as the population size <var>N</var> of a closed network; in this case
<var>N</var> must be strictly
less than the network capacity: <code><var>N</var> &lt; sum(<var>C</var>)</code>.
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>average service time at service center <em>k</em>
</p>
</dd>
<dt><code><var>C</var>(k)</code></dt>
<dd><p>capacity of service center <em>k</em>. The capacity includes both
the buffer and server space <code><var>m</var>(k)</code>. Thus the buffer space is
<code><var>C</var>(k)-<var>m</var>(k)</code>.
</p>
</dd>
<dt><code><var>P</var>(i,j)</code></dt>
<dd><p>transition probability from service center
<em>i</em> to service center <em>j</em>.
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at service center
<em>k</em>. Note that <code><var>m</var>(k) &ge; <var>C</var>(k)</code> for each <var>k</var>.
If <var>m</var> is omitted, all service centers are assumed to have a
single server (<code><var>m</var>(k) = 1</code> for all <em>k</em>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>center <em>k</em> utilization.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>response time on service center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of customers in the
service center <em>k</em>, <em>including</em> the request in service.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>throughput of service center <em>k</em>.
</p>
</dd>
</dl>

<blockquote>
<p><b>Note:</b> The space complexity of this implementation is <em>O(\prod_{k=1}^K (C_k + 1)^2)</em>. The time complexity is dominated by
the time needed to solve a linear system with <em>\prod_{k=1}^K (C_k + 1)</em> unknowns.
</p></blockquote>

</dd></dl>


<hr>
<a name="Multiple-Class-Models"></a>
<div class="header">
<p>
Next: <a href="#Generic-Algorithms" accesskey="n" rel="next">Generic Algorithms</a>, Previous: <a href="#Single-Class-Models" accesskey="p" rel="prev">Single Class Models</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Multiple-Class-Models-1"></a>
<h3 class="section">5.3 Multiple Class Models</h3>

<p>In multiple class queueing models, we assume that there exist <em>C</em>
different classes of requests. Each request from class <em>c</em> spends
on average time <em>S_{c, k}</em> in service at center <em>k</em>. For
open models, we denote with <em>{\bf \lambda} = \lambda_{c, k}</em> the
arrival rates, where <em>\lambda_{c, k}</em> is the external arrival
rate of class <em>c</em> requests at center <em>k</em>. For closed models,
we denote with <em>{\bf N} = (N_1, N_2, &hellip;, N_C)</em> the population
vector, where <em>N_c</em> is the number of class <em>c</em> requests in
the system.
</p>
<p>The transition probability matrix for multiple class networks is a
<em>C \times K \times C \times K</em> matrix <em>{\bf P} = [P_{r, i,
s, j}]</em> where <em>P_{r, i, s, j}</em> is the probability that a class
<em>r</em> request which completes service at center <em>i</em> will join
server <em>j</em> as a class <em>s</em> request.
</p>
<p>Model input and outputs can be adjusted by adding additional indexes
for the customer classes.
</p>
<p><strong>Model Inputs</strong>
</p>
<dl compact="compact">
<dt><em>lambda_{c, k}</em></dt>
<dd><p>(open networks) External arrival rate of class-<em>c</em> requests to service center <em>k</em>
</p>
</dd>
<dt><em>lambda</em></dt>
<dd><p>(open networks) Overall external arrival rate to the whole system: <em>\lambda = \sum_c \sum_k \lambda_{c, k}</em>
</p>
</dd>
<dt><em>N_c</em></dt>
<dd><p>(closed networks) Number of class <em>c</em> requests in the system.
</p>
</dd>
<dt><em>S_{c, k}</em></dt>
<dd><p>Average service time. <em>S_{c, k}</em> is the average service time on
service center <em>k</em> for class <em>c</em> requests.
</p>
</dd>
<dt><em>P_{r, i, s, j}</em></dt>
<dd><p>Routing probability matrix. <em>{\bf P} = [P_{r, i, s, j}]</em> is a <em>C
\times K \times C \times K</em> matrix such that <em>P_{r, i, s, j}</em> is
the probability that a class <em>r</em> request which completes service
at server <em>i</em> will move to server <em>j</em> as a class <em>s</em>
request.
</p>
</dd>
<dt><em>V_{c, k}</em></dt>
<dd><p>Mean number of visits of class <em>c</em> requests to center <em>k</em>.
</p>
</dd>
</dl>

<p><strong>Model Outputs</strong>
</p>
<dl compact="compact">
<dt><em>U_{c, k}</em></dt>
<dd><p>Utilization of service center <em>k</em> by class <em>c</em> requests. The
utilization is defined as the fraction of time in which the resource
is busy (i.e., the server is processing requests).  If center <em>k</em>
is a single-server or multiserver node, then 
<em>0 &le; U_{c, k} &le; 1</em>. 
If center <em>k</em> is an infinite server node (delay
center), then <em>U_{c, k}</em> denotes the <em>traffic intensity</em> and
is defined as <em>U_{c, k} = X_{c, k} S_{c, k}</em>; in this case the
utilization may be greater than one.
</p>
</dd>
<dt><em>R_{c, k}</em></dt>
<dd><p>Average response time experienced by class <em>c</em> requests on service
center <em>k</em>. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.
</p>
</dd>
<dt><em>Q_{c, k}</em></dt>
<dd><p>Average number of class <em>c</em> requests on service center
<em>k</em>. This includes both the requests in the queue, and the request
being served.
</p>
</dd>
<dt><em>X_{c, k}</em></dt>
<dd><p>Throughput of service center <em>k</em> for class <em>c</em> requests.  The
throughput is defined as the rate of completion of class <em>c</em>
requests.
</p>
</dd>
</dl>

<p>It is possible to define aggregate performance measures as follows:
</p>
<dl compact="compact">
<dt><em>U_k</em></dt>
<dd><p>Utilization of service center <em>k</em>:
<code>Uk = sum(U,k);</code>
</p>
</dd>
<dt><em>R_c</em></dt>
<dd><p>System response time for class <em>c</em> requests:
<code>Rc = sum( V.*R, 1 );</code>
</p>
</dd>
<dt><em>Q_c</em></dt>
<dd><p>Average number of class <em>c</em> requests in the system:
<code>Qc = sum( Q, 2 );</code>
</p>
</dd>
<dt><em>X_c</em></dt>
<dd><p>Class <em>c</em> throughput:
<code>X(c) = X(c,k) ./ V(c,k);</code> for any <em>k</em> for which <code>V(c,k) != 0</code>
</p>
</dd>
</dl>

<p>For closed networks, we can define the visit ratios <em>V_{s, j}</em>
for class <em>s</em> customers at service center <em>j</em> as follows:
</p>
<p>V_sj = sum_r sum_i V_ri P_risj    s=1,...,C, j=1,...,K
V_s r_s = 1                       s=1,...,C
</p>
<p>where <em>r_s</em> is the class <em>s</em>
reference station. Similarly to single class models, the traffic
equation for closed multiclass networks can be solved up to
multiplicative constants unless we choose one reference station for
each closed chain class and set its visit ratio to 1.
</p>
<p>For open networks the traffic equations are as follows:
</p>
<p>V_sj = P_0sj + sum_r sum_i V_ri P_risj  s=1,...,C, j=1,...,K
</p>
<p>where <em>P_{0, s, j}</em> is the probability that an external
arrival goes to service center <em>j</em> as a class-<em>s</em> request.
If <em>\lambda_{s, j}</em> is the external arrival rate of class
<em>s</em> requests to service center <em>j</em>, and <em>\lambda =
\sum_s \sum_j \lambda_{s, j}</em> is the overall external arrival rate,
then <em>P_{0, s, j} = \lambda_{s, j} / \lambda</em>.
</p>
<a name="doc_002dqncmvisits"></a>

<dl>
<dt><a name="index-qncmvisits"></a>Function File: <em>[<var>V</var> <var>ch</var>] =</em> <strong>qncmvisits</strong> <em>(<var>P</var>)</em></dt>
<dt><a name="index-qncmvisits-1"></a>Function File: <em>[<var>V</var> <var>ch</var>] =</em> <strong>qncmvisits</strong> <em>(<var>P</var>, <var>r</var>)</em></dt>
<dd>
<p>Compute the average number of visits to the service centers of a closed multiclass network with <em>K</em> service centers and <em>C</em> customer classes.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(r,i,s,j)</code></dt>
<dd><p>probability that a
class <em>r</em> request which completed service at center <em>i</em> is
routed to center <em>j</em> as a class <em>s</em> request. Class switching
is allowed.
</p>
</dd>
<dt><code><var>r</var>(c)</code></dt>
<dd><p>index of class <em>c</em> reference station,
<em>r(c) \in {1, &hellip;, K}</em>, <em>1 &le; c &le; C</em>.
The class <em>c</em> visit count to server <code><var>r</var>(c)</code>
(<code><var>V</var>(c,r(c))</code>) is conventionally set to 1. The reference
station serves two purposes: (i) its throughput is assumed to be the
system throughput, and (ii) a job returning to the reference station
is assumed to have completed one cycle. Default is to consider
station 1 as the reference station for all classes.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>V</var>(c,i)</code></dt>
<dd><p>number of visits of class <em>c</em> requests at center <em>i</em>.
</p>
</dd>
<dt><code><var>ch</var>(c)</code></dt>
<dd><p>chain number that class <em>c</em> belongs
to. Different classes can belong to the same chain. Chains are
numbered sequentially starting from 1 (<em>1, 2, &hellip;</em>). The
total number of chains is <code>max(<var>ch</var>)</code>.
</p>
</dd>
</dl>

</dd></dl>


<a name="doc_002dqnomvisits"></a>

<dl>
<dt><a name="index-qnomvisits"></a>Function File: <em><var>V</var> =</em> <strong>qnomvisits</strong> <em>(<var>P</var>, <var>lambda</var>)</em></dt>
<dd>
<p>Compute the visit ratios to the service centers of an open multiclass network with <em>K</em> service centers and <em>C</em> customer classes.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>P</var>(r,i,s,j)</code></dt>
<dd><p>probability that a class <em>r</em> request which completed service at center <em>i</em> is
routed to center <em>j</em> as a class <em>s</em> request. Class switching
is supported.
</p>
</dd>
<dt><code><var>lambda</var>(r,i)</code></dt>
<dd><p>external arrival rate of class <em>r</em> requests to center <em>i</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>V</var>(r,i)</code></dt>
<dd><p>visit ratio of class <em>r</em> requests at center <em>i</em>.
</p>
</dd>
</dl>

</dd></dl>


<a name="Open-Networks-1"></a>
<h4 class="subsection">5.3.1 Open Networks</h4>

<a name="doc_002dqnom"></a>

<dl>
<dt><a name="index-qnom"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnom</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qnom-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnom</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qnom-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnom</strong> <em>(<var>lambda</var>, <var>S</var>, <var>P</var>)</em></dt>
<dt><a name="index-qnom-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnom</strong> <em>(<var>lambda</var>, <var>S</var>, <var>P</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-open-network_002c-multiple-classes"></a>
<a name="index-multiclass-network_002c-open"></a>

<p>Exact analysis of open, multiple-class BCMP networks. The network can
be made of <em>single-server</em> queueing centers (FCFS, LCFS-PR or
PS) or delay centers (IS). This function assumes a network with
<em>K</em> service centers and <em>C</em> customer classes.
</p>
<blockquote>
<p><b>Note:</b> If this function is called specifying the visit ratios <var>V</var>,
class switching is <strong>not</strong> allowed. If this function is called
specifying the routing probability matrix <var>P</var>, then class
switching <strong>is</strong> allowed; however, in this case all nodes are
restricted to be fixed rate servers or delay centers:
multiple-server and general load-dependent centers are not
supported. Note that the meaning of parameter <var>lambda</var> is
different from one case to the other (see below).
</p></blockquote>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var>(c)</code></dt>
<dd><p>If this function is invoked as <code>qnom(lambda, S, V, &hellip;)</code>,
then <code><var>lambda</var>(c)</code> is the external arrival rate of class
<em>c</em> customers (<code><var>lambda</var>(c) &ge; 0</code>). If this
function is invoked as <code>qnom(lambda, S, P, &hellip;)</code>, then
<code><var>lambda</var>(c,k)</code> is the external arrival rate of class
<em>c</em> customers at center <em>k</em> (<code><var>lambda</var>(c,k)
&ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c,k)</code></dt>
<dd><p>mean service time of class <em>c</em> customers on the service center
<em>k</em> (<code><var>S</var>(c,k)&gt;0</code>). For FCFS nodes, mean service
times must be class-independent.
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>visit ratio of class <em>c</em> customers to service center <em>k</em>
(<code><var>V</var>(c,k) &ge; 0 </code>). <strong>If you pass this argument,
class switching is not allowed</strong>
</p>
</dd>
<dt><code><var>P</var>(r,i,s,j)</code></dt>
<dd><p>probability that a class <em>r</em> job completing service at center
<em>i</em> is routed to center <em>j</em> as a class <em>s</em> job.
<strong>If you pass argument <var>P</var>, class switching is allowed</strong>;
however, all servers must be fixed-rate or infinite-server nodes
(<code><var>m</var>(k) &le; 1</code> for all <em>k</em>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. If <code><var>m</var>(k) &lt; 1</code>,
enter <em>k</em> is a delay center (IS); otherwise it is a regular
queueing center with <code><var>m</var>(k)</code> servers. Default is
<code><var>m</var>(k) = 1</code> for all <em>k</em>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(c,k)</code></dt>
<dd><p>If <em>k</em> is a queueing center, then <code><var>U</var>(c,k)</code> is the
class <em>c</em> utilization of center <em>k</em>. If <em>k</em> is an IS
node, then <code><var>U</var>(c,k)</code> is the class <em>c</em> <em>traffic
intensity</em> defined as <code><var>X</var>(c,k)*<var>S</var>(c,k)</code>.
</p>
</dd>
<dt><code><var>R</var>(c,k)</code></dt>
<dd><p>class <em>c</em> response time at center <em>k</em>. The system
response time for class <em>c</em> requests can be computed as
<code>dot(<var>R</var>, <var>V</var>, 2)</code>.
</p>
</dd>
<dt><code><var>Q</var>(c,k)</code></dt>
<dd><p>average number of class <em>c</em> requests at center <em>k</em>. The
average number of class <em>c</em> requests in the system <var>Qc</var>
can be computed as <code>Qc = sum(<var>Q</var>, 2)</code>
</p>
</dd>
<dt><code><var>X</var>(c,k)</code></dt>
<dd><p>class <em>c</em> throughput at center <em>k</em>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnopen,qnos,qnomvisits.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> 
Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.1 (&quot;Open Model Solution Techniques&quot;).

<a name="index-Lazowska_002c-E_002e-D_002e-1"></a>
<a name="index-Zahorjan_002c-J_002e-1"></a>
<a name="index-Graham_002c-G_002e-S_002e-1"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-1"></a>

</li></ul>

<a name="Closed-Networks-1"></a>
<h4 class="subsection">5.3.2 Closed Networks</h4>

<a name="doc_002dqncmpopmix"></a>

<dl>
<dt><a name="index-qncmpopmix"></a>Function File: <em>pop_mix =</em> <strong>qncmpopmix</strong> <em>(<var>k</var>, <var>N</var>)</em></dt>
<dd>
<a name="index-population-mix"></a>
<a name="index-closed-network_002c-multiple-classes-1"></a>

<p>Return the set of population mixes for a closed multiclass queueing
network with exactly <var>k</var> customers. Specifically, given a
closed multiclass QN with <em>C</em> customer classes, where there
are <code><var>N</var>(c)</code> class <em>c</em> requests, a <em>k</em>-mix
<var>mix</var> is a <em>C</em>-dimensional vector with the following
properties:
</p>
<div class="example">
<pre class="example">all( mix &gt;= 0 );
all( mix &lt;= N );
sum( mix ) == k;
</pre></div>

<p><var>pop_mix</var> is a matrix with <em>C</em> columns, such
that each row represents a valid mix.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>k</var></code></dt>
<dd><p>Size of the requested mix (scalar, <code><var>k</var> &ge; 0</code>).
</p>
</dd>
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests (<code><var>k</var> &le; sum(<var>N</var>)</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>pop_mix</var>(i,c)</code></dt>
<dd><p>number of class <em>c</em> requests in the <em>i</em>-th population
mix. The number of mixes is <code>rows(<var>pop_mix</var>)</code>.
</p>
</dd>
</dl>

<p>If you are interested in the number of <em>k</em>-mixes only, you can
use the funcion <code>qnmvapop</code>.
</p>
<br>
<p><strong>See also:</strong> qncmnpop.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report
<a href="http://docs.lib.purdue.edu/cstech/286/">80-355</a>, Department of Computer
Sciences, Purdue University, revised February 15, 1982.

</li></ul>

<p>The slightly different problem of enumerating all tuples <em>k_1,
k_2, &hellip;, k_N</em> such that <em>\sum_i k_i = k</em> and <em>k_i
&ge; 0</em>, for a given <em>k &ge; 0</em> has been described in
S. Santini, <cite>Computing the Indices for a Complex Summation</cite>,
unpublished report, available at
<a href="http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf">http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf</a>
</p>
<a name="index-Schwetman_002c-H_002e-1"></a>
<a name="index-Santini_002c-S_002e"></a>

<a name="doc_002dqncmnpop"></a>

<dl>
<dt><a name="index-qncmnpop"></a>Function File: <em><var>H</var> =</em> <strong>qncmnpop</strong> <em>(<var>N</var>)</em></dt>
<dd>
<a name="index-population-mix-1"></a>
<a name="index-closed-network_002c-multiple-classes-2"></a>

<p>Given a network with <em>C</em> customer classes, this function
computes the number of <em>k</em>-mixes <code><var>H</var>(r,k)</code> that can
be constructed by the multiclass MVA algorithm by allocating
<em>k</em> customers to the first <em>r</em> classes.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class-<em>c</em> requests in the system. The total number
of requests in the network is <code>sum(<var>N</var>)</code>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>H</var>(r,k)</code></dt>
<dd><p>is the number of <em>k</em> mixes that can be constructed allocating
<em>k</em> customers to the first <em>r</em> classes.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncmmva,qncmpopmix.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<p>Zahorjan, J. and Wong, E. <cite>The solution of separable queueing
network models using mean value analysis</cite>. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
<a href="http://doi.acm.org/10.1145/1010629.805477">10.1145/1010629.805477</a>
</p>
<a name="index-Zahorjan_002c-J_002e-2"></a>
<a name="index-Wong_002c-E_002e"></a>

<a name="doc_002dqncmmva"></a>

<dl>
<dt><a name="index-qncmmva"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var> )</em></dt>
<dt><a name="index-qncmmva-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncmmva-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncmmva-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dt><a name="index-qncmmva-4"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>P</var>)</em></dt>
<dt><a name="index-qncmmva-5"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>P</var>, <var>r</var>)</em></dt>
<dt><a name="index-qncmmva-6"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmva</strong> <em>(<var>N</var>, <var>S</var>, <var>P</var>, <var>r</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029-2"></a>
<a name="index-closed-network_002c-multiple-classes-3"></a>
<a name="index-multiclass-network_002c-closed"></a>

<p>Compute steady-state performance measures for closed, multiclass
queueing networks using the Mean Value Analysys (MVA) algorithm.
</p>
<p>Queueing policies at service centers can be any of the following:
</p>
<dl compact="compact">
<dt><strong>FCFS</strong></dt>
<dd><p>(First-Come-First-Served) customers are served in order of arrival;
multiple servers are allowed. For this kind of queueing discipline,
average service times must be class-independent.
</p>
</dd>
<dt><strong>PS</strong></dt>
<dd><p>(Processor Sharing) customers are served in parallel by a single
server, each customer receiving an equal share of the service rate.
</p>
</dd>
<dt><strong>LCFS-PR</strong></dt>
<dd><p>(Last-Come-First-Served, Preemptive Resume) customers are served in
reverse order of arrival by a single server and the last arrival
preempts the customer in service who will later resume service at the
point of interruption.
</p>
</dd>
<dt><strong>IS</strong></dt>
<dd><p>(Infinite Server) customers are delayed independently of other
customers at the service center (there is effectively an infinite
number of servers).
</p>
</dd>
</dl>

<blockquote>
<p><b>Note:</b> If this function is called specifying the visit ratios
<var>V</var>, then class switching is <strong>not</strong> allowed.
</p>
<p>If this function is called specifying the routing probability matrix
<var>P</var>, then class switching <strong>is</strong> allowed; however, in this
case all nodes are restricted to be fixed rate servers or delay
centers: multiple-server and general load-dependent centers are not
supported.
</p></blockquote>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests; <code><var>N</var>(c) &ge; 0</code>. If
class <em>c</em> has no requests (<code><var>N</var>(c) == 0</code>), then for
all <var>k</var>, this function returns 
<code><var>U</var>(c,k) = <var>R</var>(c,k) = <var>Q</var>(c,k) = <var>X</var>(c,k) = 0</code>
</p>
</dd>
<dt><code><var>S</var>(c,k)</code></dt>
<dd><p>mean service time for class <em>c</em> requests at center <em>k</em>
(<code><var>S</var>(c,k) &ge; 0</code>). If the service time at center
<em>k</em> is class-dependent, then center <em>k</em> is assumed
to be of type <em>-/G/1</em>&ndash;PS (Processor Sharing). If center
<em>k</em> is a FCFS node (<code><var>m</var>(k)&gt;1</code>), then the service
times <strong>must</strong> be class-independent, i.e., all classes
<strong>must</strong> have the same service time.
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em> requests at
center <em>k</em>; <code><var>V</var>(c,k) &ge; 0</code>, default is 1.
<strong>If you pass this argument, class switching is not allowed</strong>
</p>
</dd>
<dt><code><var>P</var>(r,i,s,j)</code></dt>
<dd><p>probability that a class <em>r</em> request completing service at center
<em>i</em> is routed to center <em>j</em> as a class <em>s</em> request; the
reference stations for each class are specified with the paramter
<var>r</var>. <strong>If you pass argument <var>P</var>, class switching is
allowed</strong>; however, you can not specify any external delay (i.e.,
<var>Z</var> must be zero) and all servers must be fixed-rate or
infinite-server nodes (<code><var>m</var>(k) &le; 1</code> for all
<em>k</em>).
</p>
</dd>
<dt><code><var>r</var>(c)</code></dt>
<dd><p>reference station for class <em>c</em>. If omitted, station 1 is the
reference station for all classes. See <code>qncmvisits</code>.
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>If <code><var>m</var>(k)&lt;1</code>, then center <em>k</em> is assumed to be a delay
center (IS node <em>-/G/\infty</em>). If <code><var>m</var>(k)==1</code>, then
service center <em>k</em> is a regular queueing center
(<em>M/M/1</em>&ndash;FCFS, <em>-/G/1</em>&ndash;LCFS-PR or <em>-/G/1</em>&ndash;PS).
Finally, if <code><var>m</var>(k)&gt;1</code>, center <em>k</em> is a
<em>M/M/m</em>&ndash;FCFS center with <code><var>m</var>(k)</code> identical servers.
Default is <code><var>m</var>(k)=1</code> for each <em>k</em>.
</p>
</dd>
<dt><code><var>Z</var>(c)</code></dt>
<dd><p>class <em>c</em> external delay (think time); <code><var>Z</var>(c) &ge;
0</code>. Default is 0. This parameter can not be used if you pass a
routing matrix as the second parameter of <code>qncmmva</code>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(c,k)</code></dt>
<dd><p>If <em>k</em> is a FCFS, LCFS-PR or PS node (<code><var>m</var>(k) &ge;
1</code>), then <code><var>U</var>(c,k)</code> is the class <em>c</em> utilization at
center <em>k</em>, <em>0 &le; U(c,k) &le; 1</em>. If <em>k</em> is an
IS node, then <code><var>U</var>(c,k)</code> is the class <em>c</em> <em>traffic
intensity</em> at center <em>k</em>, defined as <code><var>U</var>(c,k) =
<var>X</var>(c,k)*<var>S</var>(c,k)</code>. In this case the value of
<code><var>U</var>(c,k)</code> may be greater than one.
</p>
</dd>
<dt><code><var>R</var>(c,k)</code></dt>
<dd><p>class <em>c</em> response time at center <em>k</em>. The class <em>c</em>
<em>residence time</em> at center <em>k</em> is <code><var>R</var>(c,k) *
<var>C</var>(c,k)</code>. The total class <em>c</em> system response time is
<code>dot(<var>R</var>, <var>V</var>, 2)</code>.
</p>
</dd>
<dt><code><var>Q</var>(c,k)</code></dt>
<dd><p>average number of class <em>c</em> requests at center <em>k</em>. The
total number of requests at center <em>k</em> is
<code>sum(<var>Q</var>(:,k))</code>. The total number of class <em>c</em>
requests in the system is <code>sum(<var>Q</var>(c,:))</code>.
</p>
</dd>
<dt><code><var>X</var>(c,k)</code></dt>
<dd><p>class <em>c</em> throughput at center <em>k</em>. The class <em>c</em>
throughput can be computed as <code><var>X</var>(c,1) / <var>V</var>(c,1)</code>.
</p>
</dd>
</dl>

<blockquote>
<p><b>Note on numerical stability:</b> In presence of load-dependent servers (e.g., if <code><var>m</var>(i)&gt;1</code>
for some <em>i</em>), the MVA algorithm is known to be numerically
unstable. Generally this problem shows up as negative values for the
computed response times or utilizations. This is not a problem with the
<code>queueing</code> package, but with the MVA algorithm;
as such, there is no known workaround at the moment (aoart from using a
different solution technique, if available). This function prints a
warning if it detects numerical problems; you can disable the warning
with the command <code>warning(&quot;off&quot;, &quot;qn:numerical-instability&quot;)</code>.
</p></blockquote>

<br>
<p><strong>See also:</strong> qnclosed, qncmmvaapprox, qncmvisits.
</p>
</dd></dl>


<p><strong>NOTE</strong>
</p>
<p>Given a network with <em>K</em> service centers, <em>C</em> job classes
and population vector <em>{\bf N}=(N_1, N_2, &hellip;, N_C)</em>, the MVA
algorithm requires space <em>O(C \prod_i (N_i + 1))</em>. The time
complexity is <em>O(CK\prod_i (N_i + 1))</em>. This implementation is
slightly more space-efficient (see details in the code). While the
space requirement can be mitigated by using some optimizations, the
time complexity can not. If you need to analyze large closed networks
you should consider the <code>qncmmvaap</code> function, which implements
the approximate MVA algorithm. Note however that <code>qncmmvaap</code>
will only provide approximate results.
</p>

<p><strong>REFERENCES</strong>
</p>
<p>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>
</p>
<a name="index-Reiser_002c-M_002e-3"></a>
<a name="index-Lavenberg_002c-S_002e-S_002e-2"></a>

<p>This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, <cite>Quantitative System Performance: Computer
System Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.2.1 (&quot;Exact Solution Techniques&quot;).
</p>
<a name="index-Bolch_002c-G_002e-11"></a>
<a name="index-Greiner_002c-S_002e-11"></a>
<a name="index-de-Meer_002c-H_002e-11"></a>
<a name="index-Trivedi_002c-K_002e-11"></a>
<a name="index-Lazowska_002c-E_002e-D_002e-2"></a>
<a name="index-Zahorjan_002c-J_002e-3"></a>
<a name="index-Graham_002c-G_002e-S_002e-2"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-2"></a>

<a name="doc_002dqncmmvaap"></a>

<dl>
<dt><a name="index-qncmmvaap"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncmmvaap-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncmmvaap-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dt><a name="index-qncmmvaap-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>, <var>tol</var>)</em></dt>
<dt><a name="index-qncmmvaap-4"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qncmmvaap</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>, <var>tol</var>, <var>iter_max</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-1"></a>
<a name="index-MVA_002c-approximate-1"></a>
<a name="index-closed-network_002c-multiple-classes-4"></a>
<a name="index-multiclass-network_002c-closed-1"></a>

<p>Approximate Mean Value Analysis (MVA) for closed, multiclass
queueing networks with <em>K</em> service centers and <em>C</em>
customer classes.
</p>
<p>This implementation uses Bard and Schweitzer approximation. It is based
on the assumption that
the queue length at service center <em>k</em> with population
set <em>{\bf N}-{\bf 1}_c</em> is approximately equal to the queue length 
with population set <em>\bf N</em>, times <em>(n-1)/n</em>:
</p>
<div class="example">
<pre class="example">Q_i(N-1c) ~ (n-1)/n Q_i(N)
</pre></div>

<p>where <em>\bf N</em> is a valid population mix, <em>{\bf N}-{\bf 1}_c</em>
is the population mix <em>\bf N</em> with one class <em>c</em> customer
removed, and <em>n = \sum_c N_c</em> is the total number of requests.
</p>
<p>This implementation works for networks with infinite server (IS)
and single-server nodes only.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests in the system (<code><var>N</var>(c) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c,k)</code></dt>
<dd><p>mean service time for class <em>c</em> customers at center <em>k</em>
(<code><var>S</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em> requests to center
<em>k</em> (<code><var>V</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. If <code><var>m</var>(k) &lt; 1</code>,
then the service center <em>k</em> is assumed to be a delay center
(IS). If <code><var>m</var>(k) == 1</code>, service center <em>k</em> is a
regular queueing center (FCFS, LCFS-PR or PS) with a single server
node. If omitted, each service center has a single server. Note
that multiple server nodes are not supported.
</p>
</dd>
<dt><code><var>Z</var>(c)</code></dt>
<dd><p>class <em>c</em> external delay (<code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
<dt><code><var>tol</var></code></dt>
<dd><p>Stopping tolerance (<code><var>tol</var>&gt;0</code>). The algorithm stops if
the queue length computed on two subsequent iterations are less than
<var>tol</var>. Default is <em>10^{-5}</em>.
</p>
</dd>
<dt><code><var>iter_max</var></code></dt>
<dd><p>Maximum number of iterations (<code><var>iter_max</var>&gt;0</code>.
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(c,k)</code></dt>
<dd><p>If <em>k</em> is a FCFS, LCFS-PR or PS node, then <code><var>U</var>(c,k)</code>
is the utilization of class <em>c</em> requests on service center
<em>k</em>. If <em>k</em> is an IS node, then <code><var>U</var>(c,k)</code> is the
class <em>c</em> <em>traffic intensity</em> at device <em>k</em>,
defined as <code><var>U</var>(c,k) = <var>X</var>(c)*<var>S</var>(c,k)</code>
</p>
</dd>
<dt><code><var>R</var>(c,k)</code></dt>
<dd><p>response time of class <em>c</em> requests at service center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(c,k)</code></dt>
<dd><p>average number of class <em>c</em> requests at service center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(c,k)</code></dt>
<dd><p>class <em>c</em> throughput at service center <em>k</em>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncmmva.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<p>Y. Bard, <cite>Some Extensions to Multiclass Queueing Network Analysis</cite>,
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, Feb 1979, pp. 51&ndash;62.
</p>
<a name="index-Bard_002c-Y_002e"></a>

<p>P. Schweitzer, <cite>Approximate Analysis of Multiclass Closed
Networks of Queues</cite>, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25&ndash;29.
</p>
<a name="index-Schweitzer_002c-P_002e"></a>

<p>This implementation is based on Edward D. Lazowska, John Zahorjan, G.
Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>.  In
particular, see section 7.4.2.2 (&quot;Approximate Solution
Techniques&quot;). This implementation is slightly different from the one
described above, as it computes the average response times <em>R</em>
instead of the residence times.
</p>
<a name="index-Lazowska_002c-E_002e-D_002e-3"></a>
<a name="index-Zahorjan_002c-J_002e-4"></a>
<a name="index-Graham_002c-G_002e-S_002e-3"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-3"></a>

<a name="Mixed-Networks"></a>
<h4 class="subsection">5.3.3 Mixed Networks</h4>

<a name="doc_002dqnmix"></a>

<dl>
<dt><a name="index-qnmix"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnmix</strong> <em>(<var>lambda</var>, <var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-Mean-Value-Analysys-_0028MVA_0029-3"></a>
<a name="index-mixed-network"></a>

<p>Mean Value Analysis for mixed queueing networks. The network
consists of <em>K</em> service centers (single-server or delay
centers) and <em>C</em> independent customer chains. Both open and
closed chains are possible. <var>lambda</var> is the vector of per-chain
arrival rates (open classes); <var>N</var> is the vector of populations
for closed chains.
</p>
<blockquote>
<p><b>Note:</b> In this implementation class switching is <strong>not</strong> allowed. Each
customer class <em>must</em> correspond to an independent chain.
</p></blockquote>

<p>If the network is made of open or closed classes only, then this
function calls <code>qnom</code> or <code>qncmmva</code>
respectively, and prints a warning message.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var>(c)</code></dt>
<dt><code><var>N</var>(c)</code></dt>
<dd><p>For each customer chain <em>c</em>:
</p>
<ul>
<li> if <em>c</em> is a closed chain, then <code><var>N</var>(c)&gt;0</code> is the
number of class <em>c</em> requests and <code><var>lambda</var>(c)</code> must be
zero;

</li><li> If <em>c</em> is an open chain,
<code><var>lambda</var>(c)&gt;0</code> is the arrival rate of class <em>c</em>
requests and <code><var>N</var>(c)</code> must be zero;

</li></ul>

<p>In other words, for each class <em>c</em> the following must hold:
</p>
<div class="example">
<pre class="example">(<var>lambda</var>(c)&gt;0 &amp;&amp; <var>N</var>(c)==0) || (<var>lambda</var>(c)==0 &amp;&amp; <var>N</var>(c)&gt;0)
</pre></div>

</dd>
<dt><code><var>S</var>(c,k)</code></dt>
<dd><p>mean class <em>c</em> service time at center <em>k</em>,
<code><var>S</var>(c,k) &ge; 0</code>. For FCFS nodes, service times must be
class-independent.
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em> customers to center
<em>k</em> (<code><var>V</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. Only single-server
(<code><var>m</var>(k)==1</code>) or IS (Infinite Server) nodes
(<code><var>m</var>(k)&lt;1</code>) are supported. If omitted, each center is
assumed to be of type <em>M/M/1</em>-FCFS. Queueing discipline for
single-server nodes can be FCFS, PS or LCFS-PR.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(c,k)</code></dt>
<dd><p>class <em>c</em> utilization at center <em>k</em>.
</p>
</dd>
<dt><code><var>R</var>(c,k)</code></dt>
<dd><p>class <em>c</em> response time at center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(c,k)</code></dt>
<dd><p>average number of class <em>c</em> requests at center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(c,k)</code></dt>
<dd><p>class <em>c</em> throughput at center <em>k</em>.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncmmva, qncm.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.3 (&quot;Mixed Model Solution Techniques&quot;).
Note that in this function we compute the mean response time <em>R</em>
instead of the mean residence time as in the reference.

<a name="index-Lazowska_002c-E_002e-D_002e-4"></a>
<a name="index-Zahorjan_002c-J_002e-5"></a>
<a name="index-Graham_002c-G_002e-S_002e-4"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-4"></a>

</li><li> Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report
<a href="http://docs.lib.purdue.edu/cstech/286/">CSD-TR-355</a>, Department
of Computer Sciences, Purdue University, revised Feb 15, 1982.

<a name="index-Schwetman_002c-H_002e-2"></a>

</li></ul>

<hr>
<a name="Generic-Algorithms"></a>
<div class="header">
<p>
Next: <a href="#Bounds-Analysis" accesskey="n" rel="next">Bounds Analysis</a>, Previous: <a href="#Multiple-Class-Models" accesskey="p" rel="prev">Multiple Class Models</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Generic-Algorithms-1"></a>
<h3 class="section">5.4 Generic Algorithms</h3>

<p>The <code>queueing</code> package provides a high-level function
<code>qnsolve</code> for analyzing QN models. <code>qnsolve</code> takes as
input a high-level description of the queueing model, and delegates
the actual solution of the model to one of the lower-level
function. <code>qnsolve</code> supports single or multiclass models, but at
the moment only product-form networks can be analyzed. For non
product-form networks See <a href="#Non-Product_002dForm-QNs">Non Product-Form QNs</a>.
</p>
<p><code>qnsolve</code> accepts two input parameters. The first one is the list
of nodes, encoded as an Octave <em>cell array</em>. The second parameter
is the vector of visit ratios <var>V</var>, which can be either a vector
(for single-class models) or a two-dimensional matrix (for
multiple-class models).
</p>
<p>Individual nodes in the network are structures build using the
<code>qnmknode</code> function.
</p>
<a name="doc_002dqnmknode"></a>

<dl>
<dt><a name="index-qnmknode"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;m/m/m-fcfs&quot;</var>, <var>S</var>)</em></dt>
<dt><a name="index-qnmknode-1"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;m/m/m-fcfs&quot;</var>, <var>S</var>, <var>m</var>)</em></dt>
<dt><a name="index-qnmknode-2"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;m/m/1-lcfs-pr&quot;</var>, <var>S</var>)</em></dt>
<dt><a name="index-qnmknode-3"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;-/g/1-ps&quot;</var>, <var>S</var>)</em></dt>
<dt><a name="index-qnmknode-4"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;-/g/1-ps&quot;</var>, <var>S</var>, <var>s2</var>)</em></dt>
<dt><a name="index-qnmknode-5"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;-/g/inf&quot;</var>, <var>S</var>)</em></dt>
<dt><a name="index-qnmknode-6"></a>Function File: <em><var>Q</var> =</em> <strong>qnmknode</strong> <em>(<var>&quot;-/g/inf&quot;</var>, <var>S</var>, <var>s2</var>)</em></dt>
<dd>
<p>Creates a node; this function can be used together with
<code>qnsolve</code>. It is possible to create either single-class nodes
(where there is only one customer class), or multiple-class nodes
(where the service time is given per-class). Furthermore, it is
possible to specify load-dependent service times. String literals
are case-insensitive, so for example <var>&quot;-/g/inf&quot;</var>, <var>&quot;-/G/inf&quot;</var>
and <var>&quot;-/g/INF&quot;</var> are all equivalent.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><var>S</var></dt>
<dd><p>Mean service time.
</p>
<ul>
<li> If <em>S</em> is a scalar,
it is assumed to be a load-independent, class-independent service time.

</li><li> If <em>S</em> is a column vector, then <code><var>S</var>(c)</code> is assumed to
the the load-independent service time for class <em>c</em> customers.

</li><li> If <em>S</em> is a row vector, then <code><var>S</var>(n)</code> is assumed to be
the class-independent service time at the node, when there are <em>n</em>
requests. 

</li><li> Finally, if <var>S</var> is a two-dimensional matrix, then
<code><var>S</var>(c,n)</code> is assumed to be the class <em>c</em> service time
when there are <em>n</em> requests at the node.

</li></ul>

</dd>
<dt><var>m</var></dt>
<dd><p>Number of identical servers at the node. Default is <code><var>m</var>=1</code>.
</p>
</dd>
<dt><var>s2</var></dt>
<dd><p>Squared coefficient of variation for the service time. Default is 1.0.
</p>
</dd>
</dl>

<p>The returned struct <var>Q</var> should be considered opaque to the client.
</p>







<br>
<p><strong>See also:</strong> qnsolve.
</p>
</dd></dl>


<p>After the network has been defined, it is possible to solve it using
<code>qnsolve</code>.
</p>
<a name="doc_002dqnsolve"></a>

<dl>
<dt><a name="index-qnsolve"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnsolve</strong> <em>(<var>&quot;closed&quot;</var>, <var>N</var>, <var>QQ</var>, <var>V</var>)</em></dt>
<dt><a name="index-qnsolve-1"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnsolve</strong> <em>(<var>&quot;closed&quot;</var>, <var>N</var>, <var>QQ</var>, <var>V</var>, <var>Z</var>)</em></dt>
<dt><a name="index-qnsolve-2"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnsolve</strong> <em>(<var>&quot;open&quot;</var>, <var>lambda</var>, <var>QQ</var>, <var>V</var>)</em></dt>
<dt><a name="index-qnsolve-3"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnsolve</strong> <em>(<var>&quot;mixed&quot;</var>, <var>lambda</var>, <var>N</var>, <var>QQ</var>, <var>V</var>)</em></dt>
<dd>
<p>High-level function for analyzing QN models.
</p>
<ul>
<li> For <strong>closed</strong> networks, the following server types are
supported: <em>M/M/m</em>&ndash;FCFS, <em>-/G/\infty</em>, <em>-/G/1</em>&ndash;LCFS-PR,
<em>-/G/1</em>&ndash;PS and load-dependent variants.

</li><li> For <strong>open</strong> networks, the following server types are supported:
<em>M/M/m</em>&ndash;FCFS, <em>-/G/\infty</em> and <em>-/G/1</em>&ndash;PS. General
load-dependent nodes are <em>not</em> supported. Multiclass open networks
do not support multiple server <em>M/M/m</em> nodes, but only
single server <em>M/M/1</em>&ndash;FCFS.

</li><li> For <strong>mixed</strong> networks, the following server types are supported:
<em>M/M/1</em>&ndash;FCFS, <em>-/G/\infty</em> and <em>-/G/1</em>&ndash;PS. General
load-dependent nodes are <em>not</em> supported.

</li></ul>

<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dt><code><var>N</var>(c)</code></dt>
<dd><p>Number of requests in the system for closed networks. For
single-class networks, <var>N</var> must be a scalar. For multiclass
networks, <code><var>N</var>(c)</code> is the population size of closed class
<em>c</em>.
</p>
</dd>
<dt><code><var>lambda</var></code></dt>
<dt><code><var>lambda</var>(c)</code></dt>
<dd><p>External arrival rate (scalar) for open networks. For single-class
networks, <var>lambda</var> must be a scalar. For multiclass networks,
<code><var>lambda</var>(c)</code> is the class <em>c</em> overall arrival rate.
</p>
</dd>
<dt><code><var>QQ</var>{i}</code></dt>
<dd><p>List of queues in the network. This must be a cell array 
with <em>N</em> elements, such that <code><var>QQ</var>{i}</code> is
a struct produced by the <code>qnmknode</code> function.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay (&quot;think time&quot;) for closed networks. Default 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>U</var>(k)</code></dt>
<dd><p>If <em>k</em> is a FCFS node, then <code><var>U</var>(k)</code> is the utilization
of service center <em>k</em>. If <em>k</em> is an IS node, then
<code><var>U</var>(k)</code> is the <em>traffic intensity</em> defined as
<code><var>X</var>(k)*<var>S</var>(k)</code>.
</p>
</dd>
<dt><code><var>R</var>(k)</code></dt>
<dd><p>average response time of service center <em>k</em>.
</p>
</dd>
<dt><code><var>Q</var>(k)</code></dt>
<dd><p>average number of customers in service center <em>k</em>.
</p>
</dd>
<dt><code><var>X</var>(k)</code></dt>
<dd><p>throughput of service center <em>k</em>.
</p>
</dd>
</dl>

<p>Note that for multiclass networks, the computed results are per-class
utilization, response time, number of customers and throughput:
<code><var>U</var>(c,k)</code>, <code><var>R</var>(c,k)</code>, <code><var>Q</var>(c,k)</code>,
<code><var>X</var>(c,k)</code>.
</p>
<p>String literals are case-insensitive, so <var>&quot;closed&quot;</var>, <var>&quot;Closed&quot;</var>
and <var>&quot;CLoSEd&quot;</var> are all equivalent.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<p>Let us consider a closed, multiclass network with <em>C=2</em> classes
and <em>K=3</em> service center. Let the population be <em>M=(2, 1)</em>
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:
</p>
<ul>
<li> Node 1 is a <em>M/M/1</em>&ndash;FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix <code>[0.2 0.1 0.1; 0.2 0.1 0.1]</code>. Thus, <code><var>S</var>(1,2) =
0.2</code> means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

</li><li> Node 2 is a <em>-/G/1</em>&ndash;PS node, with service times
<em>S_{1, 2} = 0.4</em> for class 1, and <em>S_{2, 2} = 0.6</em> for class 2
requests;

</li><li> Node 3 is a <em>-/G/\infty</em> node (delay center), with service
times <em>S_{1, 3}=1</em> and <em>S_{2, 3}=2</em> for class 1 and 2
respectively.

</li></ul>

<p>After defining the per-class visit count <var>V</var> such that
<code><var>V</var>(c,k)</code> is the visit count of class <em>c</em> requests to
service center <em>k</em>.  We can define and solve the model as
follows:
</p>
<div class="example">
<pre class="example">

</pre><pre class="verbatim"> QQ = { qnmknode( &quot;m/m/m-fcfs&quot;, [0.2 0.1 0.1; 0.2 0.1 0.1] ), ...
        qnmknode( &quot;-/g/1-ps&quot;, [0.4; 0.6] ), ...
        qnmknode( &quot;-/g/inf&quot;, [1; 2] ) };
 V = [ 1 0.6 0.4; ...
       1 0.3 0.7 ];
 N = [ 2 1 ];
 [U R Q X] = qnsolve( &quot;closed&quot;, N, QQ, V );
</pre></div>

<a name="doc_002dqnclosed"></a>

<dl>
<dt><a name="index-qnclosed"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnclosed</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, &hellip;)</em></dt>
<dd>
<a name="index-closed-network_002c-single-class-5"></a>
<a name="index-closed-network_002c-multiple-classes-5"></a>

<p>This function computes steady-state performance measures of closed
queueing networks using the Mean Value Analysis (MVA) algorithm. The
qneneing network is allowed to contain fixed-capacity centers, delay
centers or general load-dependent centers. Multiple request
classes are supported.
</p>
<p>This function dispatches the computation to one of
<code>qncsemva</code>, <code>qncsmvald</code> or <code>qncmmva</code>.
</p>
<ul>
<li> If <var>N</var> is a scalar, the network is assumed to have a single
class of requests; in this case, the exact MVA algorithm is used to
analyze the network. If <var>S</var> is a vector, then <code><var>S</var>(k)</code>
is the average service time of center <em>k</em>, and this function
calls <code>qncsmva</code> which supports load-independent
service centers. If <var>S</var> is a matrix, <code><var>S</var>(k,i)</code> is the
average service time at center <em>k</em> when <em>i=1, &hellip;, N</em>
jobs are present; in this case, the network is analyzed with the
<code>qncmmvald</code> function.

</li><li> If <var>N</var> is a vector, the network is assumed to have multiple
classes of requests, and is analyzed using the exact multiclass
MVA algorithm as implemented in the <code>qncmmva</code> function.

</li></ul>

<br>
<p><strong>See also:</strong> qncsmva, qncsmvald, qncmmva.
</p>
</dd></dl>


<p><strong>EXAMPLE</strong>
</p>
<div class="example">
<pre class="verbatim"> P = [0 0.3 0.7; 1 0 0; 1 0 0]; # Transition probability matrix
 S = [1 0.6 0.2];               # Average service times
 m = ones(size(S));             # All centers are single-server
 Z = 2;                         # External delay
 N = 15;                        # Maximum population to consider
 V = qncsvisits(P);             # Compute number of visits
 X_bsb_lower = X_bsb_upper = X_ab_lower = X_ab_upper = X_mva = zeros(1,N);
 for n=1:N
   [X_bsb_lower(n) X_bsb_upper(n)] = qncsbsb(n, S, V, m, Z);
   [X_ab_lower(n) X_ab_upper(n)] = qncsaba(n, S, V, m, Z);
   [U R Q X] = qnclosed( n, S, V, m, Z );
   X_mva(n) = X(1)/V(1);
 endfor
 close all;
 plot(1:N, X_ab_lower,&quot;g;Asymptotic Bounds;&quot;, ...
      1:N, X_bsb_lower,&quot;k;Balanced System Bounds;&quot;, ...
      1:N, X_mva,&quot;b;MVA;&quot;, &quot;linewidth&quot;, 2, ...
      1:N, X_bsb_upper,&quot;k&quot;, 1:N, X_ab_upper,&quot;g&quot; );
 axis([1,N,0,1]); legend(&quot;location&quot;,&quot;southeast&quot;); legend(&quot;boxoff&quot;);
 xlabel(&quot;Number of Requests n&quot;); ylabel(&quot;System Throughput X(n)&quot;);
</pre></div>

<a name="doc_002dqnopen"></a>

<dl>
<dt><a name="index-qnopen"></a>Function File: <em>[<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] =</em> <strong>qnopen</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>, &hellip;)</em></dt>
<dd>
<a name="index-open-network"></a>

<p>Compute utilization, response time, average number of requests in the
system, and throughput for open queueing networks. If <var>lambda</var> is
a scalar, the network is considered a single-class QN and is solved
using <code>qnopensingle</code>. If <var>lambda</var> is a vector, the network
is considered as a multiclass QN and solved using <code>qnopenmulti</code>.
</p>
<br>
<p><strong>See also:</strong> qnos, qnom.
</p>
</dd></dl>



<hr>
<a name="Bounds-Analysis"></a>
<div class="header">
<p>
Next: <a href="#QN-Analysis-Examples" accesskey="n" rel="next">QN Analysis Examples</a>, Previous: <a href="#Generic-Algorithms" accesskey="p" rel="prev">Generic Algorithms</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Bounds-Analysis-1"></a>
<h3 class="section">5.5 Bounds Analysis</h3>

<a name="doc_002dqnosaba"></a>

<dl>
<dt><a name="index-qnosaba"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnosaba</strong> <em>(<var>lambda</var>, <var>D</var>)</em></dt>
<dt><a name="index-qnosaba-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnosaba</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qnosaba-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnosaba</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dd>
<a name="index-bounds_002c-asymptotic"></a>
<a name="index-open-network-1"></a>

<p>Compute Asymptotic Bounds for open, single-class networks with <em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var></code></dt>
<dd><p>Arrival rate of requests (scalar, <code><var>lambda</var> &ge; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand at center <em>k</em>.
(vector of length <em>K</em>, <code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em>.
(vector of length <em>K</em>, <code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>mean number of visits to center <em>k</em>.
(vector of length <em>K</em>, <code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>.
This function only supports <em>M/M/1</em> queues, therefore
<var>m</var> must be <code>ones(size(S))</code>. 
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bounds on the system throughput. <var>Xl</var> is
always set to <em>0</em> since there can be no lower bound on the
throughput of open networks (scalar).
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bounds on the system response time. <var>Ru</var>
is always set to <code>+inf</code> since there can be no upper bound on the
throughput of open networks (scalar).
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnomaba.
</p>
</dd></dl>


<a name="doc_002dqnomaba"></a>

<dl>
<dt><a name="index-qnomaba"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnomaba</strong> <em>(<var>lambda</var>, <var>D</var>)</em></dt>
<dt><a name="index-qnomaba-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Rl</var>] =</em> <strong>qnomaba</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>)</em></dt>
<dd>
<a name="index-bounds_002c-asymptotic-1"></a>
<a name="index-open-network-2"></a>
<a name="index-multiclass-network_002c-open-1"></a>

<p>Compute Asymptotic Bounds for open, multiclass networks with <em>K</em>
service centers and <em>C</em> customer classes.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var>(c)</code></dt>
<dd><p>class <em>c</em> arrival rate to the system (vector of length
<em>C</em>, <code><var>lambda</var>(c) &gt; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(c, k)</code></dt>
<dd><p>class <em>c</em> service demand at center <em>k</em> (<em>C \times K</em>
matrix, <code><var>D</var>(c, k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c, k)</code></dt>
<dd><p>mean service time of class <em>c</em> requests at center <em>k</em>
(<em>C \times K</em> matrix, <code><var>S</var>(c, k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(c, k)</code></dt>
<dd><p>mean number of visits of class <em>c</em> requests at center <em>k</em>
(<em>C \times K</em> matrix, <code><var>V</var>(c, k) &ge; 0</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var>(c)</code></dt>
<dt><code><var>Xu</var>(c)</code></dt>
<dd><p>lower and upper bounds of class <em>c</em> throughput.
<code><var>Xl</var>(c)</code> is always <em>0</em> since there can be no lower
bound on the throughput of open networks (vector of length
<em>C</em>).
</p>
</dd>
<dt><code><var>Rl</var>(c)</code></dt>
<dt><code><var>Ru</var>(c)</code></dt>
<dd><p>lower and upper bounds of class <em>c</em> response time.
<code><var>Ru</var>(c)</code> is always <code>+inf</code> since there can be no
upper bound on the response time of open networks (vector of length
<em>C</em>).
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnombsb.
</p>
</dd></dl>


<a name="doc_002dqncsaba"></a>

<dl>
<dt><a name="index-qncsaba"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsaba</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncsaba-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsaba-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncsaba-3"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-bounds_002c-asymptotic-2"></a>
<a name="index-asymptotic-bounds"></a>
<a name="index-closed-network_002c-single-class-6"></a>

<p>Compute Asymptotic Bounds for the system throughput and response
time of closed, single-class networks with <em>K</em> service
centers.
</p>
<p>Single-server and infinite-server nodes are supported.
Multiple-server nodes and general load-dependent servers are not
supported.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>number of requests in the system (scalar, <code><var>N</var>&gt;0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand at center <em>k</em>
(<code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em>
(<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to center
<em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>
(if <var>m</var> is a scalar, all centers have that number of servers). If
<code><var>m</var>(k) &lt; 1</code>, center <em>k</em> is a delay center (IS);
if <code><var>m</var>(k) = 1</code>, center <em>k</em> is a M/M/1-FCFS server.
This function does not support multiple-server nodes. Default
is 1.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay (scalar, <code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bounds on the system throughput.
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bounds on the system response time.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncmaba.
</p>
</dd></dl>


<a name="doc_002dqncmaba"></a>

<dl>
<dt><a name="index-qncmaba"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmaba</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncmaba-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncmaba-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncmaba-3"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmaba</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-bounds_002c-asymptotic-3"></a>
<a name="index-asymptotic-bounds-1"></a>
<a name="index-closed-network-1"></a>
<a name="index-multiclass-network_002c-closed-2"></a>
<a name="index-closed-multiclass-network"></a>

<p>Compute Asymptotic Bounds for closed, multiclass networks
with <em>K</em> service centers and <em>C</em> customer classes.
Single-server and infinite-server nodes are supported.
Multiple-server nodes and general load-dependent servers are not
supported.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests in the system
(vector of length <em>C</em>, <code><var>N</var>(c) &ge; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(c, k)</code></dt>
<dd><p>class <em>c</em> service demand
at center <em>k</em> (<em>C \times K</em> matrix, <code><var>D</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c, k)</code></dt>
<dd><p>mean service time of class <em>c</em>
requests at center <em>k</em> (<em>C \times K</em> matrix, <code><var>S</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em>
requests to center <em>k</em> (<em>C \times K</em> matrix, <code><var>V</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>
(if <var>m</var> is a scalar, all centers have that number of servers). If
<code><var>m</var>(k) &lt; 1</code>, center <em>k</em> is a delay center (IS);
if <code><var>m</var>(k) = 1</code>, center <em>k</em> is a M/M/1-FCFS server.
This function does not support multiple-server nodes. Default
is 1.
</p>
</dd>
<dt><code><var>Z</var>(c)</code></dt>
<dd><p>class <em>c</em> external delay
(vector of length <em>C</em>, <code><var>Z</var>(c) &ge; 0</code>). Default is 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var>(c)</code></dt>
<dt><code><var>Xu</var>(c)</code></dt>
<dd><p>Lower and upper bounds for class <em>c</em> throughput.
</p>
</dd>
<dt><code><var>Rl</var>(c)</code></dt>
<dt><code><var>Ru</var>(c)</code></dt>
<dd><p>Lower and upper bounds for class <em>c</em> response time.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsaba.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<p>Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.2 (&quot;Asymptotic Bounds&quot;).
</p>
<a name="index-Lazowska_002c-E_002e-D_002e-5"></a>
<a name="index-Zahorjan_002c-J_002e-6"></a>
<a name="index-Graham_002c-G_002e-S_002e-5"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-5"></a>

<a name="doc_002dqnosbsb"></a>

<dl>
<dt><a name="index-qnosbsb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnosbsb</strong> <em>(<var>lambda</var>, <var>D</var>)</em></dt>
<dt><a name="index-qnosbsb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qnosbsb</strong> <em>(<var>lambda</var>, <var>S</var>, <var>V</var>)</em></dt>
<dd>
<a name="index-bounds_002c-balanced-system"></a>
<a name="index-open-network-3"></a>

<p>Compute Balanced System Bounds for single-class, open networks with
<em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>lambda</var></code></dt>
<dd><p>overall arrival rate to the system (scalar, <code><var>lambda</var> &ge; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand at center <em>k</em> (<code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>service time at center <em>k</em> (<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>mean number of visits at center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. This function only supports
<em>M/M/1</em> queues, therefore <var>m</var> must be
<code>ones(size(S))</code>.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bounds on the system throughput. <var>Xl</var> is always
set to <em>0</em>, since there can be no lower bound on open
networks throughput.
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bounds on the system response time.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qnosaba.
</p>
</dd></dl>


<a name="doc_002dqncsbsb"></a>

<dl>
<dt><a name="index-qncsbsb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsbsb</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncsbsb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsbsb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsbsb-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsbsb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncsbsb-3"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncsbsb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-bounds_002c-balanced-system-1"></a>
<a name="index-closed-network_002c-single-class-7"></a>
<a name="index-balanced-system-bounds"></a>

<p>Compute Balanced System Bounds on system throughput and response time for closed, single-class networks with <em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>number of requests in the system (scalar, <code><var>N</var> &ge; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand at center <em>k</em> (<code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em> (<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>average number of visits to center <em>k</em> (<code><var>V</var>(k)
&ge; 0</code>). Default is 1.
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. This function supports
<code><var>m</var>(k) = 1</code> only (single-eserver FCFS nodes); this
parameter is only for compatibility with <code>qncsaba</code>. Default is
1.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>External delay (<code><var>Z</var> &ge; 0</code>). Default is 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bound on the system throughput.
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bound on the system response time.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncmbsb.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.4 (&quot;Balanced Systems Bounds&quot;).

<a name="index-Lazowska_002c-E_002e-D_002e-6"></a>
<a name="index-Zahorjan_002c-J_002e-7"></a>
<a name="index-Graham_002c-G_002e-S_002e-6"></a>
<a name="index-Sevcik_002c-K_002e-C_002e-6"></a>

</li></ul>

<a name="doc_002dqncmbsb"></a>

<dl>
<dt><a name="index-qncmbsb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmbsb</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncmbsb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmbsb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dd>
<a name="index-bounds_002c-balanced-system-2"></a>
<a name="index-balanced-system-bounds-1"></a>
<a name="index-multiclass-network_002c-closed-3"></a>
<a name="index-closed-multiclass-network-1"></a>

<p>Compute Balanced System Bounds for closed, multiclass networks
with <em>K</em> service centers and <em>C</em> customer classes.
Only single-server nodes are supported.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests in the system (vector of length
<em>C</em>).
</p>
</dd>
<dt><code><var>D</var>(c, k)</code></dt>
<dd><p>class <em>c</em> service demand  at center <em>k</em> (<em>C \times K</em>
matrix, <code><var>D</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c, k)</code></dt>
<dd><p>mean service time of class <em>c</em>
requests at center <em>k</em> (<em>C \times K</em> matrix, <code><var>S</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em>
requests to center <em>k</em> (<em>C \times K</em> matrix, <code><var>V</var>(c,k) &ge; 0</code>). 
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var>(c)</code></dt>
<dt><code><var>Xu</var>(c)</code></dt>
<dd><p>Lower and upper class <em>c</em> throughput bounds (vector of length <em>C</em>).
</p>
</dd>
<dt><code><var>Rl</var>(c)</code></dt>
<dt><code><var>Ru</var>(c)</code></dt>
<dd><p>Lower and upper class <em>c</em> response time bounds (vector of length <em>C</em>).
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsbsb.
</p>
</dd></dl>


<a name="doc_002dqncmcb"></a>

<dl>
<dt><a name="index-qncmcb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmcb</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncmcb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncmcb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dd>
<a name="index-multiclass-network_002c-closed-4"></a>
<a name="index-closed-multiclass-network-2"></a>
<a name="index-bounds_002c-composite"></a>
<a name="index-composite-bounds"></a>

<p>Composite Bound (CB) on throughput and response time for closed multiclass networks.
</p>
<p>This function implements the Composite Bound Method described in T.
Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>, Technical Report
CSD-TR-475, Purdue University, march 13, 1984 (revised august 27,
1984).
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var>(c)</code></dt>
<dd><p>number of class <em>c</em> requests in the system.
</p>
</dd>
<dt><code><var>D</var>(c, k)</code></dt>
<dd><p>class <em>c</em> service demand
at center <em>k</em> (<code><var>S</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(c, k)</code></dt>
<dd><p>mean service time of class <em>c</em>
requests at center <em>k</em> (<code><var>S</var>(c,k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(c,k)</code></dt>
<dd><p>average number of visits of class <em>c</em>
requests to center <em>k</em> (<code><var>V</var>(c,k) &ge; 0</code>).
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var>(c)</code></dt>
<dt><code><var>Xu</var>(c)</code></dt>
<dd><p>Lower and upper class <em>c</em> throughput bounds.
</p>
</dd>
<dt><code><var>Rl</var>(c)</code></dt>
<dt><code><var>Ru</var>(c)</code></dt>
<dd><p>Lower and upper class <em>c</em> response time bounds.
</p>
</dd>
</dl>

</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> Teemu Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>, Performance
Evaluation Vol. 6, Issue 1, March 1986, DOI
<a href="http://dx.doi.org/10.1016/0166-5316(86)90002-7">10.1016/0166-5316(86)90002-7</a>. Also available as
<a href="http://docs.lib.purdue.edu/cstech/395/">Technical Report
CSD-TR-475</a>, Department of Computer Sciences, Purdue University, mar
13, 1984 (Revised Aug 27, 1984).

<a name="index-Kerola_002c-T_002e"></a>

</li></ul>

<a name="doc_002dqncspb"></a>

<dl>
<dt><a name="index-qncspb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncspb</strong> <em>(<var>N</var>, <var>D</var> )</em></dt>
<dt><a name="index-qncspb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncspb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var> )</em></dt>
<dt><a name="index-qncspb-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncspb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var> )</em></dt>
<dt><a name="index-qncspb-3"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] =</em> <strong>qncspb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var> )</em></dt>
<dd>
<a name="index-bounds_002c-PB"></a>
<a name="index-PB-bounds"></a>
<a name="index-closed-network_002c-single-class-8"></a>

<p>Compute PB Bounds (C. H. Hsieh and S. Lam, 1987) for single-class,
closed networks with <em>K</em> service centers.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var></var></code></dt>
<dd><p>number of requests in the system (scalar, <code><var>N</var> &gt; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand of service center <em>k</em> (<code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em> (<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>visit ratio to center <em>k</em> (<code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. This function only supports
<em>M/M/1</em> queues, therefore <var>m</var> must be
<code>ones(size(S))</code>.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>external delay (think time, <code><var>Z</var> &ge; 0</code>). Default 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bounds on the system throughput.
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bounds on the system response time.
</p>
</dd>
</dl>

<br>
<p><strong>See also:</strong> qncsaba, qbcsbsb, qncsgb.
</p>
</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> C. H. Hsieh and S. Lam, <cite>Two classes of performance bounds for
closed queueing networks</cite>, Performance Evaluation, Vol. 7 Issue 1,
pp. 3&ndash;30, February 1987, DOI
<a href="http://dx.doi.org/10.1016/0166-5316(87)90054-X">10.1016/0166-5316(87)90054-X</a>. Also available as
<a href="ftp://ftp.cs.utexas.edu/pub/techreports/tr85-09.pdf">Technical
Report TR-85-09</a>, Department of Computer Science, University of Texas
at Austin, June 1985

<a name="index-Hsieh_002c-C_002e-H_002e"></a>
<a name="index-Lam_002c-S_002e"></a>

</li></ul>

<p>This function implements the non-iterative variant described in G.
Casale, R. R. Muntz, G. Serazzi, <cite>Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks</cite>, IEEE
Transactions on Computers, 57(6):780-794, June 2008.
</p>
<a name="index-Casale_002c-G_002e-1"></a>
<a name="index-Muntz_002c-R_002e-R_002e"></a>
<a name="index-Serazzi_002c-G_002e"></a>

<a name="doc_002dqncsgb"></a>

<dl>
<dt><a name="index-qncsgb"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] =</em> <strong>qncsgb</strong> <em>(<var>N</var>, <var>D</var>)</em></dt>
<dt><a name="index-qncsgb-1"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] =</em> <strong>qncsgb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>)</em></dt>
<dt><a name="index-qncsgb-2"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] =</em> <strong>qncsgb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>)</em></dt>
<dt><a name="index-qncsgb-3"></a>Function File: <em>[<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] =</em> <strong>qncsgb</strong> <em>(<var>N</var>, <var>S</var>, <var>V</var>, <var>m</var>, <var>Z</var>)</em></dt>
<dd>
<a name="index-bounds_002c-geometric"></a>
<a name="index-geometric-bounds"></a>
<a name="index-closed-network-2"></a>

<p>Compute Geometric Bounds (GB) on system throughput, system response
time and server queue lenghts for closed, single-class networks
with <em>K</em> service centers and <em>N</em> requests.
</p>
<p><strong>INPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>N</var></code></dt>
<dd><p>number of requests in the system (scalar, <code><var>N</var> &gt; 0</code>).
</p>
</dd>
<dt><code><var>D</var>(k)</code></dt>
<dd><p>service demand of service center <em>k</em> (vector of length
<em>K</em>, <code><var>D</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>S</var>(k)</code></dt>
<dd><p>mean service time at center <em>k</em> (vector of length <em>K</em>,
<code><var>S</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>V</var>(k)</code></dt>
<dd><p>visit ratio to center <em>k</em>
(vector of length <em>K</em>, <code><var>V</var>(k) &ge; 0</code>).
</p>
</dd>
<dt><code><var>m</var>(k)</code></dt>
<dd><p>number of servers at center <em>k</em>. This function only supports
<em>M/M/1</em> queues, therefore <var>m</var> must be
<code>ones(size(S))</code>.
</p>
</dd>
<dt><code><var>Z</var></code></dt>
<dd><p>external delay (think time, <code><var>Z</var> &ge; 0</code>, scalar). Default is 0.
</p>
</dd>
</dl>

<p><strong>OUTPUTS</strong>
</p>
<dl compact="compact">
<dt><code><var>Xl</var></code></dt>
<dt><code><var>Xu</var></code></dt>
<dd><p>Lower and upper bound on the system throughput. If <code><var>Z</var>&gt;0</code>,
these bounds are computed using <em>Geometric Square-root Bounds</em>
(GSB). If <code><var>Z</var>==0</code>, these bounds are computed using <em>Geometric Bounds</em> (GB)
</p>
</dd>
<dt><code><var>Rl</var></code></dt>
<dt><code><var>Ru</var></code></dt>
<dd><p>Lower and upper bound on the system response time. These bounds
are derived from <var>Xl</var> and <var>Xu</var> using Little&rsquo;s Law:
<code><var>Rl</var> = <var>N</var> / <var>Xu</var> - <var>Z</var></code>, 
<code><var>Ru</var> = <var>N</var> / <var>Xl</var> - <var>Z</var></code>
</p>
</dd>
<dt><code><var>Ql</var>(k)</code></dt>
<dt><code><var>Qu</var>(k)</code></dt>
<dd><p>lower and upper bounds of center <em>K</em> queue length.
</p>
</dd>
</dl>

</dd></dl>


<p><strong>REFERENCES</strong>
</p>
<ul>
<li> G. Casale, R. R. Muntz, G. Serazzi, <cite>Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks</cite>, IEEE
Transactions on Computers, 57(6):780-794, June
2008. <a href="http://doi.ieeecomputersociety.org/10.1109/TC.2008.37">10.1109/TC.2008.37</a>

<a name="index-Casale_002c-G_002e-2"></a>
<a name="index-Muntz_002c-R_002e-R_002e-1"></a>
<a name="index-Serazzi_002c-G_002e-1"></a>

</li></ul>

<p>In this implementation we set <em>X^+</em> and <em>X^-</em> as the upper
and lower Asymptotic Bounds as computed by the <code>qncsab</code>
function, respectively.
</p>


<hr>
<a name="QN-Analysis-Examples"></a>
<div class="header">
<p>
Previous: <a href="#Bounds-Analysis" accesskey="p" rel="prev">Bounds Analysis</a>, Up: <a href="#Queueing-Networks" accesskey="u" rel="up">Queueing Networks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="QN-Analysis-Examples-1"></a>
<h3 class="section">5.6 QN Analysis Examples</h3>

<p>In this section we illustrate with a few examples how the
<code>queueing</code> package can be used to analyze queueing network
models. Further examples can be found in the functions demo blocks,
and can be inspected with the <code>demo <em>function</em></code> Octave
command.
</p>
<a name="Closed_002c-Single-Class-Network"></a>
<h4 class="subsection">5.6.1 Closed, Single Class Network</h4>

<p>Let us consider again the network shown in
<a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a>. We denote with <em>S_k</em> the average
service time at center <em>k</em>, <em>k=1, 2, 3</em>. Let the service
times be <em>S_1 = 1.0</em>, <em>S_2 = 2.0</em> and <em>S_3 = 0.8</em>. The
routing of jobs within the network is described with a <em>routing
probability matrix</em> <em>\bf P</em>: a request completing service at
center <em>i</em> is enqueued at center <em>j</em> with probability
<em>P_{i, j}</em>.  We use the following routing matrix:
</p>
<div class="example">
<pre class="example">    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
</pre></div>

<p>The network above can be analyzed with the <code>qnclosed</code> function
see <a href="#doc_002dqnclosed">doc-qnclosed</a>. <code>qnclosed</code> requires the following
parameters:
</p>
<dl compact="compact">
<dt><var>N</var></dt>
<dd><p>Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)
</p>
</dd>
<dt><var>S</var></dt>
<dd><p>Array of average service times at the centers: <code><var>S</var>(k)</code> is
the average service time at center <em>k</em>.
</p>
</dd>
<dt><var>V</var></dt>
<dd><p>Array of visit ratios: <code><var>V</var>(k)</code> is the average number of
visits to center <em>k</em>.
</p>
</dd>
</dl>

<p>We can compute <em>V_k</em> from the routing probability matrix
<em>P_{i, j}</em> using the <code>qncsvisits</code> function
see <a href="#doc_002dqncsvisits">doc-qncsvisits</a>.  Therefore, we can analyze the network for a
given population size <em>N</em> (e.g., <em>N=10</em>) as follows:
</p>
<div class="example">
<pre class="example"><kbd>N = 10;</kbd>
<kbd>S = [1 2 0.8];</kbd>
<kbd>P = [0 0.3 0.7; 1 0 0; 1 0 0];</kbd>
<kbd>V = qncsvisits(P);</kbd>
<kbd>[U R Q X] = qnclosed( N, S, V )</kbd>
   &rArr; U = 0.99139 0.59483 0.55518
   &rArr; R = 7.4360  4.7531  1.7500
   &rArr; Q = 7.3719  1.4136  1.2144
   &rArr; X = 0.99139 0.29742 0.69397
</pre></div>

<p>The output of <code>qnclosed</code> includes the vectors of utilizations
<em>U_k</em> at center <em>k</em>, response time <em>R_k</em>, average
number of customers <em>Q_k</em> and throughput <em>X_k</em>. In our
example, the throughput of center 1 is <em>X_1 = 0.99139</em>, and the
average number of requests in center 3 is <em>Q_3 = 1.2144</em>. The
utilization of center 1 is <em>U_1 = 0.99139</em>, which is the highest
among the service centers. Thus, center 1 is the <em>bottleneck
device</em>.
</p>
<p>This network can also be analyzed with the <code>qnsolve</code> function
see <a href="#doc_002dqnsolve">doc-qnsolve</a>. <code>qnsolve</code> can handle open, closed or
mixed networks, and allows the network to be described in a very
flexible way.  First, let <var>Q1</var>, <var>Q2</var> and <var>Q3</var> be the
variables describing the service centers. Each variable is
instantiated with the <code>qnmknode</code> function.
</p>
<div class="example">
<pre class="example"><kbd>Q1 = qnmknode( &quot;m/m/m-fcfs&quot;, 1 );</kbd>
<kbd>Q2 = qnmknode( &quot;m/m/m-fcfs&quot;, 2 );</kbd>
<kbd>Q3 = qnmknode( &quot;m/m/m-fcfs&quot;, 0.8 );</kbd>
</pre></div>

<p>The first parameter of <code>qnmknode</code> is a string describing the
type of the node; <code>&quot;m/m/m-fcfs&quot;</code> denotes a <em>M/M/m</em>&ndash;FCFS
center (this parameter is case-insensitive). The second parameter
gives the average service time. An optional third parameter can be
used to specify the number <em>m</em> of service centers. If omitted, it
is assumed <em>m=1</em> (single-server node).
</p>
<p>Now, the network can be analyzed as follows:
</p>
<div class="example">
<pre class="example"><kbd>N = 10;</kbd>
<kbd>V = [1 0.3 0.7];</kbd>
<kbd>[U R Q X] = qnsolve( &quot;closed&quot;, N, { Q1, Q2, Q3 }, V )</kbd>
   &rArr; U = 0.99139 0.59483 0.55518
   &rArr; R = 7.4360  4.7531  1.7500
   &rArr; Q = 7.3719  1.4136  1.2144
   &rArr; X = 0.99139 0.29742 0.69397
</pre></div>

<a name="Open_002c-Single-Class-Network"></a>
<h4 class="subsection">5.6.2 Open, Single Class Network</h4>

<p>Let us consider an open network with <em>K=3</em> service centers and
the following routing probabilities:
</p>
<div class="example">
<pre class="example">    / 0  0.3  0.5 \
P = ! 1  0    0   |
    \ 1  0    0   /
</pre></div>

<p>In this network, requests can leave the system from center 1 with
probability <em>1-(0.3+0.5) = 0.2</em>. We suppose that external jobs
arrive at center 1 with rate <em>\lambda_1 = 0.15</em>; there are no
arrivals at centers 2 and 3.
</p>
<p>Similarly to closed networks, we first compute the visit counts
<em>V_k</em> to center <em>k</em>, <em>k = 1, 2, 3</em>. We use the
<code>qnosvisits</code> function as follows:
</p>
<div class="example">
<pre class="example"><kbd>P = [0 0.3 0.5; 1 0 0; 1 0 0];</kbd>
<kbd>lambda = [0.15 0 0];</kbd>
<kbd>V = qnosvisits(P, lambda)</kbd>
   &rArr; V = 5.00000 1.50000 2.50000
</pre></div>

<p>where <code><var>lambda</var>(k)</code> is the arrival rate at center <em>k</em>,
and <var>P</var> is the routing matrix. Assuming the same service times as
in the previous example, the network can be analyzed with the
<code>qnopen</code> function see <a href="#doc_002dqnopen">doc-qnopen</a>, as follows:
</p>
<div class="example">
<pre class="example"><kbd>S = [1 2 0.8];</kbd>
<kbd>[U R Q X] = qnopen( sum(lambda), S, V )</kbd>
   &rArr; U = 0.75000 0.45000 0.30000
   &rArr; R = 4.0000  3.6364  1.1429
   &rArr; Q = 3.00000 0.81818 0.42857
   &rArr; X = 0.75000 0.22500 0.37500
</pre></div>

<p>The first parameter of the <code>qnopen</code> function is the (scalar)
aggregate arrival rate.
</p>
<p>Again, it is possible to use the <code>qnsolve</code> high-level function:
</p>
<div class="example">
<pre class="example"><kbd>Q1 = qnmknode( &quot;m/m/m-fcfs&quot;, 1 );</kbd>
<kbd>Q2 = qnmknode( &quot;m/m/m-fcfs&quot;, 2 );</kbd>
<kbd>Q3 = qnmknode( &quot;m/m/m-fcfs&quot;, 0.8 );</kbd>
<kbd>lambda = [0.15 0 0];</kbd>
<kbd>[U R Q X] = qnsolve( &quot;open&quot;, sum(lambda), { Q1, Q2, Q3 }, V )</kbd>
   &rArr; U = 0.75000 0.45000 0.30000
   &rArr; R = 4.0000  3.6364  1.1429
   &rArr; Q = 3.00000 0.81818 0.42857
   &rArr; X = 0.75000 0.22500 0.37500
</pre></div>

<a name="Closed-Multiclass-Network_002f1"></a>
<h4 class="subsection">5.6.3 Closed Multiclass Network/1</h4>

<p>The following example is taken from Herb Schwetman, <cite>Implementing
the Mean Value Algorithm for the Solution of Queueing Network Models</cite>,
Technical Report CSD-TR-355, Department of Computer Sciences, Purdue
University, Feb 15, 1982.
</p>
<p>Let us consider the following multiclass QN with three servers and two classes
</p>
<div class="float"><a name="fig_003aapl"></a>
<div align="center"><img src="qn_closed_multi_apl.png" alt="qn_closed_multi_apl">
</div><div class="float-caption"><p><strong>Figure 5.3
</strong></p></div></div>
<p>Servers 1 and 2 (labeled <em>APL</em> and <em>IMS</em>, respectively) are
infinite server nodes; server 3 (labeled <em>SYS</em>) is Processor
Sharing (PS). Mean service times are given in the following table:
</p>
<table>
<thead><tr><th width="15%"></th><th width="15%">APL</th><th width="15%">IMS</th><th width="15%">SYS</th></tr></thead>
<tr><td width="15%">Class 1</td><td width="15%">1</td><td width="15%">-</td><td width="15%">0.025</td></tr>
<tr><td width="15%">Class 2</td><td width="15%">-</td><td width="15%">15</td><td width="15%">0.500</td></tr>
</table>

<p>There is no class switching. If  we assume a population of 15 requests
for  class 1,  and  5 requests  for class  2,  then the  model can  be
analyzed as follows:
</p>
<div class="example">
<pre class="verbatim"> S = [1 0 .025; 0 15 .5];
 P = zeros(2,3,2,3);
 P(1,1,1,3) = P(1,3,1,1) = 1;
 P(2,2,2,3) = P(2,3,2,2) = 1;
 V = qncmvisits(P,[3 3]); # reference station is station 3
 N = [15 5];
 m = [-1 -1 1];
 [U R Q X] = qncmmva(N,S,V,m)
</pre><pre class="example">  &rArr;
U =

   14.32312    0.00000    0.35808
    0.00000    4.70699    0.15690

R =

    1.00000    0.00000    0.04726
    0.00000   15.00000    0.93374

Q =

   14.32312    0.00000    0.67688
    0.00000    4.70699    0.29301

X =

   14.32312    0.00000   14.32312
    0.00000    0.31380    0.31380
</pre></div>

<a name="Closed-Multiclass-Network_002f2"></a>
<h4 class="subsection">5.6.4 Closed Multiclass Network/2</h4>

<p>The following example is from M. Marzolla, <cite>The qnetworks
Toolbox: A Software Package for Queueing Networks Analysis</cite>, Technical
Report
<a href="http://www.informatica.unibo.it/it/ricerca/technical-report/2010/UBLCS-2010-04">UBLCS-2010-04</a>, Department of Computer Science, University of Bologna,
Italy, February 2010.
</p>
<div class="float"><a name="fig_003aweb_005fmodel"></a>
<div align="center"><img src="qn_web_model.png" alt="qn_web_model">
</div>
<div class="float-caption"><p><strong>Figure 5.4: </strong>Three-tier enterprise system model</p></div></div>
<p>The model shown in <a href="#fig_003aweb_005fmodel">Figure 5.4</a> shows a three-tier enterprise
system with <em>K=6</em> service centers. The first tier contains the
<em>Web server</em> (node 1), which is responsible for generating Web
pages and transmitting them to clients. The application logic is
implemented by nodes 2 and 3, and the storage tier is made of nodes
4&ndash;6.The system is subject to two workload classes, both represented
as closed populations of <em>N_1</em> and <em>N_2</em> requests,
respectively. Let <em>D_{c, k}</em> denote the service demand of class
<em>c</em> requests at center <em>k</em>. We use the parameter values:
</p>
<table>
<thead><tr><th width="20%">Serv. no.</th><th width="33%">Name</th><th width="10%">Class 1</th><th width="10%">Class 2</th></tr></thead>
<tr><td width="20%">1</td><td width="33%">Web Server</td><td width="10%">12</td><td width="10%">2</td></tr>
<tr><td width="20%">2</td><td width="33%">App. Server 1</td><td width="10%">14</td><td width="10%">20</td></tr>
<tr><td width="20%">3</td><td width="33%">App. Server 2</td><td width="10%">23</td><td width="10%">14</td></tr>
<tr><td width="20%">4</td><td width="33%">DB Server 1</td><td width="10%">20</td><td width="10%">90</td></tr>
<tr><td width="20%">5</td><td width="33%">DB Server 2</td><td width="10%">80</td><td width="10%">30</td></tr>
<tr><td width="20%">6</td><td width="33%">DB Server 3</td><td width="10%">31</td><td width="10%">33</td></tr>
</table>

<p>We set the total number of requests to 100, that is <em>N_1 + N_2 =
N = 100</em>, and we study how different population mixes <em>(N_1,
N_2)</em> affect the system throughput and response time. Let
<em>0 &lt; \beta_1 &lt; 1</em> denote the fraction of class 1 requests:
<em>N_1 = \beta_1 N</em>, <em>N_2 = (1-\beta_1)N</em>. The following
Octave code defines the model for <em>\beta_1 = 0.1</em>:
</p>
<div class="example">
<pre class="example">N = 100;     # total population size
beta1 = 0.1; # fraction of class 1 reqs.
S = [12 14 23 20 80 31; \
      2 20 14 90 30 33 ];
V = ones(size(S));
pop = [fix(beta1*N) N-fix(beta1*N)];
[U R Q X] = qncmmva(pop, S, V);
</pre></div>

<p>The <code>qncmmva(pop, S, V)</code> function invocation uses the
multiclass MVA algorithm to compute per-class utilizations <em>U_{c,
k}</em>, response times <em>R_{c,k}</em>, mean queue lengths <em>Q_{c,k}</em>
and throughputs <em>X_{c,k}</em> at each service center <em>k</em>, given
a population vector <var>pop</var>, mean service times <var>S</var> and visit
ratios <var>V</var>. Since we are given the service demands <em>D_{c, k}
= S_{c, k} V_{c,k}</em>, but function <code>qncmmva</code> requires separate
service times and visit ratios, we set the service times equal to the
demands, and all visit ratios equal to one. Overall class and system
throughputs and response times can also be computed:
</p>
<div class="example">
<pre class="example">X1 = X(1,1) / V(1,1)     # class 1 throughput
        &rArr; X1 =  0.0044219
X2 = X(2,1) / V(2,1)     # class 2 throughput
        &rArr; X2 =  0.010128
XX = X1 + X2             # system throughput
        &rArr; XX =  0.014550
R1 = dot(R(1,:), V(1,:)) # class 1 resp. time
        &rArr; R1 =  2261.5
R2 = dot(R(2,:), V(2,:)) # class 2 resp. time
        &rArr; R2 =  8885.9
RR = N / XX              # system resp. time
        &rArr; RR =  6872.7
</pre></div>

<p><code>dot(X,Y)</code> computes the dot product of two vectors.
<code>R(1,:)</code> is the first row of matrix <var>R</var> and <code>V(1,:)</code> is
the first row of matrix <var>V</var>, so <code>dot(R(1,:), V(1,:))</code>
computes <em>\sum_k R_{1,k} V_{1,k}</em>.
</p>
<div class="float"><a name="fig_003aweb"></a>
<div align="center"><img src="web.png" alt="web">
</div>
<div class="float-caption"><p><strong>Figure 5.5: </strong>Throughput and Response Times as a function of the population mix</p></div></div>
<p>We can also compute the system power <em>\Phi = X / R</em>, which
defines how efficiently resources are being used: high values of
<em>\Phi</em> denote the desirable situation of high throughput and low
response time. <a href="#fig_003apower">Figure 5.6</a> shows <em>\Phi</em> as a function of
<em>\beta_1</em>. We observe a &ldquo;plateau&rdquo; of the global system power,
corresponding to values of <em>\beta_1</em> which approximately lie
between <em>0.3</em> and <em>0.7</em>. The per-class power exhibits an
interesting (although not completely surprising) pattern, where the
class with higher population exhibits worst efficiency as it produces
higher contention on the resources.
</p>
<div class="float"><a name="fig_003apower"></a>
<div align="center"><img src="power.png" alt="power">
</div>
<div class="float-caption"><p><strong>Figure 5.6: </strong>System Power as a function of the population mix</p></div></div>
<a name="Closed-Multiclass-Network_002f3"></a>
<h4 class="subsection">5.6.5 Closed Multiclass Network/3</h4>

<p>We now consider an example of multiclass network with class switching.
The example is taken from <a href="#Sch82">Sch82</a>, and is shown in Figure
<a href="#fig_003aclass_005fswitching">Figure 5.7</a>.
</p>
<div class="float"><a name="fig_003aclass_005fswitching"></a>
<div align="center"><img src="qn_closed_multi_cs.png" alt="qn_closed_multi_cs">
</div>
<div class="float-caption"><p><strong>Figure 5.7: </strong>Multiclass Model with Class Switching</p></div></div>
<p>The system consists of three devices and two job classes. The CPU node
is a PS server, while the two nodes labeled I/O are FCFS. Class 1 mean
service time at the CPU is <em>0.01</em>; class 2 mean service time at
the CPU is <em>0.05</em>. The mean service time at node 2 is <em>0.1</em>,
and is class-independent. Similarly, the mean service time at node 3
is <em>0.07</em>. Jobs in class 1 leave the CPU and join class 2 with
probability <em>0.1</em>; jobs of class 2 leave the CPU and join class 1
with probability <em>0.2</em>. There are <em>N=3</em> jobs, which are
initially allocated to class 1. However, note that since class
switching is allowed, the total number of jobs in each class does not
remain constant; however the total number of jobs does.
</p>
<div class="example">
<pre class="verbatim"> C = 2; K = 3;
 S = [.01 .07 .10; ...
      .05 .07 .10 ];
 P = zeros(C,K,C,K);
 P(1,1,1,2) = .7; P(1,1,1,3) = .2; P(1,1,2,1) = .1;
 P(2,1,2,2) = .3; P(2,1,2,3) = .5; P(2,1,1,1) = .2;
 P(1,2,1,1) = P(2,2,2,1) = 1;
 P(1,3,1,1) = P(2,3,2,1) = 1;
 N = [3 0];
 [U R Q X] = qncmmva(N, S, P)
</pre><pre class="example">  &rArr;
U =

   0.12609   0.61784   0.25218
   0.31522   0.13239   0.31522

R =

   0.014653   0.133148   0.163256
   0.073266   0.133148   0.163256

Q =

   0.18476   1.17519   0.41170
   0.46190   0.25183   0.51462

X =

   12.6089    8.8262    2.5218
    6.3044    1.8913    3.1522
</pre></div>



<hr>
<a name="References"></a>
<div class="header">
<p>
Next: <a href="#Copying" accesskey="n" rel="next">Copying</a>, Previous: <a href="#Queueing-Networks" accesskey="p" rel="prev">Queueing Networks</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="References-1"></a>
<h2 class="chapter">6 References</h2>

<dl compact="compact">
<dt>[Aky88]</dt>
<dd><p>Ian F. Akyildiz, <cite>Mean Value Analysis for Blocking Queueing
Networks</cite>, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418&ndash;428.  DOI <a href="http://dx.doi.org/10.1109/32.4663">10.1109/32.4663</a>
</p>
</dd>
<dt>[Bar79]</dt>
<dd><p>Y. Bard, <cite>Some Extensions to Multiclass Queueing Network Analysis</cite>,
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51&ndash;62.
</p>
</dd>
<dt>[BCMP75]</dt>
<dd><p>F. Baskett, K. Mani Chandy, R. R. Muntz, and F. G. Palacios. 1975. <cite>Open, Closed, and Mixed Networks of Queues with Different Classes of Customers</cite>. J. ACM 22, 2 (April 1975), 248260, DOI <a href="http://doi.acm.org/10.1145/321879.321887">10.1145/321879.321887</a>
</p>
</dd>
<dt>[BGMT98]</dt>
<dd><p>G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998.
</p>
</dd>
<dt>[Buz73]</dt>
<dd><p>J. P. Buzen, <cite>Computational Algorithms for Closed Queueing
Networks with Exponential Servers</cite>, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527&ndash;531. DOI <a href="http://doi.acm.org/10.1145/362342.362345">10.1145/362342.362345</a>
</p>
</dd>
<dt>[C08]</dt>
<dd><p>G. Casale, <cite>A note on stable flow-equivalent aggregation in
closed networks</cite>. Queueing Syst. Theory Appl., 60:193-202, December
2008, DOI <a href="http://dx.doi.org/10.1007/s11134-008-9093-6">10.1007/s11134-008-9093-6</a>
</p>
</dd>
<dt>[CMS08]</dt>
<dd><p>G. Casale, R. R. Muntz, G. Serazzi,
<cite>Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks</cite>, IEEE Transactions on Computers, 57(6):780-794,
June 2008. DOI <a href="http://doi.ieeecomputersociety.org/10.1109/TC.2008.37">10.1109/TC.2008.37</a>
</p>
</dd>
<dt><a name="GrSn97"></a>[GrSn97]</dt>
<dd><p>C. M. Grinstead, J. L. Snell, (July 1997). <cite>Introduction
to Probability</cite>. American Mathematical Society. ISBN 978-0821807491;
this excellent textbook is <a href="http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/amsbook.mac.pdf">available in PDF format</a>
and can be used under the terms of the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License (FDL)</a>
</p>
</dd>
<dt>[Jac04]</dt>
<dd><p>J. R. Jackson, <cite>Jobshop-Like Queueing Systems</cite>, Vol. 50, No. 12, Ten Most Influential Titles of &quot;Management Science&rsquo;s&quot; First Fifty Years (Dec., 2004), pp. 1796-1802, <a href="http://www.jstor.org/stable/30046149">available online</a>
</p>
</dd>
<dt>[Jai91]</dt>
<dd><p>R. Jain, <cite>The Art of Computer Systems Performance Analysis</cite>,
Wiley, 1991, p. 577.
</p>
</dd>
<dt>[HsLa87]</dt>
<dd><p>C. H. Hsieh and S. Lam,
<cite>Two classes of performance bounds for closed queueing networks</cite>,
PEVA, vol. 7, n. 1, pp. 3&ndash;30, 1987
</p>
</dd>
<dt>[Ker84]</dt>
<dd><p>T. Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>,
Performance Evaluation, Vol. 6 Isue 1, March 1986, DOI
<a href="http://dx.doi.org/10.1016/0166-5316(86)90002-7">10.1016/0166-5316(86)90002-7</a>; also available as 
<a href="http://docs.lib.purdue.edu/cstech/395/">Technical Report CSD-TR-475</a>, Department of Computer Sciences, Purdue
University, mar 13, 1984 (Revised aug 27, 1984).
</p>
</dd>
<dt>[LZGS84]</dt>
<dd><p>E. D. Lazowska, J. Zahorjan, G. Scott Graham, and K. C.
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">available online</a>.
</p>
</dd>
<dt>[ReKo76]</dt>
<dd><p>M. Reiser, H. Kobayashi, <cite>On The Convolution Algorithm for
Separable Queueing Networks</cite>, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29&ndash;31,
1976). SIGMETRICS &rsquo;76. ACM, New York, NY,
pp. 109&ndash;117. DOI <a href="http://doi.acm.org/10.1145/800200.806187">10.1145/800200.806187</a>
</p>
</dd>
<dt>[ReLa80]</dt>
<dd><p>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. DOI
<a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>
</p>
</dd>
<dt>[Sch79]</dt>
<dd><p>P. Schweitzer, <cite>Approximate Analysis of Multiclass Closed Networks of
Queues</cite>, Proc. Int. Conf. on Stochastic Control and Optimization, jun
1979, pp. 2529
</p>
</dd>
<dt>[Sch80]</dt>
<dd><p>H. D. Schwetman, <cite>Testing Network-of-Queues Software</cite>,
<a href="http://docs.lib.purdue.edu/cstech/259/">Technical Report CSD-TR
330</a>, Department of computer Sciences, Purdue University, 1980
</p>
</dd>
<dt>[Sch81]</dt>
<dd><p>H. D. Schwetman, <cite>Some Computational Aspects of Queueing Network
Models</cite>, <a href="http://docs.lib.purdue.edu/cstech/285/">Technical
Report CSD-TR-354</a>, Department of Computer Sciences, Purdue
University, feb, 1981 (revised).
</p>
</dd>
<dt><a name="Sch82"></a>[Sch82]</dt>
<dd><p>H. D. Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>,
<a href="http://docs.lib.purdue.edu/cstech/286/">Technical Report
CSD-TR-355</a>, Department of Computer Sciences, Purdue University, feb
15, 1982.
</p>
</dd>
<dt>[Sch84]</dt>
<dd><p>T. Kerola, H. D. Schwetman, <cite>Performance Bounds for
Multiclass Models</cite>, <a href="http://docs.lib.purdue.edu/cstech/399/">Technical Report CSD-TR-479</a>, Department of Computer Sciences, Purdue
University, 1984.
</p>
</dd>
<dt>[Tij03]</dt>
<dd><p>H. C. Tijms, <cite>A first course in stochastic models</cite>,
John Wiley and Sons, 2003, ISBN 0471498807, ISBN 9780471498803,
DOI <a href="http://dx.doi.org/10.1002/047001363X">10.1002/047001363X</a>
</p>
</dd>
<dt>[ZaWo81]</dt>
<dd><p>J. Zahorjan and E. Wong, <cite>The solution of separable queueing
network models using mean value analysis</cite>. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85.
DOI <a href="http://doi.acm.org/10.1145/1010629.805477">10.1145/1010629.805477</a>
</p>
</dd>
<dt>[Zeng03]</dt>
<dd><p>G. Zeng, <cite>Two common properties of the erlang-B function, erlang-C function, and Engset blocking function</cite>, Mathematical and Computer Modelling, Volume 37, Issues 12-13, June 2003, Pages 1287-1296 DOI
<a href="http://dx.doi.org/10.1016/S0895-7177(03)90040-9">10.1016/S0895-7177(03)90040-9</a>
</p>
</dd>
</dl>


<hr>
<a name="Copying"></a>
<div class="header">
<p>
Next: <a href="#Concept-Index" accesskey="n" rel="next">Concept Index</a>, Previous: <a href="#References" accesskey="p" rel="prev">References</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="GNU-GENERAL-PUBLIC-LICENSE"></a>
<h2 class="appendix">Appendix A GNU GENERAL PUBLIC LICENSE</h2>
<a name="index-warranty"></a>
<a name="index-copyright"></a>

<div align="center">Version 3, 29 June 2007
</div>
<div class="display">
<pre class="display">Copyright &copy; 2007 Free Software Foundation, Inc. <a href="http://fsf.org/">http://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.
</pre></div>

<a name="Preamble"></a>
<h3 class="heading">Preamble</h3>

<p>The GNU General Public License is a free, copyleft license for
software and other kinds of works.
</p>
<p>The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program&mdash;to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.
</p>
<p>When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.
</p>
<p>To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.
</p>
<p>For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.
</p>
<p>Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.
</p>
<p>For the developers&rsquo; and authors&rsquo; protection, the GPL clearly explains
that there is no warranty for this free software.  For both users&rsquo; and
authors&rsquo; sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.
</p>
<p>Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users&rsquo; freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.
</p>
<p>Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.
</p>
<p>The precise terms and conditions for copying, distribution and
modification follow.
</p>
<a name="TERMS-AND-CONDITIONS"></a>
<h3 class="heading">TERMS AND CONDITIONS</h3>

<ol>
<li> Definitions.

<p>&ldquo;This License&rdquo; refers to version 3 of the GNU General Public License.
</p>
<p>&ldquo;Copyright&rdquo; also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.
</p>
<p>&ldquo;The Program&rdquo; refers to any copyrightable work licensed under this
License.  Each licensee is addressed as &ldquo;you&rdquo;.  &ldquo;Licensees&rdquo; and
&ldquo;recipients&rdquo; may be individuals or organizations.
</p>
<p>To &ldquo;modify&rdquo; a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a &ldquo;modified version&rdquo; of
the earlier work or a work &ldquo;based on&rdquo; the earlier work.
</p>
<p>A &ldquo;covered work&rdquo; means either the unmodified Program or a work based
on the Program.
</p>
<p>To &ldquo;propagate&rdquo; a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.
</p>
<p>To &ldquo;convey&rdquo; a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.
</p>
<p>An interactive user interface displays &ldquo;Appropriate Legal Notices&rdquo; to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.
</p>
</li><li> Source Code.

<p>The &ldquo;source code&rdquo; for a work means the preferred form of the work for
making modifications to it.  &ldquo;Object code&rdquo; means any non-source form
of a work.
</p>
<p>A &ldquo;Standard Interface&rdquo; means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.
</p>
<p>The &ldquo;System Libraries&rdquo; of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
&ldquo;Major Component&rdquo;, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.
</p>
<p>The &ldquo;Corresponding Source&rdquo; for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work&rsquo;s
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.
</p>
<p>The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.
</p>
<p>The Corresponding Source for a work in source code form is that same
work.
</p>
</li><li> Basic Permissions.

<p>All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.
</p>
<p>You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force.
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.
</p>
<p>Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.
</p>
</li><li> Protecting Users&rsquo; Legal Rights From Anti-Circumvention Law.

<p>No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.
</p>
<p>When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work&rsquo;s users, your or third parties&rsquo; legal rights to forbid
circumvention of technological measures.
</p>
</li><li> Conveying Verbatim Copies.

<p>You may convey verbatim copies of the Program&rsquo;s source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.
</p>
<p>You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.
</p>
</li><li> Conveying Modified Source Versions.

<p>You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:
</p>
<ol>
<li> The work must carry prominent notices stating that you modified it,
and giving a relevant date.

</li><li> The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to &ldquo;keep intact all
notices&rdquo;.

</li><li> You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

</li><li> If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
</li></ol>

<p>A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
&ldquo;aggregate&rdquo; if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation&rsquo;s users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.
</p>
</li><li> Conveying Non-Source Forms.

<p>You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:
</p>
<ol>
<li> Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

</li><li> Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

</li><li> Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

</li><li> Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source.
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

</li><li> Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

</li></ol>

<p>A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.
</p>
<p>A &ldquo;User Product&rdquo; is either (1) a &ldquo;consumer product&rdquo;, which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
&ldquo;normally used&rdquo; refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.
</p>
<p>&ldquo;Installation Information&rdquo; for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.
</p>
<p>If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).
</p>
<p>The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.
</p>
<p>Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.
</p>
</li><li> Additional Terms.

<p>&ldquo;Additional permissions&rdquo; are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.
</p>
<p>When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.
</p>
<p>Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:
</p>
<ol>
<li> Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

</li><li> Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

</li><li> Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

</li><li> Limiting the use for publicity purposes of names of licensors or
authors of the material; or

</li><li> Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

</li><li> Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
</li></ol>

<p>All other non-permissive additional terms are considered &ldquo;further
restrictions&rdquo; within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.
</p>
<p>If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.
</p>
<p>Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.
</p>
</li><li> Termination.

<p>You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).
</p>
<p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</p>
<p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</p>
<p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.
</p>
</li><li> Acceptance Not Required for Having Copies.

<p>You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.
</p>
</li><li> Automatic Licensing of Downstream Recipients.

<p>Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.
</p>
<p>An &ldquo;entity transaction&rdquo; is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party&rsquo;s predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.
</p>
<p>You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.
</p>
</li><li> Patents.

<p>A &ldquo;contributor&rdquo; is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor&rsquo;s &ldquo;contributor version&rdquo;.
</p>
<p>A contributor&rsquo;s &ldquo;essential patent claims&rdquo; are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, &ldquo;control&rdquo; includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.
</p>
<p>Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor&rsquo;s essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.
</p>
<p>In the following three paragraphs, a &ldquo;patent license&rdquo; is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To &ldquo;grant&rdquo; such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.
</p>
<p>If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  &ldquo;Knowingly relying&rdquo; means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient&rsquo;s use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.
</p>
<p>If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.
</p>
<p>A patent license is &ldquo;discriminatory&rdquo; if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.
</p>
<p>Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.
</p>
</li><li> No Surrender of Others&rsquo; Freedom.

<p>If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.
</p>
</li><li> Use with the GNU Affero General Public License.

<p>Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.
</p>
</li><li> Revised Versions of this License.

<p>The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.
</p>
<p>Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.
</p>
<p>If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy&rsquo;s public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.
</p>
<p>Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.
</p>
</li><li> Disclaimer of Warranty.

<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &ldquo;AS IS&rdquo; WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.
</p>
</li><li> Limitation of Liability.

<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
</p>
</li><li> Interpretation of Sections 15 and 16.

<p>If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.
</p>
</li></ol>

<a name="END-OF-TERMS-AND-CONDITIONS"></a>
<h3 class="heading">END OF TERMS AND CONDITIONS</h3>

<a name="How-to-Apply-These-Terms-to-Your-New-Programs"></a>
<h3 class="heading">How to Apply These Terms to Your New Programs</h3>

<p>If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.
</p>
<p>To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the &ldquo;copyright&rdquo; line and a pointer to where the full notice is found.
</p>
<div class="smallexample">
<pre class="smallexample"><var>one line to give the program's name and a brief idea of what it does.</var>  
Copyright (C) <var>year</var> <var>name of author</var>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</pre></div>

<p>Also add information on how to contact you by electronic and paper mail.
</p>
<p>If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:
</p>
<div class="smallexample">
<pre class="smallexample"><var>program</var> Copyright (C) <var>year</var> <var>name of author</var> 
This program comes with ABSOLUTELY NO WARRANTY; for details type &lsquo;<samp>show w</samp>&rsquo;.
This is free software, and you are welcome to redistribute it
under certain conditions; type &lsquo;<samp>show c</samp>&rsquo; for details.
</pre></div>

<p>The hypothetical commands &lsquo;<samp>show w</samp>&rsquo; and &lsquo;<samp>show c</samp>&rsquo; should show
the appropriate parts of the General Public License.  Of course, your
program&rsquo;s commands might be different; for a GUI interface, you would
use an &ldquo;about box&rdquo;.
</p>
<p>You should also get your employer (if you work as a programmer) or school,
if any, to sign a &ldquo;copyright disclaimer&rdquo; for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>
<p>The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read <a href="http://www.gnu.org/philosophy/why-not-lgpl.html">http://www.gnu.org/philosophy/why-not-lgpl.html</a>.
</p>

<hr>
<a name="Concept-Index"></a>
<div class="header">
<p>
Next: <a href="#Function-Index" accesskey="n" rel="next">Function Index</a>, Previous: <a href="#Copying" accesskey="p" rel="prev">Copying</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Concept-Index-1"></a>
<h2 class="unnumbered">Concept Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-absorption-probabilities_002c-DTMC">absorption probabilities, DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-approximate-MVA">approximate MVA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asymmetric-M_002fM_002fm-system">asymmetric <em>M/M/m</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asymptotic-bounds">asymptotic bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asymptotic-bounds-1">asymptotic bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-balanced-system-bounds">balanced system bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-balanced-system-bounds-1">balanced system bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BCMP-network">BCMP network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-birth_002ddeath-process_002c-CTMC">birth-death process, CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-birth_002ddeath-process_002c-DTMC">birth-death process, DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blocking-queueing-network">blocking queueing network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-blocking-queueing-network-1">blocking queueing network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-asymptotic">bounds, asymptotic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-asymptotic-1">bounds, asymptotic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-asymptotic-2">bounds, asymptotic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-asymptotic-3">bounds, asymptotic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-balanced-system">bounds, balanced system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-balanced-system-1">bounds, balanced system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-balanced-system-2">bounds, balanced system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-composite">bounds, composite</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-geometric">bounds, geometric</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bounds_002c-PB">bounds, PB</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-multiclass-network">closed multiclass network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-multiclass-network-1">closed multiclass network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-multiclass-network-2">closed multiclass network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network">closed network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network-1">closed network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network-2">closed network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-approximate-analysis">closed network, approximate analysis</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-finite-capacity">closed network, finite capacity</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-finite-capacity-1">closed network, finite capacity</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes-1">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes-2">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes-3">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes-4">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-multiple-classes-5">closed network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-1">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-2">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-3">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-4">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-5">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-6">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-7">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-closed-network_002c-single-class-8">closed network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CMVA">CMVA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-composite-bounds">composite bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conditional-MVA-_0028CMVA_0029">conditional MVA (CMVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuous-time-Markov-chain">continuous time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuous-time-Markov-chain-1">continuous time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuous-time-Markov-chain-2">continuous time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuous-time-Markov-chain-3">continuous time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continuous-time-Markov-chain-4">continuous time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convolution-algorithm">convolution algorithm</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convolution-algorithm-1">convolution algorithm</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-copyright">copyright</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Copying">Copying</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTMC">CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTMC-1">CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTMC-2">CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTMC-3">CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CTMC-4">CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-deprecated-functions">deprecated functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Naming-Conventions">Naming Conventions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-1">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-2">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-3">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-4">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-5">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-discrete-time-Markov-chain-6">discrete time Markov chain</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-1">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-2">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-3">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-4">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-5">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DTMC-6">DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Engset-loss-formula">Engset loss formula</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Engset-Formula">The Engset Formula</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Erlang_002dB-formula">Erlang-B formula</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Erlang_002dB-Formula">The Erlang-B Formula</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Erlang_002dC-formula">Erlang-C formula</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Erlang_002dC-Formula">The Erlang-C Formula</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expected-sojourn-time_002c-CTMC">expected sojourn time, CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expected-sojourn-times_002c-DTMC">expected sojourn times, DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-first-passage-times">first passage times</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-first-passage-times_002c-CTMC">first passage times, CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fundamental-matrix">fundamental matrix</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-geometric-bounds">geometric bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-load_002ddependent-service-center">load-dependent service center</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load_002ddependent-service-center-1">load-dependent service center</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fG_002f1-system"><em>M/G/1</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fG_002f1-System">The M/G/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fH_005fm_002f1-system"><em>M/H_m/1</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fM_002f1-system"><em>M/M/1</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fM_002f1_002fK-system"><em>M/M/1/K</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fM_002finf-system"><em>M/M/</em>inf system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fM_002fm-system"><em>M/M/m</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-M_002fM_002fm_002fK-system"><em>M/M/m/K</em> system</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-1">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-2">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-3">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-4">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-5">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-continuous-time-6">Markov chain, continuous time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-1">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-2">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-3">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-4">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-5">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-discrete-time-6">Markov chain, discrete time</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-state-occupancy-probabilities">Markov chain, state occupancy probabilities</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-stationary-probabilities">Markov chain, stationary probabilities</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Markov-chain_002c-transient-probabilities">Markov chain, transient probabilities</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mean-recurrence-times">mean recurrence times</a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mean-time-to-absorption_002c-CTMC">mean time to absorption, CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mean-time-to-absorption_002c-DTMC">mean time to absorption, DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysis_002c-conditional-_0028CMVA_0029">Mean Value Analysis, conditional (CMVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029">Mean Value Analysys (MVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029-1">Mean Value Analysys (MVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029-2">Mean Value Analysys (MVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029-3">Mean Value Analysys (MVA)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate">Mean Value Analysys (MVA), approximate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-1">Mean Value Analysys (MVA), approximate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mixed-network">mixed network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-closed">multiclass network, closed</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-closed-1">multiclass network, closed</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-closed-2">multiclass network, closed</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-closed-3">multiclass network, closed</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-closed-4">multiclass network, closed</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-open">multiclass network, open</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiclass-network_002c-open-1">multiclass network, open</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MVA">MVA</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MVA_002c-approximate">MVA, approximate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MVA_002c-approximate-1">MVA, approximate</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MVABLO">MVABLO</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-normalization-constant">normalization constant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-normalization-constant-1">normalization constant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-normalization-constant-2">normalization constant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network">open network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network-1">open network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network-2">open network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network-3">open network</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network_002c-multiple-classes">open network, multiple classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-open-network_002c-single-class">open network, single class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-PB-bounds">PB bounds</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-population-mix">population mix</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-population-mix-1">population mix</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-queueing-network-with-blocking">queueing network with blocking</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-queueing-networks">queueing networks</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Queueing-Networks">Queueing Networks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-RS-blocking">RS blocking</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-stationary-probabilities">stationary probabilities</a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002dalveraged-sojourn-time_002c-CTMC">time-alveraged sojourn time, CTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002dalveraged-sojourn-time_002c-DTMC">time-alveraged sojourn time, DTMC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-traffic-intensity">traffic intensity</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Concept-Index_cp_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-warranty">warranty</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Copying">Copying</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<a name="Function-Index"></a>
<div class="header">
<p>
Next: <a href="#Author-Index" accesskey="n" rel="next">Author Index</a>, Previous: <a href="#Concept-Index" accesskey="p" rel="prev">Concept Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Function-Index-1"></a>
<h2 class="unnumbered">Function Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-fn" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmc"><code>ctmc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmc-1"><code>ctmc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcbd"><code>ctmcbd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcchkQ"><code>ctmcchkQ</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcexps"><code>ctmcexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcexps-1"><code>ctmcexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcfpt"><code>ctmcfpt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcfpt-1"><code>ctmcfpt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmcmtta"><code>ctmcmtta</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmctaexps"><code>ctmctaexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctmctaexps-1"><code>ctmctaexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmc"><code>dtmc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmc-1"><code>dtmc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcbd"><code>dtmcbd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcchkP"><code>dtmcchkP</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcexps"><code>dtmcexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcexps-1"><code>dtmcexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcfpt"><code>dtmcfpt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcmtta"><code>dtmcmtta</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmcmtta-1"><code>dtmcmtta</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmctaexps"><code>dtmctaexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dtmctaexps-1"><code>dtmctaexps</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-engset"><code>engset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Engset-Formula">The Engset Formula</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-erlangb"><code>erlangb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Erlang_002dB-Formula">The Erlang-B Formula</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-erlangc"><code>erlangc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Erlang_002dC-Formula">The Erlang-C Formula</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Function-Index_fn_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnclosed"><code>qnclosed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmaba"><code>qncmaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmaba-1"><code>qncmaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmaba-2"><code>qncmaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmaba-3"><code>qncmaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmbsb"><code>qncmbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmbsb-1"><code>qncmbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmcb"><code>qncmcb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmcb-1"><code>qncmcb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-1"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-2"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-3"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-4"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-5"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmva-6"><code>qncmmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmvaap"><code>qncmmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmvaap-1"><code>qncmmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmvaap-2"><code>qncmmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmvaap-3"><code>qncmmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmmvaap-4"><code>qncmmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmnpop"><code>qncmnpop</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmpopmix"><code>qncmpopmix</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmvisits"><code>qncmvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncmvisits-1"><code>qncmvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsaba"><code>qncsaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsaba-1"><code>qncsaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsaba-2"><code>qncsaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsaba-3"><code>qncsaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsbsb"><code>qncsbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsbsb-1"><code>qncsbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsbsb-2"><code>qncsbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsbsb-3"><code>qncsbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncscmva"><code>qncscmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncscmva-1"><code>qncscmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsconv"><code>qncsconv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsconv-1"><code>qncsconv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsconvld"><code>qncsconvld</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsgb"><code>qncsgb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsgb-1"><code>qncsgb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsgb-2"><code>qncsgb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsgb-3"><code>qncsgb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmva"><code>qncsmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmva-1"><code>qncsmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmva-2"><code>qncsmva</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvaap"><code>qncsmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvaap-1"><code>qncsmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvaap-2"><code>qncsmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvaap-3"><code>qncsmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvaap-4"><code>qncsmvaap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvablo"><code>qncsmvablo</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvald"><code>qncsmvald</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsmvald-1"><code>qncsmvald</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncspb"><code>qncspb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncspb-1"><code>qncspb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncspb-2"><code>qncspb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncspb-3"><code>qncspb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsvisits"><code>qncsvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qncsvisits-1"><code>qncsvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmarkov"><code>qnmarkov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmarkov-1"><code>qnmarkov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmarkov-2"><code>qnmarkov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmarkov-3"><code>qnmarkov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmix"><code>qnmix</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-1"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-2"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-3"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-4"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-5"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnmknode-6"><code>qnmknode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnom"><code>qnom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnom-1"><code>qnom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnom-2"><code>qnom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnom-3"><code>qnom</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnomaba"><code>qnomaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnomaba-1"><code>qnomaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnomvisits"><code>qnomvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnopen"><code>qnopen</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnos"><code>qnos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnos-1"><code>qnos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosaba"><code>qnosaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosaba-1"><code>qnosaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosaba-2"><code>qnosaba</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosbsb"><code>qnosbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosbsb-1"><code>qnosbsb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnosvisits"><code>qnosvisits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnsolve"><code>qnsolve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnsolve-1"><code>qnsolve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnsolve-2"><code>qnsolve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qnsolve-3"><code>qnsolve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-Algorithms">Generic Algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsammm"><code>qsammm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmg1"><code>qsmg1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fG_002f1-System">The M/G/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmh1"><code>qsmh1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmm1"><code>qsmm1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmm1k"><code>qsmm1k</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmminf"><code>qsmminf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmmm"><code>qsmmm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmmm-1"><code>qsmmm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qsmmmk"><code>qsmmmk</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<a name="Author-Index"></a>
<div class="header">
<p>
Previous: <a href="#Function-Index" accesskey="p" rel="prev">Function Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Author-Index-1"></a>
<h2 class="unnumbered">Author Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Author-Index_au_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-au" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Akyildiz_002c-I_002e-F_002e">Akyildiz, I. F.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bard_002c-Y_002e">Bard, Y.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-1">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-2">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-3">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-4">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-5">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-6">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-7">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-8">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-9">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-10">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bolch_002c-G_002e-11">Bolch, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Buzen_002c-J_002e-P_002e">Buzen, J. P.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Casale_002c-G_002e">Casale, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Casale_002c-G_002e-1">Casale, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Casale_002c-G_002e-2">Casale, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-1">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-2">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-3">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-4">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-5">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-6">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-7">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-8">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-9">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-10">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-de-Meer_002c-H_002e-11">de Meer, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-1">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-2">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-3">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-4">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-5">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graham_002c-G_002e-S_002e-6">Graham, G. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-1">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-2">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-3">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-4">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-5">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-6">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-7">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-8">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-9">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-10">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Greiner_002c-S_002e-11">Greiner, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hsieh_002c-C_002e-H_002e">Hsieh, C. H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-J">J</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Jain_002c-R_002e">Jain, R.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-K">K</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kerola_002c-T_002e">Kerola, T.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kobayashi_002c-H_002e">Kobayashi, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lam_002c-S_002e">Lam, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lavenberg_002c-S_002e-S_002e">Lavenberg, S. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lavenberg_002c-S_002e-S_002e-1">Lavenberg, S. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lavenberg_002c-S_002e-S_002e-2">Lavenberg, S. S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-1">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-2">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-3">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-4">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-5">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lazowska_002c-E_002e-D_002e-6">Lazowska, E. D.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Muntz_002c-R_002e-R_002e">Muntz, R. R.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Muntz_002c-R_002e-R_002e-1">Muntz, R. R.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reiser_002c-M_002e">Reiser, M.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reiser_002c-M_002e-1">Reiser, M.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reiser_002c-M_002e-2">Reiser, M.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reiser_002c-M_002e-3">Reiser, M.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Santini_002c-S_002e">Santini, S.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schweitzer_002c-P_002e">Schweitzer, P.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schwetman_002c-H_002e">Schwetman, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schwetman_002c-H_002e-1">Schwetman, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schwetman_002c-H_002e-2">Schwetman, H.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Serazzi_002c-G_002e">Serazzi, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Serazzi_002c-G_002e-1">Serazzi, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-1">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-2">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-3">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-4">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-5">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sevcik_002c-K_002e-C_002e-6">Sevcik, K. C.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-1">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002f1-System">The M/M/1 System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-2">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm-System">The M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-3">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002finf-System">The M/M/inf System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-4">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-5">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-6">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-7">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-8">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-9">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-10">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trivedi_002c-K_002e-11">Trivedi, K.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Wong_002c-E_002e">Wong, E.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Author-Index_au_letter-Z">Z</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Single-Class-Models">Single Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-1">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-2">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-3">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-4">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-5">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Class-Models">Multiple Class Models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-6">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zahorjan_002c-J_002e-7">Zahorjan, J.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bounds-Analysis">Bounds Analysis</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zeng_002c-G_002e">Zeng, G.</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Erlang_002dB-Formula">The Erlang-B Formula</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Author-Index_au_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Author-Index_au_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>

<hr>



</body>
</html>

This is comms.info, produced by makeinfo version 5.2 from comms.texi.


File: comms.info,  Node: Top,  Next: Introduction

Communications Package for Octave
*********************************

* Menu:

* Introduction::
* Random Signals::
* Source Coding::
* Block Coding::
* Convolutional Coding::
* Modulations::
* Special Filters::
* Galois Fields::
* Function Reference::


File: comms.info,  Node: Introduction,  Next: Random Signals,  Prev: Top,  Up: Top

1 Introduction
**************

This is the manual for the Communications Package for GNU Octave.  All
functions provided by this package are described in this manual.  In
addition many functions from Octave and other Octave packages are useful
to or required by this package, and so they may also be explained or
shown in examples in this manual.

   This documentation is a work in progress, you are invited to help
improve it and submit patches.


File: comms.info,  Node: Random Signals,  Next: Source Coding,  Prev: Introduction,  Up: Top

2 Random Signals
****************

The purpose of the functions described here is to create and add random
noise to a signal, to create random data and to analyze the eventually
errors in a received signal.  The functions to perform these tasks can
be considered as either related to the creation or analysis of signals
and are treated separately below.

   It should be noted that the examples below are based on the output of
a random number generator, and so the user can not expect to exactly
recreate the examples below.

* Menu:

* Signal Creation::
* Signal Analysis::


File: comms.info,  Node: Signal Creation,  Next: Signal Analysis,  Up: Random Signals

2.1 Signal Creation
===================

The signal creation functions here fall into to two classes.  Those that
treat discrete data and those that treat continuous data.  The basic
function to create discrete data is 'randint', that creates a random
matrix of equi-probable integers in a desired range.  For example

     octave:1> a = randint (3, 3, [-1, 1])
     a =

        0   1   0
       -1  -1   1
        0   1   1

creates a 3-by-3 matrix of random integers in the range -1 to 1.  To
allow for repeated analysis with the same random data, the function
'randint' allows the seed-value of the random number generator to be
set.  For instance

     octave:1> a = randint (3, 3, [-1, 1], 1)
     a =

        0   1   1
        0  -1   0
        1  -1  -1

will always produce the same set of random data.  The range of the
integers to produce can either be a two element vector or an integer.
In the case of a two element vector all elements within the defined
range can be produced.  In the case of an integer range M, 'randint'
returns the equi-probable integers in the range [0:2^M-1].

   The function 'randsrc' differs from 'randint' in that it allows a
random set of symbols to be created with a given probability.  The
symbols can be real, complex or even characters.  However characters and
scalars can not be mixed.  For example

     octave:1> a = randsrc (2, 2, "ab");
     octave:2> b = randsrc (4, 4, [1, 1i, -1, -1i]);

are both legal, while

     octave:1> a = randsrc (2, 2, [1, "a"]);

is not legal.  The alphabet from which the symbols are chosen can be
either a row vector or two row matrix.  In the case of a row vector, all
of the elements of the alphabet are chosen with an equal probability.
In the case of a two row matrix, the values in the second row define the
probability that each of the symbols are chosen.  For example

     octave:1> a = randsrc (5, 5, [1, 1i, -1, -1i; 0.6 0.2 0.1 0.1])
     a =

        1 + 0i   0 + 1i   0 + 1i   0 + 1i   1 + 0i
        1 + 0i   1 + 0i   0 + 1i   0 + 1i   1 + 0i
       -0 - 1i   1 + 0i  -1 + 0i   1 + 0i   0 + 1i
        1 + 0i   1 + 0i   1 + 0i   1 + 0i   1 + 0i
       -1 + 0i  -1 + 0i   1 + 0i   1 + 0i   1 + 0i

defines that the symbol '1' has a 60% probability, the symbol '1i' has a
20% probability and the remaining symbols have 10% probability each.
The sum of the probabilities must equal one.  Like 'randint', 'randsrc'
accepts a fourth argument as the seed of the random number generator
allowing the same random set of data to be reproduced.

   The function 'randerr' allows a matrix of random bit errors to be
created, for binary encoded messages.  By default, 'randerr' creates
exactly one errors per row, flagged by a non-zero value in the returned
matrix.  That is

     octave:1> a = randerr (5, 10)
     a =

        0   1   0   0   0   0   0   0   0   0
        0   0   1   0   0   0   0   0   0   0
        0   0   1   0   0   0   0   0   0   0
        0   0   0   0   0   0   0   0   0   1
        0   0   0   0   0   0   0   0   0   1

   The number of errors per row can be specified as the third argument
to 'randerr'.  This argument can be either a scalar, a row vector or a
two row matrix.  In the case of a scalar value, exactly this number of
errors will be created per row in the returned matrix.  In the case of a
row vector, each element of the row vector gives a possible number of
equi-probable bit errors.  The second row of a two row matrix defines
the probability of each number of errors occurring.  For example

     octave:1> n = 15; k = 11; nsym = 100;
     octave:2> msg = randint (nsym, k);       ## Binary vector of message
     octave:3> code = encode (msg, n, k, "bch");
     octave:4> berrs = randerr (nsym, n, [0, 1; 0.7, 0.3]);
     octave:5> noisy = mod (code + berrs, 2)  ## Add errors to coded message

creates a vector MSG, encodes it with a [15,11] BCH code, and then add
either none or one error per symbol with the chances of an error being
30%.  As previously, 'randerr' accepts a fourth argument as the seed of
the random number generator allowing the same random set of data to be
reproduced.

   All of the above functions work on discrete random signals.  The
functions 'wgn' and 'awgn' create and add white Gaussian noise to
continuous signals.  The function 'wgn' creates a matrix of white
Gaussian noise of a certain power.  A typical call to 'wgn' is then

     octave:1> nse = wgn (10, 10, 0);

which creates a 10-by-10 matrix of noise with a root mean squared power
of 0dBW relative to an impedance of 1 Ohm.

   This effectively means that an equivalent result to the above can be
obtained with

     octave:1> nse = randn (10, 10);

   The reference impedance and units of power to the function 'wgn' can
however be modified, for example

     octave:1> nse_30dBm_50Ohm = wgn (10000, 1, 30, 50, "dBm");
     octave:2> nse_0dBW_50Ohm = wgn (10000, 1, 0, 50, "dBW");
     octave:3> nse_1W_50Ohm = wgn (10000, 1, 1, 50, "linear");
     octave:4> [std(nse_30dBm_50Ohm), std(nse_0dBW_50Ohm), std(nse_1W_50Ohm)]
     ans =

        7.0805   7.1061   7.0730

   Each of these produces a 1W signal referenced to a 50 Ohm impedance.
MATLAB uses the misnomer "dB" for "dBW", so "dB" is an accepted type for
'wgn' and is treated as a synonym for "dBW".

   In all cases, the returned matrix V, will be related to the input
power P and the impedance Z as

   P = sum (V(:) .^ 2 ) / IMP Watts

   By default 'wgn' produces real vectors of white noise.  However, it
can produce both real and complex vectors like

     octave:1> rnse = wgn (10000, 1, 0, "dBm", "real");
     octave:2> cnse = wgn (10000, 1, 0, "dBm", "complex");
     octave:3> [std(rnse), std(real (cnse)), std(imag (cnse)), std(cnse)]
     ans =

        0.031615   0.022042   0.022241   0.031313

which shows that with a complex return value that the total power is the
same as a real vector, but that it is equally shared between the real
and imaginary parts.  As previously, 'wgn' accepts a fourth numerical
argument as the seed of the random number generator allowing the same
random set of data to be reproduced.  That is

     octave:1> nse = wgn (10, 10, 0, 0);

will always produce the same set of data.

   The final function to deal with the creation of random signals is
'awgn', that adds noise at a certain level relative to a desired signal.
This function adds noise at a certain level to a desired signal.  An
example call to 'awgn' is

     octave:1> x = [0:0.1:2*pi];
     octave:2> y = sin (x);
     octave:3> noisy = awgn (y, 10, "measured")

which adds noise with a 10dB signal-to-noise ratio to the measured power
in the desired signal.  By default 'awgn' assumes that the desired
signal is at 0dBW, and the noise is added relative to this assumed
power.  This behavior can be modified by the third argument to 'awgn'.
If the third argument is a numerical value, it is assumed to define the
power in the input signal, otherwise if the third argument is the string
"measured", as above, the power in the signal is measured prior to the
addition of the noise.

   The final argument to 'awgn' defines the definition of the power and
signal-to-noise ratio in a similar manner to 'wgn'.  This final argument
can be either "dB" or "linear".  In the first case the numerical value
of the input power is assumed to be in dBW and the signal-to-noise ratio
in dB. In the second case, the power is assumed to be in Watts and the
signal-to-noise ratio is expressed as a ratio.

   The return value of 'awgn' will be in the same form as the input
signal.  In addition if the input signal is real, the additive noise
will be real.  Otherwise the additive noise will also be complex and the
noise will be equally split between the real and imaginary parts.

   As previously the seed to the random number generator can be
specified as the last argument to 'awgn' to allow repetition of the same
scenario.  That is

     octave:1> x = [0:0.1:2*pi];
     octave:2> y = sin (x);
     octave:3> noisy = awgn (y, 10, "dB", 0, "measured")

which uses the seed-value of 0 for the random number generator.


File: comms.info,  Node: Signal Analysis,  Prev: Signal Creation,  Up: Random Signals

2.2 Signal Analysis
===================

It is important to be able to evaluate the performance of a
communications system in terms of its bit-error and symbol-error rates.
Two functions 'biterr' and 'symerr' exist within this package to
calculate these values, both taking as arguments the expected and the
actually received data.  The data takes the form of matrices or vectors,
with each element representing a single symbol.  They are compared in
the following manner

Both matrices
     In this case both matrices must be the same size and then by
     default the return values are the overall number of errors and the
     overall error rate.
One column vector
     In this case the column vector is used for comparison column-wise
     with the matrix.  The return values are row vectors containing the
     number of errors and the error rate for each column-wise
     comparison.  The number of rows in the matrix must be the same as
     the length of the column vector.
One row vector
     In this case the row vector is used for comparison row-wise with
     the matrix.  The return values are column vectors containing the
     number of errors and the error rate for each row-wise comparison.
     The number of columns in the matrix must be the same as the length
     of the row vector.

   For the bit-error comparison, the size of the symbol is assumed to be
the minimum number of bits needed to represent the largest element in
the two matrices supplied.  However, the number of bits per symbol can
(and in the case of random data should) be specified.  As an example of
the use of 'biterr' and 'symerr', consider the example

     octave:1> m = 8;
     octave:2> msg = randint (10, 10, 2^m);
     octave:3> noisy = mod (msg + diag (1:10), 2^m);
     octave:4> [berr, brate] = biterr (msg, noisy, m)
     berr = 32
     brate = 0.040000
     octave:5> [serr, srate] = symerr (msg, noisy)
     serr = 10
     srate = 0.10000

which creates a 10-by-10 matrix adds 10 symbols errors to the data and
then finds the bit and symbol error-rates.

   Two other means of displaying the integrity of a signal are the
eye-diagram and the scatterplot.  Although the functions 'eyediagram'
and 'scatterplot' have different appearance, the information presented
is similar and so are their inputs.  The difference between 'eyediagram'
and 'scatterplot' is that 'eyediagram' segments the data into time
intervals and plots the in-phase and quadrature components of the signal
against this time interval.  While 'scatterplot' uses a parametric plot
of quadrature versus in-phase components.

   Both functions can accept real or complex signals in the following
forms.

A real vector
     In this case the signal is assumed to be real and represented by
     the vector X.
A complex vector
     In this case the in-phase and quadrature components of the signal
     are assumed to be the real and imaginary parts of the signal.
A matrix with two columns
     In this case the first column represents the in-phase and the
     second the quadrature components of a complex signal.

   An example of the use of the function 'eyediagram' is

     octave:1> n = 50;
     octave:2> ovsp = 50;
     octave:3> x = 1:n;
     octave:4> xi = 1:1/ovsp:n-0.1;
     octave:5> y = randsrc (1, n, [1 + 1i, 1 - 1i, -1 - 1i, -1 + 1i]);
     octave:6> yi = interp1 (x, y, xi);
     octave:7> noisy = awgn (yi, 15, "measured");
     octave:8> eyediagram (noisy, ovsp);

   Similarly an example of the use of the function 'scatterplot' is

     octave:1> n = 200;
     octave:2> ovsp = 5;
     octave:3> x = 1:n;
     octave:4> xi = 1:1/ovsp:n-0.1;
     octave:5> y = randsrc (1, n, [1 + 1i, 1 - 1i, -1 - 1i, -1 + 1i]);
     octave:6> yi = interp1 (x, y, xi);
     octave:7> noisy = awgn (yi, 15, "measured");
     octave:8> f = scatterplot (noisy, 1, 0, "b");
     octave:9> hold on;
     octave:10> scatterplot (noisy, ovsp, 0, "r+", f);


File: comms.info,  Node: Source Coding,  Next: Block Coding,  Prev: Random Signals,  Up: Top

3 Source Coding
***************

* Menu:

* Quantization::
* PCM Coding::
* Arithmetic Coding::
* Dynamic Range Compression::


File: comms.info,  Node: Quantization,  Next: PCM Coding,  Up: Source Coding

3.1 Quantization
================

An important aspect of converting an analog signal to the digital domain
is quantization.  This is the process of mapping a continuous signal to
a set of defined values.  Octave contains two functions to perform
quantization, 'lloyds' creates an optimal mapping of the continuous
signal to a fixed number of levels and 'quantiz' performs the actual
quantization.

   The set of quantization points to use is represented by a
partitioning table (TABLE) of the data and the signal levels (CODES to
which they are mapped.  The partitioning TABLE is monotonically
increasing and if x falls within the range given by two points of this
table then it is mapped to the corresponding code as seen in Table 1.

          Table 1: Table quantization partitioning and coding

        x < table(1)                  codes(1)
        table(1) <= x < table(2)      codes(2)
        ...                           ...
        table(i-1) <= x < table(i)    codes(i)
        ...                           ...
        table(n-1) <= x < table(n)    codes(n)
        table(n-1) <= x               codes(n+1)

   These partition and coding tables can either be created by the user
of using the function 'lloyds'.  For instance the use of a linear
mapping can be seen in the following example.

     octave:1> m = 8;
     octave:2> n = 1024;
     octave:3> table = 2*[0:m-1]/m - 1 + 1/m;
     octave:4> codes = 2*[0:m]/m - 1;
     octave:5> x = 4*pi*[0:(n-1)]/(n-1);
     octave:6> y = cos (x);
     octave:7> [i, z] = quantiz (y, table, codes);

   If a training signal is known that well represents the expected
signals, the quantization levels can be optimized using the 'lloyds'
function.  For example the above example can be continued

     octave:8> [table2, codes2] = lloyds (y, table, codes);
     octave:9> [i, z2] = quantiz (y, table2, codes2);

to use the mapping suggested by the function 'lloyds'.  It should be
noted that the mapping given by 'lloyds' is highly dependent on the
training signal used.  So if this signal does not represent a realistic
signal to be quantized, then the partitioning suggested by 'lloyds' will
be sub-optimal.


File: comms.info,  Node: PCM Coding,  Next: Arithmetic Coding,  Prev: Quantization,  Up: Source Coding

3.2 PCM Coding
==============

The DPCM function 'dpcmenco', 'dpcmdeco' and 'dpcmopt' implement a form
of predictive quantization, where the predictability of the signal is
used to further compress it.  These functions are not yet implemented.


File: comms.info,  Node: Arithmetic Coding,  Next: Dynamic Range Compression,  Prev: PCM Coding,  Up: Source Coding

3.3 Arithmetic Coding
=====================

The arithmetic coding functions 'arithenco' and 'arithdeco' are not yet
implemented.


File: comms.info,  Node: Dynamic Range Compression,  Prev: Arithmetic Coding,  Up: Source Coding

3.4 Dynamic Range Compression
=============================

The final source coding function is 'compand' which is used to compress
and expand the dynamic range of a signal.  For instance consider a
logarithm quantized by a linear partitioning.  Such a partitioning is
very poor for this large dynamic range.  'compand' can then be used to
compress the signal prior to quantization, with the signal being
expanded afterwards.  For example

     octave:1> mu = 1.95;
     octave:2> x = [0.01:0.01:2];
     octave:3> y = log (x);
     octave:4> V = max (abs (y));
     octave:5> [i, z, d] = quantiz (y, [-4.875:0.25:0.875], [-5:0.25:1]);
     octave:6> c = compand (y, minmu, V, "mu/compressor");
     octave:7> [i2, c2] = quantiz (c, [-4.875:0.25:0.875], [-5:0.25:1]);
     octave:8> z2 = compand (c2, minmu, max (abs (c2)), "mu/expander");
     octave:9> d2 = sumsq (y - z2) / length (y);
     octave:10> [d, d2]
     ans =

        0.0053885   0.0029935

which demonstrates that the use of 'compand' can significantly reduce
the distortion due to the quantization of signals with a large dynamic
range.


File: comms.info,  Node: Block Coding,  Next: Convolutional Coding,  Prev: Source Coding,  Up: Top

4 Block Coding
**************

The error-correcting codes available in this package are discussed here.
These codes work with blocks of data, with no relation between one block
and the next.  These codes create codewords based on the messages to
transmit that contain redundant information that allow the recovery of
the original message in the presence of errors.

* Menu:

* Data Formats::
* Binary Block Codes::
* BCH Codes::
* Reed-Solomon Codes::


File: comms.info,  Node: Data Formats,  Next: Binary Block Codes,  Up: Block Coding

4.1 Data Formats
================

All of the codes described in this section are binary and share similar
data formats.  The exception is the Reed-Solomon coder which has a
significantly longer codeword length in general and therefore uses a
different representation to efficiently pass data.  The user should
refer to the section about the Reed-Solomon codes for the data format
used for Reed-Solomon codes.

   In general K bits of data are considered to represent a single
message symbol.  These K bits are coded into N bits of data representing
the codeword.  The data can therefore be grouped in one of three
manners, to emphasis this grouping into bits, messages and codewords

A binary vector
     Each element of the vector is either one or zero.  If the data
     represents an uncoded message the vector length should be an
     integer number of K in length.
A binary matrix
     In this case the data is ones and zeros grouped into rows, with
     each representing a single message or codeword.  The number of
     columns in the matrix should be equal to K in the case of a uncoded
     message or N in the case of a coded message.
A non-binary vector
     In this case each element of the vector represents a message or
     codeword in an integer format.  The bits of the message or codeword
     are represented by the bits of the vector elements with the
     least-significant bit representing the first element in the message
     or codeword.

   An example demonstrating the relationship between the three data
formats can be seen below.

     octave:1> k = 4;
     octave:2> bin_vec = randint (k*10, 1);         # Binary vector format
     octave:3> bin_mat = reshape (bin_vec, k, 10)'; # Binary matrix format
     octave:4> dec_vec = bi2de (bin_mat);           # Decimal vector format

   The functions within this package will return data in the same format
to which it is given.  It should be noted that internally the binary
matrix format is used, and thus if the message or codeword length is
large it is preferable to use the binary format to avoid internal
rounding errors.


File: comms.info,  Node: Binary Block Codes,  Next: BCH Codes,  Prev: Data Formats,  Up: Block Coding

4.2 Binary Block Codes
======================

All of the codes presented here can be characterized by their

Generator Matrix
     A K-by-N matrix G to generate the codewords C from the messages T
     by the matrix multiplication C = T * G.
Parity Check Matrix
     A 'N-K'-by-N matrix H to check the parity of the received symbols.
     If H * R = S != 0, then an error has been detected.  S can be used
     with the syndrome table to correct this error
Syndrome Table
     A 2^K-by-N matrix ST with the relationship of the error vectors to
     the non-zero parities of the received symbols.  That is, if the
     received symbol is represented as R = mod (T + E, 2), then the
     error vector E is ST(S).

   It is assumed for most of the functions in this package that the
generator matrix will be in a 'standard' form.  That is the generator
matrix can be represented by

      g(1,1)  g(1,2)  ...  g(1,k)  1  0  ...  0
      g(2,1)  g(2,2)       g(2,k)  0  1  ...  0
        .                    .     .          .
        .                    .     .          .
        .                    .     .          .
      g(k,1)  g(k,2)  ...  g(k,k)  0  0  ...  1

or

       1  0  ...  0  g(1,1)  g(1,2)  ...  g(1,k)
       0  1  ...  0  g(2,1)  g(2,2)       g(2,k)
       .          .     .                   .
       .          .     .                   .
       .          .     .                   .
       0  0  ...  1  g(k,1)  g(k,2)  ...  g(k,k)

and similarly the parity check matrix can be represented by a
combination of an identity matrix and a square matrix.

   Some of the codes can also have their representation in terms of a
generator polynomial that can be used to create the generator and parity
check matrices.  In the case of BCH codes, this generator polynomial is
used directly in the encoding and decoding without ever explicitly
forming the generator or parity check matrix.

   The user can create their own generator and parity check matrices, or
they can rely on the functions 'hammgen', 'cyclgen' and 'cyclpoly'.  The
function 'hammgen' creates parity check and generator matrices for
Hamming codes, while 'cyclpoly' and 'cyclgen' create generator
polynomials and matrices for generic cyclic codes.  An example of their
use is

     octave:1> m = 3;
     octave:2> n = 2^m - 1;
     octave:2> k = 4;
     octave:3> [par, gen] = hammgen (m);
     octave:4> [par2, gen2] = cyclgen (n, cyclpoly (n, k));

which create identical parity check and generator matrices for the [7,4]
Hamming code.

   The syndrome table of the codes can be created with the function
'syndtable', in the following manner

     octave:1> [par, gen] = hammgen (3);
     octave:2> st = syndtable (par);

   There exists two auxiliary functions 'gen2par' and 'gfweight', that
convert between generator and parity check matrices and calculate the
Hamming distance of the codes.  For instance

     octave:1> par = hammgen (3);
     octave:2> gen = gen2par (par);
     octave:3> gfweight (gen)
     ans = 3

   It should be noted that for large values of N, the generator, parity
check and syndrome table matrices are very large.  There is therefore an
internal limitation on the size of the block codes that can be created
that limits the codeword length N to less than 64.  This is still
excessively large for the syndrome table, so use caution with these
codes.  These limitations do not apply to the Reed-Solomon or BCH codes.

   The top-level encode and decode functions are 'encode' and 'decode',
which can be used with all codes, except the Reed-Solomon code.  The
basic call to both of these functions passes the message to code/decode,
the codeword length, the message length and the type of coding to use.
There are four basic types that are available with these functions

"linear"
     Generic linear block codes
"cyclic"
     Cyclic linear block codes
"hamming"
     Hamming codes
"bch"
     Bose Chaudhuri Hocquenghem (BCH) block codes

   It is not possible to distinguish between a binary vector and a
decimal vector coding of the messages that just happens to only have
ones and zeros.  Therefore the functions 'encode' and 'decode' must be
told the format of the messages in the following manner.

     octave:1> m = 3;
     octave:2> n = 7;
     octave:3> k = 4;
     octave:4> msg_bin = randint (10, k);
     octave:5> cbin = encode (msg_bin, n, k, "hamming/binary");
     octave:5> cdec = encode (bi2de (msg), n, k, "hamming/decimal");

which codes a binary matrix and a non-binary vector representation of a
message, returning the coded message in the same format.  The functions
'encode' and 'decode' by default accept binary coded messages.
Therefore "hamming" is equivalent to "hamming/binary".

   Except for the BCH codes, the function 'encode' and 'decode'
internally create the generator, parity check and syndrome table
matrices.  Therefore if repeated calls to 'encode' and 'decode' are
made, it will often be faster to create these matrices externally and
pass them as an argument.  For example

     n = 15;
     k = 11;
     [par, gen] = hammgen (4);
     code1 = code2 = zeros (100, 15)
     for i = 1:100
       msg = get_msg (i);
       code1(i,:) = encode (msg, n, k, "linear", gen);  # This is faster
       code2(i,:) = encode (msg, n, k, "hamming");      # than this !!!
     endfor

   In the case of the BCH codes the low-level functions described in the
next section are used directly by the 'encode' and 'decode' functions.


File: comms.info,  Node: BCH Codes,  Next: Reed-Solomon Codes,  Prev: Binary Block Codes,  Up: Block Coding

4.3 BCH Codes
=============

The BCH coder used here is based on code written by Robert
Morelos-Zaragoza (r.morelos-zaragoza@ieee.org).  This code was
originally written in C and has been converted for use as an Octave
oct-file.

   Called without arguments, 'bchpoly' returns a table of valid BCH
error correcting codes and their error-correction capability.  The first
returned column of 'bchpoly' is the codeword length, the second the
message length and the third the error correction capability of the
code.  Called with one argument, 'bchpoly' returns similar output, but
only for the specified codeword length.  In this manner codes with
codeword length greater than 511 can be found.

   In general the codeword length is of the form '2^M - 1', where M is
an integer.  However if [N,K] is a valid BCH code, then it is also
possible to use a shortened BCH form of the form '[N-X,K-X]'.

   With two or more arguments, 'bchpoly' is used to find the generator
polynomial of a valid BCH code.  For instance

     octave:1> bchpoly (15, 7)
     ans =

        1   0   0   0   1   0   1   1   1

     octave:2> bchpoly (14, 6)
     ans =

        1   0   0   0   1   0   1   1   1

show that the generator polynomial of a [15,7] BCH code with the default
primitive polynomial is

   1 + X ^ 4 + X ^ 6 + X ^ 7 + X ^ 8

   Using a different primitive polynomial to define the Galois Field
over which the BCH code is defined results in a different generator
polynomial as can be seen in the example.

     octave:1> bchpoly ([1 1 0 0 1], 7)
     ans =

        1   0   0   0   1   0   1   1   1

     octave:2> bchpoly ([1 0 0 1 1], 7)
     ans =

        1   1   1   0   1   0   0   0   1

   It is recommend not to convert the generator polynomials created by
'bchpoly' into generator and parity check matrices with the BCH codes,
as the underlying BCH software is faster than the generic coding
software and can treat significantly longer codes.

   As well as using the 'encode' and 'decode' functions previously
discussed, the user can directly use the low-level BCH functions
'bchenco' and 'bchdeco'.  In this case the messages must be in the
format of a binary matrix with K columns

     octave:1> n = 31;
     octave:2> pgs = bchpoly (n);
     octave:3> pg = pgs(floor (rand () * (rows (pgs) + 1)),:);  # Pick a poly
     octave:4> k = pg(2);
     octave:5> t = pg(3);
     octave:6> msg = randint (10, k);
     octave:7> code = bchenco (msg, n, k);
     octave:8> noisy = code + [ones(10, 1), zeros(10, n-1)];
     octave:9> dec = bchdeco (code, k, t);


File: comms.info,  Node: Reed-Solomon Codes,  Prev: BCH Codes,  Up: Block Coding

4.4 Reed-Solomon Codes
======================

* Menu:

* Representation of Reed-Solomon Messages::
* Creating and Decoding Messages::
* Shortened Reed-Solomon Codes::


File: comms.info,  Node: Representation of Reed-Solomon Messages,  Next: Creating and Decoding Messages,  Up: Reed-Solomon Codes

4.4.1 Representation of Reed-Solomon Messages
---------------------------------------------

The Reed-Solomon coder used in this package is based on code written by
Phil Karn (http://www.ka9q.net/code/fec).  This code was originally
written in C and has been converted for use as an Octave oct-file.

   Reed-Solomon codes are based on Galois Fields of even characteristics
GF(2^M). Many of the properties of Galois Fields are therefore important
when considering Reed-Solomon coders.

   The representation of the symbols of the Reed-Solomon code differs
from the other block codes, in that the other block codes use a binary
representation, while the Reed-Solomon code represents each m-bit symbol
by an integer.  The elements of the message and codeword must be
elements of the Galois Field corresponding to the Reed-Solomon code.
Thus to code a message with a [7,5] Reed-Solomon code an example is

     octave:1> m = 3;
     octave:2> n = 7;
     octave:3> k = 5;
     octave:4> msg = gf (floor (2^m * rand (2, k)), m)
     msg =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        5   0   6   3   2
        4   1   3   1   2

     octave:5> code = rsenc (msg, n, k)
     code =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        5   0   6   3   2   3   5
        4   1   3   1   2   6   3

   The variable N is the codeword length of the Reed-Solomon coder,
while K is the message length.  It should be noted that K should be less
than N and that 'N - K' should be even.  The error correcting capability
of the Reed-Solomon code is then '(N - K)/2' symbols.  M is the number
of bits per symbol, and is related to N by 'N = 2^M - 1'.  For a valid
Reed-Solomon coder, M should be between 3 and 16.


File: comms.info,  Node: Creating and Decoding Messages,  Next: Shortened Reed-Solomon Codes,  Prev: Representation of Reed-Solomon Messages,  Up: Reed-Solomon Codes

4.4.2 Creating and Decoding Messages
------------------------------------

The Reed-Solomon encoding function requires at least three arguments.
The first MSG is the message in encodes, the second is N the codeword
length and K is the message length.  Therefore MSG must have K columns
and the output will have N columns of symbols.

   The message itself is many up of elements of a Galois Field GF(2^M).
Normally, The order of the Galois Field (M), is related to the codeword
length by 'N = 2^M - 1'.  Another important parameter when determining
the behavior of the Reed-Solomon coder is the primitive polynomial of
the Galois Field (see 'gf').  Thus the messages

     octave:1> msg0 = gf ([0, 1, 2, 3], 3);
     octave:2> msg1 = gf ([0, 1, 2, 3], 3, 13);

will not result in the same Reed-Solomon coding.  Finally, the parity of
the Reed-Solomon code are generated with the use of a generator
polynomial.  The parity symbols are then generated by treating the
message to encode as a polynomial and finding the remainder of the
division of this polynomial by the generator polynomial.  Therefore the
generator polynomial must have as many roots as 'N - K'.  Whether the
parity symbols are placed before or afterwards the message will then
determine which end of the message is the most-significant term of the
polynomial representing the message.  The parity symbols are therefore
different in these two cases.  The position of the parity symbols can be
chosen by specifying "beginning" or "end" to 'rsenc' and 'rsdec'.  By
default the parity symbols are placed after the message.

   Valid generator polynomials can be constructed with the 'rsgenpoly'
function.  The roots of the generator polynomial are then defined by

     G = (X - A^(B*S)) * (X - A^((B+1)*S)) * ... * (X - A^((B+2*T-1)*S)).

where T is '(N - K)/2', A is the primitive element of the Galois Field,
B is the first consecutive root, and S is the step between roots.
Generator polynomial of this form are constructed by 'rsgenpoly' and can
be passed to both 'rsenc' and 'rsdec'.  It is also possible to pass the
B and S values directly to 'rsenc' and 'rsdec'.  In the case of 'rsdec'
passing B and S can make the decoding faster.

   Consider the example below.

     octave:1> m = 8;
     octave:2> n = 2^m - 1;
     octave:3> k = 223;
     octave:4> prim = 391;
     octave:5> b = 112;
     octave:6> s = 11;
     octave:7> gg = rsgenpoly (n, k, prim, b, s);
     octave:8> msg = gf (floor (2^m * rand (17, k)), m, prim);
     octave:9> code = rsenc (msg, n, k, gg);
     octave:10> noisy = code + [toeplitz([ones(1,17)], zeros(1,17)), zeros(17,238)];
     octave:11> [dec, nerr] = rsdec (msg, n, k, b, s);
     octave:12> nerr'
     ans =

         1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   -1

     octave:13> any (msg' != dec')
     ans =

        0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1

   This is an interesting example in that it demonstrates many of the
additional arguments of the Reed-Solomon functions.  In particular this
example approximates the CCSDS standard Reed-Solomon coder, lacking only
the dual-basis lookup tables used in this standard.  The CCSDS uses
non-default values to all of the basic functions involved in the
Reed-Solomon encoding, since it has a non-default primitive polynomial,
generator polynomial, etc.

   The example creates 17 message blocks and adds between 1 and 17 error
symbols to these block.  As can be seen NERR gives the number of errors
corrected.  In the case of 17 introduced errors NERR equals -1,
indicating a decoding failure.  This is normal as the correction ability
of this code is up to 16 error symbols.  Comparing the input message and
the decoding it can be seen that as expected, only the case of 17 errors
has not been correctly decoded.


File: comms.info,  Node: Shortened Reed-Solomon Codes,  Prev: Creating and Decoding Messages,  Up: Reed-Solomon Codes

4.4.3 Shortened Reed-Solomon Codes
----------------------------------

In general the codeword length of the Reed-Solomon coder is chosen so
that it is related directly to the order of the Galois Field by the
formula 'N = 2^M - 1'.  Although, the underlying Reed-Solomon coding
must operate over valid codeword length, there are sometimes reasons to
assume that the codeword length will be shorter.  In this case the
message is padded with zeros before coding, and the zeros are stripped
from the returned block.  For example consider the shortened [6,4]
Reed-Solomon below

     octave:1> m = 3;
     octave:2> n = 6;
     octave:3> k = 4;
     octave:4> msg = gf (floor (2^m * rand (2, k)), m)
     msg =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        7   0   2   5
        1   5   7   1

     octave:5> code = rsenc (msg, n, k)
     code =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        7   0   2   5   2   3
        1   5   7   1   0   2


File: comms.info,  Node: Convolutional Coding,  Next: Modulations,  Prev: Block Coding,  Up: Top

5 Convolutional Coding
**********************

Some initial support for convolutional codes is provided by the
functions described in this chapter.  Convolutional codes are different
from block codes in that the sequence of preceding symbols is taken into
account when computing the output symbol of the coder.

* Menu:

* Trellis Structure::
* Convolutional Encoding::


File: comms.info,  Node: Trellis Structure,  Next: Convolutional Encoding,  Up: Convolutional Coding

5.1 Trellis Structure
=====================

Like block codes, convolutional codes can be described by a set of
generator polynomials.  Each polynomial describes the combination of
current and previous input symbols used to compute one output bit of the
encoder.

   The state transitions and outputs of a convolutional encoder can also
be described by a trellis diagram.  This diagram describes the
transitions between states and the outputs of the encoder as a function
of the current state and the current input symbol.  A trellis structure
can be created from a set of generator polynomials, specified as octal
numbers by convention,

     octave:1> g0 = 13;
     octave:2> g1 = 17;
     octave:3> trellis = poly2trellis (4, [g0, g1]);

where G0 and G1 are the two polynomials of a rate 1/2 encoder with a
constraint length of 4.  The returned trellis structure contains the
following fields

'numInputSymbols'
     The number of possible input symbols in the input sequence.
'numOutputSymbols'
     The number of possible output symbols in the encoded sequence.
'numStates'
     The number of possible states that the encoder can take.
'nextStates'
     The state transition table for the encoder.  Each row contains the
     (zero-based) indices of the states reachable from the state
     represented by that row for each possible input symbol.
'outputs'
     The output table for the encoder.  Each row contains the
     (octal-encoded) output symbols produced by the encoder in the state
     represented by that row for each possible input symbol.

   To check if a variable references a structure that is a valid trellis
describing a convolutional encoder, use the 'istrellis' function.


File: comms.info,  Node: Convolutional Encoding,  Prev: Trellis Structure,  Up: Convolutional Coding

5.2 Convolutional Encoding
==========================

The convolutional encoding function takes the message to be encoded and
a trellis describing the encoder.  The message must be a binary vector
containing an even number of symbols.  For example, using the encoder
from the previous section,

     octave:1> trellis = poly2trellis (4, [13, 17]);
     octave:2> msg = [1 1 0 1 1 0 0 0];
     octave:3> out = convenc (msg, trellis)
     out =

        1   1   1   0   1   0   1   1   0   1   1   0   0   0   1   1

   The initial state of the encoder can also be passed in to 'convenc',
and the ending state can be read with an optional output argument.
Encoding a different vector with a different initial state using the
same encoder,

     octave:4> msg = [0 1 1 0 1 0 1 1];
     octave:5> [out, state] = convenc (msg, trellis, [], 4)
     out =

        0   1   0   0   0   1   1   0   1   1   1   0   0   0   0   1

     state =  6

returns both the encoded array and the final state of the convolutional
encoder.  This can be used to encode data in blocks, for example, saving
and restoring the internal state of the encoder for each subsequent
input block.


File: comms.info,  Node: Modulations,  Next: Special Filters,  Prev: Convolutional Coding,  Up: Top

6 Modulations
*************

To be written.

   Currently have functions amodce, ademodce, apkconst, demodmap,
modmap, qaskdeco, qaskenco, genqammod, pamdemod, pammod, pskdemod and
pskmod.


File: comms.info,  Node: Special Filters,  Next: Galois Fields,  Prev: Modulations,  Up: Top

7 Special Filters
*****************

To be written.


File: comms.info,  Node: Galois Fields,  Next: Function Reference,  Prev: Special Filters,  Up: Top

8 Galois Fields
***************

* Menu:

* Galois Field Basics::
* Manipulating Galois Fields::


File: comms.info,  Node: Galois Field Basics,  Next: Manipulating Galois Fields,  Up: Galois Fields

8.1 Galois Field Basics
=======================

A Galois Field is a finite algebraic field.  This package implements a
Galois Field type in Octave having 2^M members where M is an integer
between 1 and 16.  Such fields are denoted as GF(2^M) and are used in
error correcting codes in communications systems.  Galois Fields having
odd numbers of elements are not implemented.

   The _primitive element_ of a Galois Field has the property that all
elements of the Galois Field can be represented as a power of this
element.  The _primitive polynomial_ is the minimum polynomial of some
primitive element in GF(2^M) and is irreducible and of order M. This
means that the primitive element is a root of the primitive polynomial.

   The elements of the Galois Field GF(2^M) are represented as the
values 0 to 2^M -1 by Octave.  The first two elements represent the zero
and unity values of the Galois Field and are unique in all fields.  The
element represented by 2 is the primitive element of the field and all
elements can be represented as combinations of the primitive element and
unity as follows

Integer                  Binary                   Element of GF(2^M)
0                        000                      '0'
1                        001                      '1'
2                        010                      'A'
3                        011                      'A + 1'
4                        100                      'A^2'
5                        101                      'A^2 + 1'
6                        110                      'A^2 + A'
7                        111                      'A^2 + A + 1'

   It should be noted that there is often more than a single primitive
polynomial of GF(2^M). Each Galois Field over a different primitive
polynomial represents a different realization of the Field.  The
representations above however rest valid.

* Menu:

* Creating Galois Fields::
* Primitive Polynomials::
* Accessing Internal Fields::
* Function Overloading::
* Known Problems::


File: comms.info,  Node: Creating Galois Fields,  Next: Primitive Polynomials,  Up: Galois Field Basics

8.1.1 Creating Galois Fields
----------------------------

To work with a Galois Field GF(2^M) in Octave, you must first create a
variable that Octave recognizes as a Galois Field.  This is done with
the function 'gf (A, M)' as follows.

     octave:1> a = [0:7];
     octave:2> b = gf (a, 4)
     b =
     GF(2^4) array. Primitive Polynomial = D^4+D+1 (decimal 19)

     Array elements =

        0   1   2   3   4   5   6   7

   This creates an array B with 8 elements that Octave recognizes as a
Galois Field.  The field is created with the default primitive
polynomial for the field GF(2^4).  It can be verified that a variable is
in fact a Galois Field with the functions 'isgalois' or 'whos'.

     octave:3> isgalois (a)
     ans = 0
     octave:4> isgalois (b)
     ans = 1
     octave:5> whos
     Variables in the current scope:

        Attr Name        Size                     Bytes  Class
        ==== ====        ====                     =====  =====
             a           1x8                         24  double
             b           1x8                         32  galois

     Total is 16 elements using 56 bytes

   It is also possible to create a Galois Field with an arbitrary
primitive polynomial.  However, if the polynomial is not a primitive
polynomial of the field, and error message is returned.  For instance.

     octave:1> a = [0:7];
     octave:2> b = gf (a, 4, 25)
     b =
     GF(2^4) array. Primitive Polynomial = D^4+D^3+1 (decimal 25)

     Array elements =

        0   1   2   3   4   5   6   7

     octave:3> c = gf (a, 4, 21)
     error: gf: primitive polynomial (21) of Galois Field must be irreducible

   The function 'gftable' is included for compatibility with MATLAB.  In
MATLAB this function is used to create the lookup tables used to
accelerate the computations over the Galois Field and store them to a
file.  However Octave stores these parameters for all of the fields
currently in use and so this function is not required, although it is
silently accepted.


File: comms.info,  Node: Primitive Polynomials,  Next: Accessing Internal Fields,  Prev: Creating Galois Fields,  Up: Galois Field Basics

8.1.2 Primitive Polynomials
---------------------------

The function 'gf (A, M)' creates a Galois Field using the default
primitive polynomial.  However there exists many possible primitive
polynomials for most Galois Fields.  Two functions exist for identifying
primitive polynomials, 'isprimitive' and 'primpoly'.  'primpoly (M,
OPT)' is used to identify the primitive polynomials of the fields
GF(2^M). For example

     octave:1> primpoly (4)

     Primitive polynomial(s) =

     D^4+D+1

     ans = 19

identifies the default primitive polynomials of the field GF(2^M), which
is the same as 'primpoly (4, "min")'.  All of the primitive polynomials
of a field can be identified with the function 'primpoly (M, "all")'.
For example

     octave:1> primpoly (4, "all")

     Primitive polynomial(s) =

     D^4+D+1
     D^4+D^3+1

     ans =

        19   25

while 'primpoly (M, "max")' returns the maximum primitive polynomial of
the field, which for the case above is 25.  The function 'primpoly' can
also be used to identify the primitive polynomials having only a certain
number of non-zero terms.  For instance

     octave:1> primpoly (5, 3)

     Primitive polynomial(s) =

     D^5+D^2+1
     D^5+D^3+1

     ans =

        37   41

identifies the polynomials with only three terms that can be used as
primitive polynomials of GF(2^5).  If no primitive polynomials existing
having the requested number of terms then 'primpoly' returns an empty
vector.  That is

     octave:1> primpoly (5, 2)
     warning: primpoly: No primitive polynomial satisfies the given constraints

     ans = [](1x0)

   As can be seen above, 'primpoly' displays the polynomial forms the
the polynomials that it finds.  This output can be suppressed with the
"nodisplay" option, while the returned value is left unchanged.

     octave:1> primpoly (4, "all", "nodisplay")
     ans =

        19   25

   'isprimitive (A)' identifies whether the elements of A can be used as
primitive polynomials of the Galois Fields GF(2^M). Consider as an
example the fields GF(2^4).  The primitive polynomials of these fields
must have an order m and so their integer representation must be between
16 and 31.  Therefore 'isprimitive' can be used in a similar manner to
'primpoly' as follows

     octave:1> find (isprimitive (16:31)) + 15
     ans =

        19   25

which finds all of the primitive polynomials of GF(2^4).


File: comms.info,  Node: Accessing Internal Fields,  Next: Function Overloading,  Prev: Primitive Polynomials,  Up: Galois Field Basics

8.1.3 Accessing Internal Fields
-------------------------------

Once a variable has been defined as a Galois Field, the parameters of
the field of this structure can be obtained by adding a suffix to the
variable.  Valid suffixes are '.m', '.prim_poly' and '.x', which return
the order of the Galois Field, its primitive polynomial and the data the
variable contains respectively.  For instance

     octave:1> a = [0:7];
     octave:2> b = gf (a, 4);
     octave:3> b.m
     ans = 4
     octave:4> b.prim_poly
     ans = 19
     octave:5> c = b.x;
     octave:6> whos
     Variables in the current scope:

        Attr Name        Size                     Bytes  Class
        ==== ====        ====                     =====  =====
             a           1x8                         24  double
             b           1x8                         32  galois
             c           1x8                         64  double

     Total is 24 elements using 120 bytes

   Please note that it is explicitly forbidden to modify the Galois
field by accessing these variables.  For instance

     octave:1> a = gf ([0:7], 3);
     octave:2> a.prim_poly = 13;

is explicitly forbidden.  The result of this will be to replace the
Galois array A with a structure A with a single element called
'.prim_poly'.  To modify the order or primitive polynomial of a field, a
new field must be created and the data copied.  That is

     octave:1> a = gf ([0:7], 3);
     octave:2> a = gf (a.x, a.m, 13);


File: comms.info,  Node: Function Overloading,  Next: Known Problems,  Prev: Accessing Internal Fields,  Up: Galois Field Basics

8.1.4 Function Overloading
--------------------------

An important consideration in the use of the Galois Field package is
that many of the internal functions of Octave, such as 'roots', can not
accept Galois Fields as an input.  This package therefore uses Octave
classes to _overload_ the internal Octave functions with equivalent
functions that work with Galois Fields, so that the standard function
names can be used.

   The version of the function that is chosen is determined by the first
argument of the function.  This is a temporary situation until the
Galois Field class constructor can be rewritten to allow the use of the
'superiorto' function to define the galois class with a higher
precedence.  So, considering the 'filter' function, if the first
argument is a _Matrix_, then the normal version of the function is
called regardless of whether the other arguments of the function are
Galois vectors or not.

   Other Octave functions work correctly with Galois Fields and so
overloaded versions are not necessary.  This include such functions as
'size' and 'polyval'.

   It is also useful to use the '.x' option discussed in the previous
section, to extract the raw data of the Galois field for use with some
functions.  An example is

     octave:1> a = minpol (gf (14, 5));
     octave:2> b = de2bi (a.x, [], "left-msb");

converts the polynomial form of the minimum polynomial of 14 in GF(2^5)
into an integer.  Finally help for the Galois specific versions of the
functions must explicitly call the correct function as

     octave:1> help @galois/conv


File: comms.info,  Node: Known Problems,  Prev: Function Overloading,  Up: Galois Field Basics

8.1.5 Known Problems
--------------------

Please review the following list of known problems with the Galois type
before reporting a bug against this package.

Saving and loading Galois variables

     Saving a Galois variable to a file is as simple as

          octave:1> a = gf (...);
          octave:2> save a.mat a

     where A is any Galois variable.  Galois variables can be saved in
     the Octave binary and ASCII formats, as well as the HDF5 format.
     To load a Galois variable from a file, the Galois type must already
     be registered to the Octave interpreter prior to the call to
     'load'.  If no Galois variables have been created yet, you will
     have to do something like

          octave:1> dummy = gf (1);
          octave:2> load a.mat

Logarithm of zero does not return NaN
     The logarithm of zero in a Galois field is not defined.  However,
     to avoid segmentation faults in later calculations the logarithm of
     zero is defined as '2^M - 1', whose value is not the logarithm of
     any other value in the Galois field.  A warning is also shown to
     tell the user about the problem.  For example

          octave:1> m = 3;
          octave:2> a = log (gf ([0:2^m-1], m))
          warning: log of zero undefined in Galois field
          a =
          GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

          Array elements =

             7   0   1   3   2   6   4   5

     To fix this problem would require a major rewrite of all code,
     adding an exception for the case of NaN to all basic operators.
     These exceptions will certainly slow the code down.

Speed
     The code was written piecemeal with no attention to optimization.
     Some operations may be slower than they could be.  Contributions
     are welcome.


File: comms.info,  Node: Manipulating Galois Fields,  Prev: Galois Field Basics,  Up: Galois Fields

8.2 Manipulating Galois Fields
==============================

* Menu:

* Expressions manipulation and assignment::
* Unary operations::
* Arithmetic operations::
* Comparison operations::
* Polynomial manipulations::
* Linear Algebra::
* Signal Processing::


File: comms.info,  Node: Expressions manipulation and assignment,  Next: Unary operations,  Up: Manipulating Galois Fields

8.2.1 Expressions, manipulation and assignment
----------------------------------------------

Galois variables can be treated in similar manner to other variables
within Octave.  For instance Galois fields can be accessed using index
expressions in a similar manner to all other Octave matrices.  For
example

     octave:1> a = gf ([[0:7]; [7:-1:0]], 3)
     a =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        0   1   2   3   4   5   6   7
        7   6   5   4   3   2   1   0

     octave:2> b = a(1,:)
     b =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        0   1   2   3   4   5   6   7

   Galois arrays can equally use indexed assignments.  That is, the data
in the array can be partially replaced, on the condition that the two
fields are identical.  An example is

     octave:1> a = gf (ones (2, 8), 3);
     octave:2> b = gf (zeros (1, 8), 3);
     octave:3> a(1,:) = b
     a =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        0   0   0   0   0   0   0   0
        1   1   1   1   1   1   1   1

   Implicit conversions between normal matrices and Galois arrays are
possible.  For instance data can be directly copied from a Galois array
to a real matrix as follows.

     octave:1> a = gf (ones (2, 8), 3);
     octave:2> b = zeros (2, 8);
     octave:3> b(2,:) = a(2,:)
     b =

        0   0   0   0   0   0   0   0
        1   1   1   1   1   1   1   1

   The inverse is equally possible, with the proviso that the data in
the matrix is valid in the Galois field.  For instance

     octave:1> a = gf ([0:7], 3);
     octave:2> a(1) = 1;

is valid, while

     octave:1> a = gf ([0:7], 3);
     octave:2> a(1) = 8;

is not, since 8 is not an element of GF(2^3).  This is a basic rule of
manipulating Galois arrays.  That is matrices and scalars can be used in
conjunction with a Galois array as long as they contain valid data
within the Galois field.  In this case they will be assumed to be of the
same field.

   Galois arrays can also be concatenated with real matrices or with
other Galois arrays in the same field.  For example

     octave:1> a = [gf([0:7], 3); gf([7:-1:0], 3)];
     octave:2> b = [a, a];
     octave:3> c = [a, eye(2)];
     octave:3> whos
     Variables in the current scope:

        Attr Name        Size                     Bytes  Class
        ==== ====        ====                     =====  =====
             a           2x8                         64  galois
             b           2x16                       128  galois
             c           2x10                        80  galois

     Total is 68 elements using 272 bytes

   Other basic manipulations of Galois arrays are

'isempty'
     Returns true if the Galois array is empty.

'size'
     Returns the number of rows and columns in the Galois array.

'length'
     Returns the length of a Galois vector, or the maximum of rows or
     columns of Galois arrays.

'find'
     Find the indexes of the non-zero elements of a Galois array.

'diag'
     Create a diagonal Galois array from a Galois vector, or extract a
     diagonal from a Galois array.

'reshape'
     Change the shape of the Galois array.


File: comms.info,  Node: Unary operations,  Next: Arithmetic operations,  Prev: Expressions manipulation and assignment,  Up: Manipulating Galois Fields

8.2.2 Unary operations
----------------------

The same unary operators that are available for normal Octave matrices
are also available for Galois arrays.  These operations are

'+X'
     Unary plus.  This operator has no effect on the operand.

'-X'
     Unary minus.  Note that in a Galois Field this operator also has no
     effect on the operand.

'!X'
     Returns true for zero elements of Galois Array.

'X''
     Complex conjugate transpose.  As the Galois Field only contains
     integer values, this is equivalent to the transpose operator.

'X.''
     Transpose of the Galois array.


File: comms.info,  Node: Arithmetic operations,  Next: Comparison operations,  Prev: Unary operations,  Up: Manipulating Galois Fields

8.2.3 Arithmetic operations
---------------------------

The available arithmetic operations on Galois arrays are the same as on
other Octave matrices.  It should be noted that both operands must be in
the same Galois Field.  If one operand is a Galois array and the second
is a matrix or scalar, then the second operand is silently converted to
the same Galois Field.  The element(s) of these matrix or scalar must
however be valid members of the Galois field.  Thus

     octave:1> a = gf ([0:7], 3);
     octave:2> b = a + [0:7];

is valid, while

     octave:1> a = gf ([0:7], 3);
     octave:2> b = a + [1:8];

is not, since 8 is not a valid element of GF(2^3).  The available
arithmetic operators are

'X + Y'
     Addition.  If both operands are Galois arrays or matrices, the
     number of rows and columns must both agree.  If one operand is a is
     a Galois array with a single element or a scalar, its value is
     added to all the elements of the other operand.  The '+' operator
     on a Galois Field is equivalent to an exclusive-or on normal
     integers.

'X .+ Y'
     Element by element addition.  This operator is equivalent to '+'.

'X - Y'
     As both '+' and '-' in a Galois Field are equivalent to an
     exclusive-or for normal integers, '-' is equivalent to the '+'
     operator

'X .- Y'
     Element by element subtraction.  This operator is equivalent to
     '-'.

'X * Y'
     Matrix multiplication.  The number of columns of X must agree with
     the number of rows of Y.

'X .* Y'
     Element by element multiplication.  If both operands are matrices,
     the number of rows and columns must both agree.

'X / Y'
     Right division.  This is conceptually equivalent to the expression

          (inverse (y') * x')'

     but it is computed without forming the inverse of Y'.

     If the matrix is singular then an error occurs.  If the matrix is
     under-determined, then a particular solution is found (but not
     minimum norm).  If the solution is over-determined, then an attempt
     is made to find a solution, but this is not guaranteed to work.

'X ./ Y'
     Element by element right division.

'X \ Y'
     Left division.  This is conceptually equivalent to the expression

          inverse (x) * y

     but it is computed without forming the inverse of X.

     If the matrix is singular then an error occurs.  If the matrix is
     under-determined, then a particular solution is found (but not
     minimum norm).  If the solution is over-determined, then an attempt
     is made to find a solution, but this is not guaranteed to work.

'X .\ Y'
     Element by element left division.  Each element of Y is divided by
     each corresponding element of X.

'X ^ Y'
'X ** Y'
     Power operator.  If X and Y are both scalars, this operator returns
     X raised to the power Y.  Otherwise X must be a square matrix
     raised to an integer power.

'X .^ Y'
'X .** Y'
     Element by element power operator.  If both operands are matrices,
     the number of rows and columns must both agree.


File: comms.info,  Node: Comparison operations,  Next: Polynomial manipulations,  Prev: Arithmetic operations,  Up: Manipulating Galois Fields

8.2.4 Comparison operations
---------------------------

Galois variables can be tested for equality in the usual manner.  That
is

     octave:1> a = gf ([0:7], 3);
     octave:2> a == ones (1, 8)
     ans =

        0   1   0   0   0   0   0   0

     octave:3> a != zeros (1, 8)
     ans =

        0   1   1   1   1   1   1   1

   Likewise, Galois vectors can be tested against scalar values (whether
they are Galois or not).  For instance

     octave:4> a == 1
     ans =

        0   1   0   0   0   0   0   0

   To test if any or all of the values in a Galois array are non-zero,
the functions 'any' and 'all' can be used as normally.

   In addition the comparison operators '>', '>=', '<' and '<=' are
available.  As elements of the Galois Field are modulus 2^M, all
elements of the field are both greater than and less than all others at
the same time.  Thus these comparison operators don't make that much
sense and are only included for completeness.  The comparison is done
relative to the integer value of the Galois Field elements.


File: comms.info,  Node: Polynomial manipulations,  Next: Linear Algebra,  Prev: Comparison operations,  Up: Manipulating Galois Fields

8.2.5 Polynomial manipulations
------------------------------

A polynomial in GF(2^M) can be expressed as a vector in GF(2^M). For
instance if A is the _primitive element_, then the example

     octave:1> poly = gf ([2, 4, 5, 1], 3);

represents the polynomial

     poly = A * x^3 + A^2 * x^2 + (A^2 + 1) * x + 1

   Arithmetic can then be performed on these vectors.  For instance to
add to polynomials an example is

     octave:1> poly1 = gf ([2, 4, 5, 1], 3);
     octave:2> poly2 = gf ([1, 2], 3);
     octave:3> sumpoly = poly1 + [0, 0, poly2]
     sumpoly =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        2   4   4   3

   Note that POLY2 must be zero padded to the same length as poly1 to
allow the addition to take place.

   Multiplication and division of Galois polynomials is equivalent to
convolution and de-convolution of vectors of Galois elements.  Thus to
multiply two polynomials in GF(2^3).

     octave:4> mulpoly = conv (poly1, poly2)
     mulpoly =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        2   0   6   0   2

   Likewise the division of two polynomials uses the de-convolution
function as follows

     octave:5> [poly, remd] = deconv (mulpoly, poly2)
     poly =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        2   4   5   1

     remd =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        0   0   0   0   0

   Note that the remainder of this division is zero, as we performed the
inverse operation to the multiplication.

   To evaluate a polynomial for a certain value in GF(2^M), use the
Octave function 'polyval'.

     octave:1> poly1 = gf ([2, 4, 5, 1], 3);  ## a*x^3+a^2*x^2+(a^2+1)*x+1
     octave:2> x0 = gf ([0, 1, 2], 3);
     octave:3> y0 = polyval (poly1, x0);
     y0 =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        1   2   0

     octave:4> a = gf (2, 3);               ## The primitive element
     octave:5> y1 = a .* x0.^3 + a.^2 .* x0.^2 + (a.^2 + 1) .* x0 + 1
     y1 =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        1   2   0

   It is equally possible to find the roots of Galois polynomials with
the 'roots' function.  Using the polynomial above over GF(2^3), we can
find its roots in the following manner

     octave:1> poly1 = gf ([2, 4, 5, 1], 3);
     octave:2> root1 = roots (poly1)
     root1 =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        2
        5
        5

   Thus the example polynomial has 3 roots in GF(2^3) with one root of
multiplicity 2.  We can check this answer with the 'polyval' function as
follows

     octave:3> check1 = polyval (poly1, root1)
     check1 =
     GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

     Array elements =

        0
        0
        0

which as expected gives a zero vector.  It should be noted that both the
number of roots and their value, will depend on the chosen field.  Thus
for instance

     octave:1> poly3 = gf ([2, 4, 5, 1], 3, 13);
     octave:2> root3 = roots (poly3)
     root3 =
     GF(2^3) array. Primitive Polynomial = D^3+D^2+1 (decimal 13)

     Array elements =

        5

shows that in the field GF(2^3) with a different primitive polynomial,
has only one root exists.

   The minimum polynomial of an element of GF(2^M) is the minimum degree
polynomial in GF(2), excluding the trivial zero polynomial, that has
that element as a root.  The fact that the minimum polynomial is in
GF(2) means that its coefficients are one or zero only.  The 'minpol'
function can be used to find the minimum polynomial as follows

     octave:1> a = gf (2, 3);               ## The primitive element
     octave:2> b = minpol (a)
     b =
     GF(2) array.

     Array elements =

        1   0   1   1

   Note that the minimum polynomial of the primitive element is the
primitive polynomial.  Elements of GF(2^M) sharing the same minimum
polynomial form a partitioning of the field.  This partitioning can be
found with the 'cosets' function as follows

     octave:1> c = cosets (3)
     c =
     {
       [1,1] =
       GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

       Array elements =

          1

       [1,2] =
       GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

       Array elements =

          2   4   6

       [1,3] =
       GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

       Array elements =

          3   5   7

     }

which returns a cell array containing all of the elements of the
GF(2^3), partitioned into groups sharing the same minimum polynomial.
The function 'cosets' can equally accept a second argument defining the
primitive polynomial to use in its calculations (i.e.  'cosets (A, P)').


File: comms.info,  Node: Linear Algebra,  Next: Signal Processing,  Prev: Polynomial manipulations,  Up: Manipulating Galois Fields

8.2.6 Linear Algebra
--------------------

The basic linear algebra operation of this package is the LU
factorization of a Galois array.  That is the Galois array A is
factorized in the following way

     octave:2> [l, u, p] = lu (a)

such that 'P * A = L * U'.  The matrix P contains row permutations of A,
such that L and U are strictly upper and low triangular.  The Galois
array A can be rectangular.

   All other linear algebra operations within this package are based on
this LU factorization of a Galois array.  An important consequence of
this is that no solution can be found for singular matrices, only a
particular solution will be found for under-determined systems of
equation and the solution found for over-determined systems is not
always correct.  This is identical to the way MATLAB performs linear
algebra on Galois arrays.

   For instance consider the under-determined linear equation

     octave:1> A = gf ([2, 0, 3, 3; 3, 1, 3, 1; 3, 1, 1, 0], 2);
     octave:2> b = [0:2]';
     octave:3> x = A \ b;

gives the solution 'X = [2, 0, 3, 2]'.  There are in fact 4 possible
solutions to this linear system; 'X = [3, 2, 2, 0]', 'X = [0, 3, 1, 1]',
'X = [2, 0, 3, 2]' and 'X = [1, 1, 0, 3]'.  No particular selection
criteria are applied to the chosen solution.

   In addition, because singular matrices cannot be solved, unless you
know the matrix is not singular, you should test the determinant of the
matrix prior to solving the linear system.  For instance

     octave:1> A = gf (floor (2^m * rand (3)), 2);
     octave:2> b = [0:2]';
     octave:3> if (det (A) != 0); x = A \ b; y = b' / A; endif;
     octave:4> r = rank (A);

solves the linear systems 'A * X = B' and 'Y * A = B'.  Note that you do
not need to take into account rounding errors in the determinant, as the
determinant can only take values within the Galois Field.  So if the
determinant equals zero, the array is singular.


File: comms.info,  Node: Signal Processing,  Prev: Linear Algebra,  Up: Manipulating Galois Fields

8.2.7 Signal Processing with Galois Fields
------------------------------------------

Signal processing functions such as filtering, convolution,
de-convolution and Fourier transforms can be performed over Galois
Fields.  For instance the 'filter' function can be used with Galois
vectors in the same manner as usual.  For instance

     octave:1> b = gf ([2, 0, 0, 1, 0, 2, 0, 1], 2);
     octave:2> a = gf ([2, 0, 1, 1], 2);
     octave:3> x = gf ([1, zeros(1, 20)], 2);
     octave:4> y = filter (b, a, x)
     y =
     GF(2^2) array. Primitive Polynomial = D^2+D+1 (decimal 7)

     Array elements =

        1   0   3   0   2   3   1   0   1   3   3   1   0   1   3   3   1   0   1   3   3

gives the impulse response of the filter defined by A and B.

   Two equivalent ways are given to perform the convolution of two
Galois vectors.  Firstly the function 'conv' can be used, or
alternatively the function 'convmtx' can be used.  The first of these
function is identical to the convolution function over real vectors, and
has been described in the section about multiplying two Galois
polynomials.

   In the case where many Galois vectors will be convolved with the same
vector, the second function 'convmtx' offers an alternative method to
calculate the convolution.  If A is a column vector and X is a column
vector of length N, then

     octave:1> m = 3;
     octave:2> a = gf (floor (2^m * rand (4, 1)), m);
     octave:3> b = gf (floor (2^m * rand (4, 1)), m);
     octave:4> c0 = conv (a, b)';
     octave:5> c1 = convmtx (a, length (b)) * b;
     octave:6> check = all (c0 == c1)
     check = 1

shows the equivalence of the two functions.  The de-convolution function
has been previously described above.

   The final signal processing function available in this package are
the functions to perform Fourier transforms over a Galois field.  Three
functions are available, 'fft', 'ifft' and 'dftmtx'.  The first two
functions use the third to perform their work.  Given an element A of
the Galois field GF(2^M), 'dftmtx' returns the '2^M - 1' square matrix
used in the Fourier transforms with respect to A.  The minimum
polynomial of A must be primitive in GF(2^M). In the case of the 'fft'
function 'dftmtx' is called with the primitive element of the Galois
Field as an argument.  As an example

     octave:1> m = 4;
     octave:2> n = 2^m - 1;
     octave:2> alph = gf (2, m);
     octave:3> x = gf (floor (2^m * rand (n, 1)), m);
     octave:4> y0 = fft (x);
     octave:5> y1 = dftmtx (alph) * x;
     octave:6> z0 = ifft (y0);
     octave:7> z1 = dftmtx (1/alph) * y1;
     octave:8> check = all (y0 == y1) & all (z0 == x) & all (z1 == x)
     check = 1

   In all cases, the length of the vector to be transformed must be '2^M
-1'.  As the 'dftmtx' creates a matrix representing the Fourier
transform, to limit the computational task only Fourier transforms in
GF(2^M), where M is less than or equal to 8, are supported.


File: comms.info,  Node: Function Reference,  Prev: Galois Fields,  Up: Top

9 Function Reference
********************

9.1 Functions Alphabetically
============================

* Menu:

* ademodce::	Baseband demodulator for analog signals.
* amdemod::	Compute the amplitude demodulation of the signal S with a
		carrier
* ammod::	Create the AM modulation of the signal x with carrier
		frequency fs.
* amodce::	Baseband modulator for analog signals.
* apkconst::	Plots a ASK/PSK signal constellation.
* awgn::	Add white Gaussian noise to a voltage signal
* bchdeco::	Decodes the coded message CODE using a BCH coder.
* bchenco::	Encodes the message MSG using a [N,K] BCH coding.
* bchpoly::	Calculates the generator polynomials for a BCH coder.
* bi2de::	Convert bit matrix to a vector of integers
* biterr::	Compares two matrices and returns the number of bit errors
		and the bit error rate.
* bsc:: 	Send DATA into a binary symmetric channel with probability
		P of
* comms::	Manual and test code for the Octave Communications toolbox.
* compand::	Compresses and expanding the dynamic range of a signal
		using a
* conv::	Convolve two Galois vectors
* convenc::	Encode the binary vector MSG with the convolutional encoder
* convmtx::	Create matrix to perform repeated convolutions with the
		same vector in a Galois Field.
* cosets::	Finds the elements of GF(2^M) with primitive polynomial
		PRIM, that share the same minimum polynomial.
* cyclgen::	Produce the parity check and generator matrix of a cyclic
		code.
* cyclpoly::	This function returns the cyclic generator polynomials of
		the code [N,K].
* de2bi::	Convert a non-negative integer to bit vector
* decode::	Top level block decoder.
* deconv::	Deconvolve two Galois vectors
* deintrlv::	Restore elements of DATA according to ELEMENTS See also:
		intrlv
* demodmap::	Demapping of an analog signal to a digital signal.
* det:: 	Compute the determinant of the Galois array A
* dftmtx::	Form a matrix, that can be used to perform Fourier
		transforms in a
* diag::	Return a diagonal matrix with Galois vector V on diagonal K
		The second argument is optional.
* dpcmdeco::	Decode using differential pulse code modulation (DPCM)
* dpcmenco::	PREDICTOR)
* dpcmopt::	(TRAINING_SET, ORD, CB)
* egolaydec::	Decode Extended Golay code
* egolayenc::	Encode with Extended Golay code
* egolaygen::	Extended Golay code generator matrix
* encode::	Top level block encoder.
* exp:: 	Compute the anti-logarithm for each element of X for a
		Galois array
* eyediagram::	Plot the eye-diagram of a signal.
* fft:: 	If X is a column vector, finds the FFT over the primitive
		element of the Galois Field of X.
* fibodeco::	Returns the decoded Fibonacci value from the binary vectors
		CODE
* fiboenco::	Returns the cell-array of encoded Fibonacci value from the
		column
* fibosplitstream:: Returns the split data stream at the word boundaries
		Assuming the
* filter::	Digital filtering of vectors in a Galois Field.
* fmdemod::	Create the FM demodulation of the signal x with carrier
		frequency
* fmmod::	Create the FM modulation of the signal x with carrier
		frequency fs.
* gen2par::	Converts binary generator matrix GEN to the parity check
		matrix PAR and visa-versa.
* genqamdemod:: General quadrature amplitude demodulation.
* genqammod::	Modulates an information sequence of integers X in the
		range '[0
* gf::		Creates a Galois field array GF(2^M) from the matrix X.
* gftable::	This function exists for compatibility with matlab.
* gfweight::	Calculate the minimum weight or distance of a linear block
		code.
* golombdeco::	Returns the Golomb decoded signal vector using CODE and M
		Compulsory m is need to be specified.
* golombenco::	Returns the Golomb coded signal as cell array Also total
		length of
* hammgen::	Produce the parity check and generator matrices of a
		Hamming code.
* helscanintrlv:: NROWS-by-NCOLS See also: helscandeintrlv
* huffmandeco:: Decode signal encoded by 'huffmanenco'
* huffmandict:: Builds a Huffman code, given a probability list.
* huffmanenco:: Returns the Huffman encoded signal using DICT.
* ifft::	If X is a column vector, finds the IFFT over the primitive
		element of the Galois Field of X.
* intrlv::	Interleaved elements of DATA according to ELEMENTS See
		also:
* inv:: 	Compute the inverse of the square matrix A.
* inverse::	See inv
* isequal::	Return true if all of X1, X2, ... are equal See also:
* isgalois::	Return 1 if the value of the expression EXPR is a Galois
		Field.
* isprimitive:: Returns 1 is the polynomial represented by A is a primitive
		polynomial of GF(2).
* istrellis::	Return true if T is a valid trellis structure
* lloyds::	Optimize the quantization table and codes to reduce
		distortion.
* log:: 	Compute the natural logarithm for each element of X for a
		Galois
* lu::		Compute the LU decomposition of A in a Galois Field.
* lz77deco::	Lempel-Ziv 77 source algorithm decoding implementation.
* lz77enco::	Lempel-Ziv 77 source algorithm implementation.
* matdeintrlv:: Restore elements of DATA with a temporary matrix of size
* matintrlv::	Interleaved elements of DATA with a temporary matrix of
		size
* minpol::	Finds the minimum polynomial for elements of a Galois
		Field.
* modmap::	Mapping of a digital signal to an analog signal.
* oct2dec::	Convert octal to decimal values
* pamdemod::	Demodulates a pulse amplitude modulated signal X into an
* pammod::	Modulates an information sequence of integers X in the
		range '[0
* poly2trellis:: Convert convolutional code generator polynomials into
		trellis form
* primpoly::	Finds the primitive polynomials in GF(2^M).
* prod::	Product of elements along dimension DIM of Galois array.
* pskdemod::	Demodulates a complex-baseband phase shift keying modulated
		signal
* pskmod::	Modulates an information sequence of integers X in the
		range '[0
* qamdemod::	Create the QAM demodulation of x with a size of alphabet m
		See
* qammod::	Create the QAM modulation of x with a size of alphabet m
		See also:
* qaskdeco::	Demaps an analog signal using a square QASK constellation.
* qaskenco::	Map a digital signal using a square QASK constellation.
* qfunc::	Compute the Q function See also: erfc, erf
* qfuncinv::	Compute the inverse Q function See also: erfc, erf
* quantiz::	Quantization of an arbitrary signal relative to a
		partitioning
* randdeintrlv:: Restore elements of DATA with a random permutation See
		also:
* randerr::	Generate a matrix of random bit errors.
* randint::	Generate a matrix of random binary numbers.
* randintrlv::	Interleaves elements of DATA with a random permutation See
		also:
* randsrc::	Generate a matrix of random symbols.
* rank::	Compute the rank of the Galois array A by counting the
		independent
* reedmullerdec:: Decode the received code word VV using the RM-generator
		matrix G, of order R, M, returning the code-word C.
* reedmullerenc:: Definition type construction of Reed-Muller code, of
		order R, length 2^M.
* reedmullergen:: Definition type construction of Reed-Muller code, of
		order R, length 2^M.
* reshape::	Return a matrix with M rows and N columns whose elements
		are taken from the Galois array A.
* ricedeco::	Returns the Rice decoded signal vector using CODE and K
		Compulsory
* riceenco::	Returns the Rice encoded signal using K or optimal K
		Default optimal K is chosen between 0-7.
* rledeco::	Returns decoded run-length MESSAGE.
* rleenco::	Returns run-length encoded MESSAGE.
* roots::	For a vector V with N components, return the roots of the
* rsdec::	Decodes the message contained in CODE using a [N,K]
		Reed-Solomon code.
* rsdecof::	Decodes an ASCII file using a Reed-Solomon coder.
* rsenc::	Encodes the message MSG using a [N,K] Reed-Solomon coding.
* rsencof::	Encodes an ASCII file using a Reed-Solomon coder.
* rsgenpoly::	Creates a generator polynomial for a Reed-Solomon coding
		with message length of K and codelength of N.
* scatterplot:: Display the scatter plot of a signal.
* shannonfanodeco:: Returns the original signal that was Shannon-Fano
		encoded.
* shannonfanodict:: Returns the code dictionary for source using
		Shannon-Fano algorithm
* shannonfanoenco:: Returns the Shannon-Fano encoded signal using DICT This
		function
* sqrt::	Compute the square root of X, element by element, in a
		Galois Field
* sum:: 	Sum of elements along dimension DIM of Galois array.
* sumsq::	Sum of squares of elements along dimension DIM of Galois
		array If
* symerr::	Compares two matrices and returns the number of symbol
		errors and the symbol error rate.
* syndtable::	Create the syndrome decoding table from the parity check
		matrix H.
* systematize:: Given G, extract P parity check matrix.
* vec2mat::	Converts the vector V into a C column matrix with row
		priority
* wgn:: 	Returns a M-by-N matrix Y of white Gaussian noise.


File: comms.info,  Node: ademodce,  Next: amdemod,  Up: Function Reference

9.1.1 ademodce
--------------

 -- Function File: Y = ademodce (X, FS, "amdsb-tc", offset)
 -- Function File: Y = ademodce (X, FS, "amdsb-tc/costas", offset)
 -- Function File: Y = ademodce (X, FS, "amdsb-sc")
 -- Function File: Y = ademodce (X, FS, "amdsb-sc/costas")
 -- Function File: Y = ademodce (X, FS, "amssb")
 -- Function File: Y = ademodce (X, FS, "qam")
 -- Function File: Y = ademodce (X, FS, "qam/cmplx")
 -- Function File: Y = ademodce (X, FS, "fm", DEV)
 -- Function File: Y = ademodce (X, FS, "pm", DEV)
 -- Function File: Y = ademodce (X, [FS, IPHS], ...)
 -- Function File: Y = ademodce (..., NUM, DEN)

     Baseband demodulator for analog signals.  The input signal is
     specified by X, its sampling frequency by FS and the type of
     modulation by the third argument, TYP.  The default values of FS is
     1 and TYP is "amdsb-tc"

     If the argument FS is a two element vector, the first element
     represents the sampling rate and the second the initial phase

     The different types of demodulations that are available are

     "am"
     "amdsb-tc"
          Double-sideband with carrier
     "amdsb-tc/costas"
          Double-sideband with carrier and Costas phase locked loop
     "amdsb-sc"
          Double-sideband with suppressed carrier
     "amssb"
          Single-sideband with frequency domain Hilbert filtering
     "qam"
          Quadrature amplitude demodulation.  In-phase in odd-columns
          and quadrature in even-columns
     "qam/cmplx"
          Quadrature amplitude demodulation with complex return value
     "fm"
          Frequency demodulation
     "pm"
          Phase demodulation

     Additional arguments are available for the demodulations
     "amdsb-tc", "fm", "pm".  These arguments are

     'offset'
          The offset in the input signal for the transmitted carrier
     'dev'
          The deviation of the phase and frequency modulation

     It is possible to specify a low-pass filter, by the numerator NUM
     and denominator DEN that will be applied to the returned vector

     See also: ademodce, dmodce


File: comms.info,  Node: amdemod,  Next: ammod,  Prev: ademodce,  Up: Function Reference

9.1.2 amdemod
-------------

 -- Function File: M = amdemod (S, FC, FS)
     Compute the amplitude demodulation of the signal S with a carrier
     frequency of FC and a sample frequency of FS See also: ammod


File: comms.info,  Node: ammod,  Next: amodce,  Prev: amdemod,  Up: Function Reference

9.1.3 ammod
-----------

 -- Function File: ammod (X, FC, FS)
     Create the AM modulation of the signal x with carrier frequency fs.
     Where x is sample at frequency fs See also: amdemod, fmmod, fmdemod


File: comms.info,  Node: amodce,  Next: apkconst,  Prev: ammod,  Up: Function Reference

9.1.4 amodce
------------

 -- Function File: Y = amodce (X, FS, "amdsb-tc", offset)
 -- Function File: Y = amodce (X, FS, "amdsb-sc")
 -- Function File: Y = amodce (X, FS, "amssb")
 -- Function File: Y = amodce (X, FS, "amssb/time", NUM, DEN)
 -- Function File: Y = amodce (X, FS, "qam")
 -- Function File: Y = amodce (X, FS, "fm", DEV)
 -- Function File: Y = amodce (X, FS, "pm", DEV)
 -- Function File: Y = amodce (X, [FS, IPHS], ...)

     Baseband modulator for analog signals.  The input signal is
     specified by X, its sampling frequency by FS and the type of
     modulation by the third argument, TYP.  The default values of FS is
     1 and TYP is "amdsb-tc"

     If the argument FS is a two element vector, the first element
     represents the sampling rate and the second the initial phase

     The different types of modulations that are available are

     "am"
     "amdsb-tc"
          Double-sideband with carrier
     "amdsb-sc"
          Double-sideband with suppressed carrier
     "amssb"
          Single-sideband with frequency domain Hilbert filtering
     "amssb/time"
          Single-sideband with time domain filtering.  Hilbert filter is
          used by default, but the filter can be specified
     "qam"
          Quadrature amplitude modulation
     "fm"
          Frequency modulation
     "pm"
          Phase modulation

     Additional arguments are available for the modulations "amdsb-tc",
     "fm", "pm" and "amssb/time".  These arguments are

     'offset'
          The offset in the input signal for the transmitted carrier
     'dev'
          The deviation of the phase and frequency modulation
     'num'
     'den'
          The numerator and denominator of the filter transfer function
          for the time domain filtering of the SSB modulation

     See also: ademodce, dmodce


File: comms.info,  Node: apkconst,  Next: awgn,  Prev: amodce,  Up: Function Reference

9.1.5 apkconst
--------------

 -- Function File: apkconst (NSIG)
 -- Function File: apkconst (NSIG, AMP)
 -- Function File: apkconst (NSIG, AMP, PHS)
 -- Function File: apkconst (..., "n")
 -- Function File: apkconst (..., STR)
 -- Function File: Y = apkconst (...)

     Plots a ASK/PSK signal constellation.  Argument NSIG is a real
     vector whose length determines the number of ASK radii in the
     constellation The values of vector NSIG determine the number of
     points in each ASK radii

     By default the radii of each ASK modulated level is given by the
     index of NSIG.  The amplitudes can be defined explicitly in the
     variable AMP, which is a vector of the same length as NSIG

     By default the first point in each ASK radii has zero phase, and
     following points are coding in an anti-clockwise manner.  If PHS is
     defined then it is a vector of the same length as NSIG defining the
     initial phase in each ASK radii

     In addition 'apkconst' takes two string arguments "n" and STR If
     the string "n" is included in the arguments, then a number is
     printed next to each constellation point giving the symbol value
     that would be mapped to this point by the 'modmap' function.  The
     argument STR is a plot style string (example "r+") and determines
     the default gnuplot point style to use for plot points in the
     constellation

     If 'apkconst' is called with a return argument, then no plot is
     created.  However the return value is a vector giving the in-phase
     and quadrature values of the symbols in the constellation See also:
     dmod, ddemod, modmap, demodmap


File: comms.info,  Node: awgn,  Next: bchdeco,  Prev: apkconst,  Up: Function Reference

9.1.6 awgn
----------

 -- Function File: Y = awgn (X, SNR)
 -- Function File: Y = awgn (X, SNR, PWR)
 -- Function File: Y = awgn (X, SNR, PWR, SEED)
 -- Function File: Y = awgn (..., TYPE)

     Add white Gaussian noise to a voltage signal

     The input X is assumed to be a real or complex voltage signal.  The
     returned value Y will be the same form and size as X but with
     Gaussian noise added.  Unless the power is specified in PWR, the
     signal power is assumed to be 0dBW, and the noise of SNR dB will be
     added with respect to this.  If PWR is a numeric value then the
     signal X is assumed to be PWR dBW, otherwise if PWR is "measured",
     then the power in the signal will be measured and the noise added
     relative to this measured power

     If SEED is specified, then the random number generator seed is
     initialized with this value

     By default the SNR and PWR are assumed to be in dB and dBW
     respectively.  This default behavior can be chosen with TYPE set to
     "dB". In the case where TYPE is set to "linear", PWR is assumed to
     be in Watts and SNR is a ratio See also: randn, wgn


File: comms.info,  Node: bchdeco,  Next: bchenco,  Prev: awgn,  Up: Function Reference

9.1.7 bchdeco
-------------

 -- Loadable Function: MSG = bchdeco (CODE, K, T)
 -- Loadable Function: MSG = bchdeco (CODE, K, T, PRIM)
 -- Loadable Function: MSG = bchdeco (..., PARPOS)
 -- Loadable Function: [MSG, ERR] = bchdeco (...)
 -- Loadable Function: [MSG, ERR, CCODE] = bchdeco (...)
     Decodes the coded message CODE using a BCH coder.  The message
     length of the coder is defined in variable K, and the error
     correction capability of the code is defined in T.

     The variable CODE is a binary array with N columns and an arbitrary
     number of rows.  Each row of CODE represents a single symbol to be
     decoded by the BCH coder.  The decoded message is returned in the
     binary array MSG containing K columns and the same number of rows
     as CODE.

     The use of 'bchdeco' can be seen in the following short example.

          m = 3; n = 2^m -1; k = 4; t = 1;
          msg = randint (10, k);
          code = bchenco (msg, n, k);
          noisy = mod (randerr (10,n) + code, 2);
          [dec, err] = bchdeco (msg, k, t);

     Valid codes can be found using 'bchpoly'.  In general the codeword
     length N should be of the form '2^M-1', where m is an integer.
     However, shortened BCH codes can be used such that if '[2^M-1,K]'
     is a valid code '[2^M-1-X,K-X]' is also a valid code using the same
     generator polynomial.

     By default the BCH coding is based on the properties of the Galois
     Field GF(2^M).  The primitive polynomial used in the Galois can be
     overridden by a primitive polynomial in PRIM.  Suitable primitive
     polynomials can be constructed with 'primpoly'.  The form of PRIM
     maybe be either a integer representation of the primitive
     polynomial as given by 'primpoly', or a binary representation that
     might be constructed like

          m = 3;
          prim = de2bi (primpoly (m));

     By default the parity symbols are assumed to be placed at the
     beginning of the coded message.  The variable PARPOS controls this
     positioning and can take the values '"beginning\"' or '\"end\"'.
     See also: bchpoly, bchenco, decode, primpoly


File: comms.info,  Node: bchenco,  Next: bchpoly,  Prev: bchdeco,  Up: Function Reference

9.1.8 bchenco
-------------

 -- Loadable Function: CODE = bchenco (MSG, N, K)
 -- Loadable Function: CODE = bchenco (MSG, N, K, G)
 -- Loadable Function: CODE = bchenco (..., PARPOS)
     Encodes the message MSG using a [N,K] BCH coding.  The variable MSG
     is a binary array with K columns and an arbitrary number of rows.
     Each row of MSG represents a single symbol to be coded by the BCH
     coder.  The coded message is returned in the binary array CODE
     containing N columns and the same number of rows as MSG.

     The use of 'bchenco' can be seen in the following short example.

          m = 3; n = 2^m -1; k = 4;
          msg = randint (10,k);
          code = bchenco (msg, n, k);

     Valid codes can be found using 'bchpoly'.  In general the codeword
     length N should be of the form '2^M-1', where m is an integer.
     However, shortened BCH codes can be used such that if '[2^M-1,K]'
     is a valid code '[2^M-1-X,K-X]' is also a valid code using the same
     generator polynomial.

     By default the generator polynomial used in the BCH coding is based
     on the properties of the Galois Field GF(2^M).  This default
     generator polynomial can be overridden by a polynomial in G.
     Suitable generator polynomials can be constructed with 'bchpoly'.

     By default the parity symbols are placed at the beginning of the
     coded message.  The variable PARPOS controls this positioning and
     can take the values '"beginning\"' or '\"end\"'.  See also:
     bchpoly, bchdeco, encode


File: comms.info,  Node: bchpoly,  Next: bi2de,  Prev: bchenco,  Up: Function Reference

9.1.9 bchpoly
-------------

 -- Function File: P = bchpoly ()
 -- Function File: P = bchpoly (N)
 -- Function File: P = bchpoly (N, K)
 -- Function File: P = bchpoly (PRIM, K)
 -- Function File: P = bchpoly (N, K, PRIM)
 -- Function File: P = bchpoly (..., PROBE)
 -- Function File: [P, F] = bchpoly (...)
 -- Function File: [P, F, C] = bchpoly (...)
 -- Function File: [P, F, C, PAR] = bchpoly (...)
 -- Function File: [P, F, C, PAR, T] = bchpoly (...)

     Calculates the generator polynomials for a BCH coder.  Called with
     no input arguments 'bchpoly' returns a list of all of the valid BCH
     codes for the codeword length 7, 15, 31, 63, 127, 255 and 511.  A
     three column matrix is returned with each row representing a
     separate valid BCH code.  The first column is the codeword length,
     the second the message length and the third the error correction
     capability of the code

     Called with a single input argument, 'bchpoly' returns the valid
     BCH codes for the specified codeword length N.  The output format
     is the same as above

     When called with two or more arguments, 'bchpoly' calculates the
     generator polynomial of a particular BCH code.  The generator
     polynomial is returned in P as a vector representation of a
     polynomial in GF(2).  The terms of the polynomial are listed
     least-significant term first

     The desired BCH code can be specified by its codeword length N and
     its message length K.  Alternatively, the primitive polynomial over
     which to calculate the polynomial can be specified as PRIM If a
     vector representation of the primitive polynomial is given, then
     PRIM can be specified as the first argument of two arguments, or as
     the third argument.  However, if an integer representation of the
     primitive polynomial is used, then the primitive polynomial must be
     specified as the third argument

     When called with two or more arguments, 'bchpoly' can also return
     the factors F of the generator polynomial P, the cyclotomic coset
     for the Galois field over which the BCH code is calculated, the
     parity check matrix PAR and the error correction capability T.  It
     should be noted that the parity check matrix is calculated with
     'cyclgen' and limitations in this function means that the parity
     check matrix is only available for codeword length up to 63.  For
     codeword length longer than this PAR returns an empty matrix

     With a string argument PROBE defined, the action of 'bchpoly' is to
     calculate the error correcting capability of the BCH code defined
     by N, K and PRIM and return it in P.  This is similar to a call to
     'bchpoly' with zero or one argument, except that only a single code
     is checked.  Any string value for PROBE will force this action

     In general the codeword length N can be expressed as '2^M-1', where
     M is an integer.  However, if [N,K] is a valid BCH code, then a
     shortened BCH code of the form [N-X,K-X] can be created with the
     same generator polynomial

     See also: cyclpoly, encode, decode, cosets


File: comms.info,  Node: bi2de,  Next: biterr,  Prev: bchpoly,  Up: Function Reference

9.1.10 bi2de
------------

 -- Function File: D = bi2de (B)
 -- Function File: D = bi2de (B, F)
 -- Function File: D = bi2de (B, P)
 -- Function File: D = bi2de (B, P, F)

     Convert bit matrix to a vector of integers

     Each row of the matrix B is treated as a single integer represented
     in binary form.  The elements of B, must therefore be '0' or '1'

     If P is defined then it is treated as the base of the decomposition
     and the elements of B must then lie between '0' and 'p-1'

     The variable F defines whether the first or last element of B is
     considered to be the most-significant.  Valid values of F are
     "right-msb" or "left-msb".  By default F is "right-msb"

     See also: de2bi


File: comms.info,  Node: biterr,  Next: bsc,  Prev: bi2de,  Up: Function Reference

9.1.11 biterr
-------------

 -- Function File: [NUM, RATE] = biterr (A, B)
 -- Function File: [NUM, RATE] = biterr (..., K)
 -- Function File: [NUM, RATE] = biterr (..., FLAG)
 -- Function File: [NUM, RATE IND] = biterr (...)

     Compares two matrices and returns the number of bit errors and the
     bit error rate.  The binary representations of the variables A and
     B are treated and A and B can be either:

     Both matrices
          In this case both matrices must be the same size and then by
          default the return values NUM and RATE are the overall number
          of bit errors and the overall bit error rate
     One column vector
          In this case the column vector is used for bit error
          comparison column-wise with the matrix.  The returned values
          NUM and RATE are then row vectors containing the number of bit
          errors and the bit error rate for each of the column-wise
          comparisons.  The number of rows in the matrix must be the
          same as the length of the column vector
     One row vector
          In this case the row vector is used for bit error comparison
          row-wise with the matrix.  The returned values NUM and RATE
          are then column vectors containing the number of bit errors
          and the bit error rate for each of the row-wise comparisons.
          The number of columns in the matrix must be the same as the
          length of the row vector

     This behavior can be overridden with the variable FLAG.  FLAG can
     take the value "column-wise", "row-wise" or "overall".  A
     column-wise comparison is not possible with a row vector and
     visa-versa

     By default the number of bits in each symbol is assumed to be give
     by the number required to represent the maximum value of A and B
     The number of bits to represent a symbol can be overridden by the
     variable K


File: comms.info,  Node: bsc,  Next: comms,  Prev: biterr,  Up: Function Reference

9.1.12 bsc
----------

 -- Function File: Y = bsc (DATA, P)
     Send DATA into a binary symmetric channel with probability P of
     error one each symbol


File: comms.info,  Node: comms,  Next: compand,  Prev: bsc,  Up: Function Reference

9.1.13 comms
------------

 -- Function File: comms ("help")
 -- Function File: comms ("info")
 -- Function File: comms ("info", MOD)
 -- Function File: comms ("test")
 -- Function File: comms ("test", MOD)

     Manual and test code for the Octave Communications toolbox.  There
     are 5 possible ways to call this function

     'comms ("help")'
          Display this help message.  Called with no arguments, this
          function also displays this help message
     'comms ("info")'
          Open the Communications toolbox manual
     'comms ("info", MOD)'
          Open the Communications toolbox manual at the section
          specified by MOD
     'comms ("test")'
          Run all of the test code for the Communications toolbox
     'comms ("test", MOD)'
          Run only the test code for the Communications toolbox in the
          module MOD

     Valid values for the variable MOD are

     "all"
          All of the toolbox
     "random"
          The random signal generation and analysis package
     "source"
          The source coding functions of the package
     "block"
          The block coding functions
     "convol"
          The convolution coding package
     "modulation"
          The modulation package
     "special"
          The special filter functions
     "galois"
          The Galois fields package

     Please note that this function file should be used as an example of
     the use of this toolbox


File: comms.info,  Node: compand,  Next: conv,  Prev: comms,  Up: Function Reference

9.1.14 compand
--------------

 -- Function File: Y = compand (X, MU, V, "mu/compressor")
 -- Function File: Y = compand (X, MU, V, "mu/expander")
 -- Function File: Y = compand (X, MU, V, "A/compressor")
 -- Function File: Y = compand (X, MU, V, "A/expander")

     Compresses and expanding the dynamic range of a signal using a
     mu-law or or A-law algorithm

     The mu-law compressor/expander for reducing the dynamic range, is
     used if the fourth argument of 'compand' starts with "mu/".
     Whereas the A-law compressor/expander is used if 'compand' starts
     with "A/" The mu-law algorithm uses the formulation


                  V log (1 + \mu/V |x|)
              y = -------------------- sgn(x)
                      log (1 + \mu)


     while the A-law algorithm used the formulation


                  /    A / (1 + log A) x,               0 <= |x| <= V/A
                  |
              y = <    V ( 1 + log (A/V |x|) )
                  |    ----------------------- sgn(x),  V/A < |x| <= V
                  \        1 + log A

     Neither converts from or to audio file ulaw format.  Use mu2lin or
     lin2mu instead

     See also: m2ulin, lin2mu


File: comms.info,  Node: conv,  Next: convenc,  Prev: compand,  Up: Function Reference

9.1.15 conv
-----------

 -- Function File: conv (A, B)
     Convolve two Galois vectors

     'y = conv (a, b)' returns a vector of length equal to 'length (a) +
     length (b) - 1' If A and B are polynomial coefficient vectors,
     'conv' returns the coefficients of the product polynomial See also:
     deconv


File: comms.info,  Node: convenc,  Next: convmtx,  Prev: conv,  Up: Function Reference

9.1.16 convenc
--------------

 -- Function File: Y = convenc (MSG, T)
 -- Function File: Y = convenc (MSG, T, PUNCT)
 -- Function File: Y = convenc (MSG, T, PUNCT, S0)
 -- Function File: [Y, STATE_END] = convenc (...)
     Encode the binary vector MSG with the convolutional encoder
     described by the trellis structure T

     The rate k/n convolutional encoder encodes k bits at a time from
     the input vector and produces n bits at a time into the output
     vector.  The input MSG must have a length that is a multiple of k

     If the initial state S0 is specified, it indicates the internal
     state of the encoder when the first k input bits are fed in.  The
     default value of S0 is 0

     The optional output argument STATE_END indicates the internal state
     of the encoder after the last bits are encoded.  This allows the
     state of the encoder to be saved and applied to the next call to
     'convenc' to process data in blocks

     See also: poly2trellis


File: comms.info,  Node: convmtx,  Next: cosets,  Prev: convenc,  Up: Function Reference

9.1.17 convmtx
--------------

 -- Function File: convmtx (A, N)

     Create matrix to perform repeated convolutions with the same vector
     in a Galois Field.  If A is a column vector and X is a column
     vector of length N, in a Galois Field then

     'convmtx (A, N) * X'

     gives the convolution of of A and X and is the same as 'conv (A,
     X)'.  The difference is if many vectors are to be convolved with
     the same vector, then this technique is possibly faster

     Similarly, if A is a row vector and X is a row vector of length N,
     then

     'X * convmtx (A, N)'

     is the same as 'conv (X, A)' See also: conv


File: comms.info,  Node: cosets,  Next: cyclgen,  Prev: convmtx,  Up: Function Reference

9.1.18 cosets
-------------

 -- Function File: cosets (M, PRIM)

     Finds the elements of GF(2^M) with primitive polynomial PRIM, that
     share the same minimum polynomial.  Returns a cell array of the
     partitioning of GF(2^M)


File: comms.info,  Node: cyclgen,  Next: cyclpoly,  Prev: cosets,  Up: Function Reference

9.1.19 cyclgen
--------------

 -- Loadable Function: H = cyclgen (N, P)
 -- Loadable Function: H = cyclgen (N, P, TYP)
 -- Loadable Function: [H, G] = cyclgen (...)
 -- Loadable Function: [H, G, K] = cyclgen (...)
     Produce the parity check and generator matrix of a cyclic code.
     The parity check matrix is returned as a M by N matrix,
     representing the [N,K] cyclic code.  M is the order of the
     generator polynomial P and the message length K is given by 'N -
     M'.

     The generator polynomial can either be a vector of ones and zeros,
     and length M representing,

          P(1) + P(2) * x + P(3) * x^2 + ... + P(M) * x^(m-1)

     The terms of the polynomial are stored least-significant term
     first.  Alternatively, P can be an integer representation of the
     same polynomial.

     The form of the parity check matrix is determined by TYP.  If TYP
     is 'system', a systematic parity check matrix is produced.  If TYP
     is 'nosys' and non-systematic parity check matrix is produced.

     If requested 'cyclgen' also returns the K by N generator matrix G.
     See also: hammgen, gen2par, cyclpoly


File: comms.info,  Node: cyclpoly,  Next: de2bi,  Prev: cyclgen,  Up: Function Reference

9.1.20 cyclpoly
---------------

 -- Loadable Function: Y = cyclpoly (N, K)
 -- Loadable Function: Y = cyclpoly (N, K, OPT)
 -- Loadable Function: Y = cyclpoly (N, K, OPT, REP)
     This function returns the cyclic generator polynomials of the code
     [N,K].  By default the polynomial with the smallest weight is
     returned.  However this behavior can be overridden with the OPT
     flag.  Valid values of OPT are:

     '"all\"'
          Returns all of the polynomials of the code [N,K]
     '\"min\"'
          Returns the polynomial of minimum weight of the code [N,K]
     '\"max\"'
          Returns the polynomial of the maximum weight of the code [N,K]
     L
          Returns the polynomials having exactly the weight L

     The polynomials are returns as row-vectors in the variable Y.  Each
     row of Y represents a polynomial with the least-significant term
     first.  The polynomials can be returned with an integer
     representation if REP is '\"integer\"'.  The default behavior is
     given if REP is '\"polynomial\"'.  See also: gf, isprimitive


File: comms.info,  Node: de2bi,  Next: decode,  Prev: cyclpoly,  Up: Function Reference

9.1.21 de2bi
------------

 -- Function File: B = de2bi (D)
 -- Function File: B = de2bi (D, N)
 -- Function File: B = de2bi (D, N, P)
 -- Function File: B = de2bi (D, N, P, F)

     Convert a non-negative integer to bit vector

     The variable D must be a vector of non-negative integers.  'de2bi'
     then returns a matrix where each row represents the binary
     representation of elements of D.  If N is defined then the returned
     matrix will have N columns.  This number of columns can be either
     larger than the minimum needed and zeros will be added to the msb
     of the binary representation or smaller than the minimum in which
     case the least-significant part of the element is returned

     If P is defined then it is used as the base for the decomposition
     of the returned values.  That is the elements of the returned value
     are between '0' and 'p-1'

     The variable F defines whether the first or last element of B is
     considered to be the most-significant.  Valid values of F are
     "right-msb" or "left-msb".  By default F is "right-msb"

     See also: bi2de


File: comms.info,  Node: decode,  Next: deconv,  Prev: de2bi,  Up: Function Reference

9.1.22 decode
-------------

 -- Function File: MSG = decode (CODE, N, K)
 -- Function File: MSG = decode (CODE, N, K, TYP)
 -- Function File: MSG = decode (CODE, N, K, TYP, OPT1)
 -- Function File: MSG = decode (CODE, N, K, TYP, OPT1, OPT2)
 -- Function File: [MSG, ERR] = decode (...)
 -- Function File: [MSG, ERR, CCODE] = decode (...)
 -- Function File: [MSG, ERR, CCODE, CERR] = decode (...)

     Top level block decoder.  This function makes use of the lower
     level functions such as 'cyclpoly', 'cyclgen', 'hammgen', and
     'bchenco'.  The coded message to decode is pass in CODE, the
     codeword length is N and the message length is K.  This function is
     used to decode messages using either:

     A [n,k] linear block code defined by a generator matrix
     A [n,k] cyclic code defined by a generator polynomial
     A [n,k] Hamming code defined by a primitive polynomial
     A [n,k] BCH code code defined by a generator polynomial

     The type of coding to use is defined by the variable TYP.  This
     variable is a string taking one of the values

     '"linear"'
     '"linear/binary"'
          A linear block code is assumed with the message MSG being in a
          binary format.  In this case the argument OPT1 is the
          generator matrix, and is required.  Additionally, OPT2
          containing the syndrome lookup table (see 'syndtable') can
          also be passed
     '"cyclic"'
     '"cyclic/binary"'
          A cyclic code is assumed with the message MSG being in a
          binary format.  The generator polynomial to use can be defined
          in OPT1 The default generator polynomial to use will be
          'cyclpoly (N, K)'.  Additionally, OPT2 containing the syndrome
          lookup table (see 'syndtable') can also be passed
     '"hamming"'
     '"hamming/binary"'
          A Hamming code is assumed with the message MSG being in a
          binary format.  In this case N must be of an integer of the
          form '2^M-1', where M is an integer.  In addition K must be
          'N-M'.  The primitive polynomial to use can be defined in
          OPT1.  The default primitive polynomial to use is the same as
          defined by 'hammgen'.  The variable OPT2 should not be defined
     '"bch"'
     '"bch/binary"'
          A BCH code is assumed with the message MSG being in a binary
          format.  The primitive polynomial to use can be defined in
          OPT2 The error correction capability of the code can also be
          defined in OPT1.  Use the empty matrix [] to let the error
          correction capability take the default value

     In addition the argument "binary" above can be replaced with
     "decimal", in which case the message is assumed to be a decimal
     vector, with each value representing a symbol to be coded.  The
     binary format can be in two forms

     'An X-by-N matrix'
          Each row of this matrix represents a symbol to be decoded
     'A vector with length divisible by N'
          The coded symbols are created from groups of N elements of
          this vector

     The decoded message is return in MSG.  The number of errors
     encountered is returned in ERR.  If the coded message format is
     "decimal" or a "binary" matrix, then ERR is a column vector having
     a length equal to the number of decoded symbols.  If CODE is a
     "binary" vector, then ERR is the same length as MSG and indicated
     the number of errors in each symbol.  If the value ERR is positive
     it indicates the number of errors corrected in the corresponding
     symbol.  A negative value indicates an uncorrectable error.  The
     corrected code is returned in CCODE in a similar format to the
     coded message MSG.  The variable CERR contains similar data to ERR
     for CCODE

     It should be noted that all internal calculations are performed in
     the binary format.  Therefore for large values of N, it is
     preferable to use the binary format to pass the messages to avoid
     possible rounding errors.  Additionally, if repeated calls to
     'decode' will be performed, it is often faster to create a
     generator matrix externally with the functions 'hammgen' or
     'cyclgen', rather than let 'decode' recalculate this matrix at each
     iteration.  In this case TYP should be "linear".  The exception to
     this case is BCH codes, where the required syndrome table is too
     large.  The BCH decoder, decodes directly from the polynomial never
     explicitly forming the syndrome table

     See also: encode, cyclgen, cyclpoly, hammgen, bchdeco, bchpoly,
     syndtable


File: comms.info,  Node: deconv,  Next: deintrlv,  Prev: decode,  Up: Function Reference

9.1.23 deconv
-------------

 -- Function File: deconv (Y, A)
     Deconvolve two Galois vectors

     '[b, r] = deconv (y, a)' solves for B and R such that 'y = conv (a,
     b) + r'

     If Y and A are polynomial coefficient vectors, B will contain the
     coefficients of the polynomial quotient and R will be a remainder
     polynomial of lowest order See also: conv


File: comms.info,  Node: deintrlv,  Next: demodmap,  Prev: deconv,  Up: Function Reference

9.1.24 deintrlv
---------------

 -- Function File: DEINTRLVD = deintrlv (DATA, ELEMENTS)
     Restore elements of DATA according to ELEMENTS See also: intrlv


File: comms.info,  Node: demodmap,  Next: det,  Prev: deintrlv,  Up: Function Reference

9.1.25 demodmap
---------------

 -- Function File: z = demodmap (Y, FD, FS, "ask", M)
 -- Function File: z = demodmap (Y, FD, FS, "fsk", M, TONE)
 -- Function File: z = demodmap (Y, FD, FS, "msk")
 -- Function File: z = demodmap (Y, FD, FS, "psk", M)
 -- Function File: z = demodmap (Y, FD, FS, "qask", M)
 -- Function File: z = demodmap (Y, FD, FS, "qask/cir", NSIG, AMP, PHS)
 -- Function File: z = demodmap (Y, FD, FS, "qask/arb", INPHASE, QUADR)
 -- Function File: z = demodmap (Y, FD, FS, "qask/arb", MAP)
 -- Function File: z = demodmap (Y, [FD, OFF], ...)

     Demapping of an analog signal to a digital signal.  The function
     'demodmap' must have at least three input arguments and one output
     argument.  Argument Y is a complex variable representing the analog
     signal to be demapped.  The variables FD and FS are the sampling
     rate of the of digital signal and the sampling rate of the analog
     signal respectively.  It is required that 'FS/FD' is an integer

     The available mapping of the digital signal are

     "ask"
          Amplitude shift keying
     "fsk"
          Frequency shift keying
     "msk"
          Minimum shift keying
     "psk"
          Phase shift keying
     "qask"
     "qsk"
     "qam"
          Quadrature amplitude shift keying

     In addition the "qask", "qsk" and "qam" method can be modified with
     the flags "/cir" or "/arb".  That is "qask/cir" and "qask/arb", etc
     are valid methods and give circular- and arbitrary-qask mappings
     respectively.  Also the method "fsk" and "msk" can be modified with
     the flag "/max", in which case Y is assumed to be a matrix with M
     columns, representing the symbol correlations

     The variable M is the order of the modulation to use.  By default
     this is 2, and in general should be specified

     For "qask/cir", the additional arguments are the same as for
     'apkconst', and you are referred to 'apkconst' for the definitions
     of the additional variables

     For "qask/arb", the additional arguments INPHASE and QUADR give the
     in-phase and quadrature components of the mapping, in a similar
     mapping to the outputs of 'qaskenco' with one argument.  Similar
     MAP represents the in-phase and quadrature components of the
     mapping as the real and imaginary parts of the variable MAP See
     also: modmap, ddemodce, ademodce, apkconst, qaskenco


File: comms.info,  Node: det,  Next: dftmtx,  Prev: demodmap,  Up: Function Reference

9.1.26 det
----------

 -- Loadable Function: D = det (A)
     Compute the determinant of the Galois array A


File: comms.info,  Node: dftmtx,  Next: diag,  Prev: det,  Up: Function Reference

9.1.27 dftmtx
-------------

 -- Function File: D = dftmtx (A)

     Form a matrix, that can be used to perform Fourier transforms in a
     Galois Field

     Given that A is an element of the Galois Field GF(2^m), and that
     the minimum value for K for which 'A ^ K' is equal to one is '2^m -
     1', then this function produces a K-by-K matrix representing the
     discrete Fourier transform over a Galois Field with respect to A.
     The Fourier transform of a column vector is then given by 'dftmtx
     (A) * X'

     The inverse Fourier transform is given by 'dftmtx (1 / A)'


File: comms.info,  Node: diag,  Next: dpcmdeco,  Prev: dftmtx,  Up: Function Reference

9.1.28 diag
-----------

 -- Loadable Function: diag (V, K)
     Return a diagonal matrix with Galois vector V on diagonal K The
     second argument is optional.  If it is positive, the vector is
     placed on the K-th super-diagonal.  If it is negative, it is placed
     on the -K-th sub-diagonal.  The default value of K is 0, and the
     vector is placed on the main diagonal.  For example,

          diag (gf ([1, 2, 3], 2), 1)
          ans =
          GF(2^2) array. Primitive Polynomial = D^2+D+1 (decimal 7)

          Array elements =

             0   1   0   0
             0   0   2   0
             0   0   0   3
             0   0   0   0



File: comms.info,  Node: dpcmdeco,  Next: dpcmenco,  Prev: diag,  Up: Function Reference

9.1.29 dpcmdeco
---------------

 -- Function File: SIG = dpcmdeco (INDX, CODEBOOK, PREDICTOR)
     Decode using differential pulse code modulation (DPCM)

     'sig = dpcmdeco (indx, codebook, predictor)'
          Decode the signal coded by DPCM Use the prediction model and
          the coded prediction error given by a codebook and the index
          of each sample in this codebook

     See also: dpcmenco, dpcmopt


File: comms.info,  Node: dpcmenco,  Next: dpcmopt,  Prev: dpcmdeco,  Up: Function Reference

9.1.30 dpcmenco
---------------

 -- Function File: QIDX = dpcmenco (SIG, CODEBOOK, PARTITION, PREDICTOR)
 -- Function File: [QIDX, Q] = dpcmenco (SIG, CODEBOOK, PARTITION,
          PREDICTOR)
 -- Function File: [QIDX, Q, D] = dpcmenco (...)
     Encode using differential pulse code modulation (DPCM)

     'qidx = dpcmenco (sig, codebook, partition, predictor)'
          Determine position of the prediction error in a strictly
          monotonic table (partition) The predictor vector describes a
          m-th order prediction for the output according to the
          following equation y(k) = p(1)sig(k-1) + p(2)sig(k-2) + ...  +
          p(m-1)sig(k-m+1) + p(m)sig(k-m) , where the predictor vector
          is given by predictor = [0, p(1), p(2), p(3),..., p(m-1),
          p(m)]

     '[qidx, q] = dpcmenco (sig, codebook, partition, predictor)'
          Also return the quantized values

     '[qidx, q, d] = dpcmenco (...)'
          Also compute distortion: mean squared distance of original sig
          from the corresponding quantized values

     See also: dpcmdeco, dpcmopt, quantiz


File: comms.info,  Node: dpcmopt,  Next: egolaydec,  Prev: dpcmenco,  Up: Function Reference

9.1.31 dpcmopt
--------------

 -- Function File: PREDICTOR = dpcmopt (TRAINING_SET, ORD)
 -- Function File: [PREDICTOR, PARTITION, CODEBOOK] = dpcmopt
          (TRAINING_SET, ORD, CB)
     Optimize the DPCM parameters and codebook

     It uses the Levinson-Durbin algorithm to find the all-pole IIR
     filter using the autocorrelation sequence.  After the best
     predictor is found, it uses the Lloyds algorithm to find the best
     codebook and partition for the interval

     'predictor = dpcmopt (training_set, ord)'
          Optimize the DPCM parameters using the Levinson-Durbin
          algorithm The predictor vector describes a m-th order
          prediction for the output according to the following equation
          y(k) = p(1)sig(k-1) + p(2)sig(k-2) + ...  + p(m-1)sig(k-m+1) +
          p(m)sig(k-m) where the predictor vector is given by predictor
          = [0, p(1), p(2), p(3),..., p(m-1), p(m)]

          training_set is the training data used to find the best
          predictor

          ord is the order of the desired prediction model

     '[predictor, partition, codebook] = dpcmopt (training_set,ord,cb)'
          Optimize the DPCM parameters and also uses the Lloyds
          algorithm to find the best codebook and partition for the
          given training signal

          cb might be the initial codebook used by Lloyds algorithm or
          the length of the desired codebook

     See also: dpcmenco, dpcmdeco, levinson, lloyds


File: comms.info,  Node: egolaydec,  Next: egolayenc,  Prev: dpcmopt,  Up: Function Reference

9.1.32 egolaydec
----------------

 -- Function File: [C, ERR] = egolaydec (R)
     Decode Extended Golay code

     Given R, the received Extended Golay code, this function tries to
     decode it using the Extended Golay code parity check matrix
     Extended Golay code (24,12) which can correct up to 3 errors

     The received code R, needs to be of length Nx24, for encoding.  We
     can decode several codes at once, if they are stacked as a matrix
     of 24 columns, each code in a separate row

     The generator used in here is same as obtained from the function
     'egolaygen'

     The function returns C, the error-corrected code word from the
     received word.  If decoding failed, ERR value is 1, otherwise it is
     0

     Extended Golay code (24,12) which can correct up to 3 errors.
     Decoding algorithm follows from Lin & Costello

     Ref: Lin & Costello, pg 128, Ch4, "Error Control Coding", 2nd ed,
     Pearson

          msg = rand (10, 12) > 0.5;
          c1 = egolayenc (msg);
          c1(:,1) = mod (c1(:,1) + 1, 2)
          c2 = egolaydec (c1)

     See also: egolaygen, egolayenc


File: comms.info,  Node: egolayenc,  Next: egolaygen,  Prev: egolaydec,  Up: Function Reference

9.1.33 egolayenc
----------------

 -- Function File: C = egolayenc (M)
     Encode with Extended Golay code

     The message M, needs to be of size Nx12, for encoding We can encode
     several messages, into codes at once, if they are stacked in the
     order suggested

     The generator used in here is same as obtained from the function
     'egolaygen'.  Extended Golay code (24,12) which can correct up to 3
     errors

          msg = rand (10, 12) > 0.5;
          c = egolayenc (msg)

     See also: egolaygen, egolaydec


File: comms.info,  Node: egolaygen,  Next: encode,  Prev: egolayenc,  Up: Function Reference

9.1.34 egolaygen
----------------

 -- Function File: [G, P] = egolaygen ()
     Extended Golay code generator matrix

     Returns G, the Extended Golay code (24,12) generator matrix, which
     can correct up to 3 errors.  P is the parity check matrix, for this
     code

     See also: egolaydec, egolayenc


File: comms.info,  Node: encode,  Next: exp,  Prev: egolaygen,  Up: Function Reference

9.1.35 encode
-------------

 -- Function File: CODE = encode (MSG, N, K)
 -- Function File: CODE = encode (MSG, N, K, TYP)
 -- Function File: CODE = encode (MSG, N, K, TYP, OPT)
 -- Function File: [CODE, ADDED] = encode (...)

     Top level block encoder.  This function makes use of the lower
     level functions such as 'cyclpoly', 'cyclgen', 'hammgen', and
     'bchenco'.  The message to code is pass in MSG, the codeword length
     is N and the message length is K.  This function is used to encode
     messages using either:

     A [n,k] linear block code defined by a generator matrix
     A [n,k] cyclic code defined by a generator polynomial
     A [n,k] Hamming code defined by a primitive polynomial
     A [n,k] BCH code code defined by a generator polynomial

     The type of coding to use is defined by the variable TYP.  This
     variable is a string taking one of the values

     '"linear"'
     '"linear/binary"'
          A linear block code is assumed with the coded message CODE
          being in a binary format.  In this case the argument OPT is
          the generator matrix, and is required
     '"cyclic"'
     '"cyclic/binary"'
          A cyclic code is assumed with the coded message CODE being in
          a binary format.  The generator polynomial to use can be
          defined in OPT The default generator polynomial to use will be
          'cyclpoly (N, K)'
     '"hamming"'
     '"hamming/binary"'
          A Hamming code is assumed with the coded message CODE being in
          a binary format.  In this case N must be of an integer of the
          form '2^M-1', where M is an integer.  In addition K must be
          'N-M'.  The primitive polynomial to use can be defined in OPT.
          The default primitive polynomial to use is the same as defined
          by 'hammgen'
     '"bch"'
     '"bch/binary"'
          A BCH code is assumed with the coded message CODE being in a
          binary format.  The generator polynomial to use can be defined
          in OPT The default generator polynomial to use will be
          'bchpoly (N, K)'

     In addition the argument "binary" above can be replaced with
     "decimal", in which case the message is assumed to be a decimal
     vector, with each value representing a symbol to be coded.  The
     binary format can be in two forms

     'An X-by-K matrix'
          Each row of this matrix represents a symbol to be coded
     'A vector'
          The symbols are created from groups of K elements of this
          vector If the vector length is not divisible by K, then zeros
          are added and the number of zeros added is returned in ADDED

     It should be noted that all internal calculations are performed in
     the binary format.  Therefore for large values of N, it is
     preferable to use the binary format to pass the messages to avoid
     possible rounding errors.  Additionally, if repeated calls to
     'encode' will be performed, it is often faster to create a
     generator matrix externally with the functions 'hammgen' or
     'cyclgen', rather than let 'encode' recalculate this matrix at each
     iteration.  In this case TYP should be "linear".  The exception to
     this case is BCH codes, whose encoder is implemented directly from
     the polynomial and is significantly faster

     See also: decode, cyclgen, cyclpoly, hammgen, bchenco, bchpoly


File: comms.info,  Node: exp,  Next: eyediagram,  Prev: encode,  Up: Function Reference

9.1.36 exp
----------

 -- Loadable Function: exp (X)
     Compute the anti-logarithm for each element of X for a Galois array


File: comms.info,  Node: eyediagram,  Next: fft,  Prev: exp,  Up: Function Reference

9.1.37 eyediagram
-----------------

 -- Function File: eyediagram (X, N)
 -- Function File: eyediagram (X, N, PER)
 -- Function File: eyediagram (X, N, PER, OFF)
 -- Function File: eyediagram (X, N, PER, OFF, STR)
 -- Function File: eyediagram (X, N, PER, OFF, STR, H)
 -- Function File: H = eyediagram (...)

     Plot the eye-diagram of a signal.  The signal X can be either in
     one of three forms

     A real vector
          In this case the signal is assumed to be real and represented
          by the vector X.  A single eye-diagram representing this
          signal is plotted
     A complex vector
          In this case the in-phase and quadrature components of the
          signal are plotted separately
     A matrix with two columns
          In this case the first column represents the in-phase and the
          second the quadrature components of a complex signal

     Each line of the eye-diagram has N elements and the period is
     assumed to be given by PER.  The time axis is then [-PER/2 PER/2]
     By default PER is 1

     By default the signal is assumed to start at -PER/2.  This can be
     overridden by the OFF variable, which gives the number of samples
     to delay the signal

     The string STR is a plot style string (example "r+"), and by
     default is the default gnuplot line style

     The figure handle to use can be defined by H.  If H is not given,
     then the next available figure handle is used.  The figure handle
     used in returned on HOUT See also: scatterplot


File: comms.info,  Node: fft,  Next: fibodeco,  Prev: eyediagram,  Up: Function Reference

9.1.38 fft
----------

 -- Function File: fft (X)

     If X is a column vector, finds the FFT over the primitive element
     of the Galois Field of X.  If X is in the Galois Field GF(2^M),
     then X must have '2^M - 1' elements


File: comms.info,  Node: fibodeco,  Next: fiboenco,  Prev: fft,  Up: Function Reference

9.1.39 fibodeco
---------------

 -- Function File: fibodeco (CODE)

     Returns the decoded Fibonacci value from the binary vectors CODE
     Universal codes like Fibonacci codes have a useful synchronization
     property, only for 255 maximum value we have designed these
     routines.  We assume user has partitioned the code into several
     unique segments based on the suffix property of unique strings "11"
     and we just decode the parts.  Partitioning the stream is as simple
     as identifying the "11" pairs that occur, at the terminating ends.
     This system implements the standard binary Fibonacci codes, which
     means that row vectors can only contain 0 or 1.  Ref:
     <http://en.wikipedia.org/wiki/Fibonacci_coding>

          fibodeco ({[0 1 0 0 1 1]})
              => 10
          fibodeco ({[1 1], [0 1 1], [0 0 1 1], [1 0 1 1]})
              => [1, 2, 3, 4]
     See also: fiboenco


File: comms.info,  Node: fiboenco,  Next: fibosplitstream,  Prev: fibodeco,  Up: Function Reference

9.1.40 fiboenco
---------------

 -- Function File: fiboenco (NUM)

     Returns the cell-array of encoded Fibonacci value from the column
     vectors NUM Universal codes like Fibonacci codes have a useful
     synchronization property, only for 255 maximum value we have
     designed these routines.  We assume user has partitioned the code
     into several unique segments based on the suffix property of unique
     elements [1 1] and we just decode the parts.  Partitioning the
     stream is as simple as identifying the [1 1] pairs that occur, at
     the terminating ends.  This system implements the standard binary
     Fibonacci codes, which means that row vectors can only contain 0 or
     1.  Ref: http://en.wikipedia.org/wiki/Fibonacci_coding Ugly
     O(k.N^2) encoder.Ref: Wikipedia article accessed March, 2006
     <http://en.wikipedia.org/wiki/Fibonacci_coding>, UCI Data
     Compression Book, <http://www.ics.uci.edu/~dan/pubs/DC-Sec3.html>,
     (accessed October 2006)

          fiboenco (10)
              => {[ 0 1 0 0 1 1]}
          fiboenco (1:4)
              => {[1 1], [0 1 1], [0 0 1 1], [1 0 1 1]}
     See also: fibodeco


File: comms.info,  Node: fibosplitstream,  Next: filter,  Prev: fiboenco,  Up: Function Reference

9.1.41 fibosplitstream
----------------------

 -- Function File: fibosplitstream (CODE)

     Returns the split data stream at the word boundaries Assuming the
     stream was originally encoded using 'fiboenco' and this routine
     splits the stream at the points where "11" occur together & gives
     us the code-words which can later be decoded from the 'fibodeco'
     This however doesn't mean that we intend to verify if all the
     codewords are correct, and in fact the last symbol in the return
     list can or can not be a valid codeword

     A example use of 'fibosplitstream' would be
          fibodeco (fibosplitstream ([fiboenco(randint (1, 100, [0, 255])){:}]))
          fibodeco (fibosplitstream ([fiboenco(1:10){:}]))
     See also: fiboenco, fibodeco


File: comms.info,  Node: filter,  Next: fmdemod,  Prev: fibosplitstream,  Up: Function Reference

9.1.42 filter
-------------

 -- Loadable Function: y = filter (B, A, X)
 -- Loadable Function: [Y, SF] = filter (B, A, X, SI)

     Digital filtering of vectors in a Galois Field.  Returns the
     solution to the following linear, time-invariant difference
     equation over a Galois Field:

             N                   M
            SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)
            k=0                 k=0

     where N=length(a)-1 and M=length(b)-1 An equivalent form of this
     equation is:

                      N                   M
            y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                     k=1                 k=0

     where c = a/a(1) and d = b/a(1)

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector whose length is equal to the length
     of the longest coefficient vector minus one If SI is not supplied,
     the initial state vector is set to all zeros


File: comms.info,  Node: fmdemod,  Next: fmmod,  Prev: filter,  Up: Function Reference

9.1.43 fmdemod
--------------

 -- Function File: fmdemod (X, FC, FS)
     Create the FM demodulation of the signal x with carrier frequency
     fs Where x is sample at frequency fs See also: ammod, amdemod,
     fmmod


File: comms.info,  Node: fmmod,  Next: gen2par,  Prev: fmdemod,  Up: Function Reference

9.1.44 fmmod
------------

 -- Function File: fmmod (X, FC, FS)
     Create the FM modulation of the signal x with carrier frequency fs.
     Where x is sample at frequency fs See also: ammod, fmdemod, amdemod


File: comms.info,  Node: gen2par,  Next: genqamdemod,  Prev: fmmod,  Up: Function Reference

9.1.45 gen2par
--------------

 -- Function File: PAR = gen2par (GEN)
 -- Function File: GEN = gen2par (PAR)

     Converts binary generator matrix GEN to the parity check matrix PAR
     and visa-versa.  The input matrix must be in standard form That is
     a generator matrix must be k-by-n and in the form [eye(k) P] or [P
     eye(k)], and the parity matrix must be (n-k)-by-n and of the form
     [eye(n-k) P'] or [P' eye(n-k)]

     See also: cyclgen, hammgen


File: comms.info,  Node: genqamdemod,  Next: genqammod,  Prev: gen2par,  Up: Function Reference

9.1.46 genqamdemod
------------------

 -- Loadable Function: Y = genqamdemod (X, C)
     General quadrature amplitude demodulation.  The complex envelope
     quadrature amplitude modulated signal X is demodulated using a
     constellation mapping specified by the 1D vector C.


File: comms.info,  Node: genqammod,  Next: gf,  Prev: genqamdemod,  Up: Function Reference

9.1.47 genqammod
----------------

 -- Function File: Y = genqammod (X, C)

     Modulates an information sequence of integers X in the range '[0
     ... M-1]' onto a quadrature amplitude modulated signal Y, where 'M
     = length (c) - 1' and C is a 1D vector specifying the signal
     constellation mapping to be used.  An example of combined 4PAM-4PSK
     is

          d = randint (1, 1e4, 8);
          c = [1+j -1+j -1-j 1-j 1+sqrt(3) j*(1+sqrt(3)) -1-sqrt(3) -j*(1+sqrt(3))];
          y = genqammod (d, c);
          z = awgn (y, 20);
          plot (z, "rx")
     See also: genqamdemod


File: comms.info,  Node: gf,  Next: gftable,  Prev: genqammod,  Up: Function Reference

9.1.48 gf
---------

 -- Loadable Function: Y = gf (X)
 -- Loadable Function: Y = gf (X, M)
 -- Loadable Function: Y = gf (X, M, PRIMPOLY)
     Creates a Galois field array GF(2^M) from the matrix X.  The Galois
     field has 2^M elements, where M must be between 1 and 16.  The
     elements of X must be between 0 and 2^M - 1.  If M is undefined it
     defaults to the value 1.

     The primitive polynomial to use in the creation of Galois field can
     be specified with the PRIMPOLY variable.  If this is undefined a
     default primitive polynomial is used.  It should be noted that the
     primitive polynomial must be of the degree M and it must be
     irreducible.

     The output of this function is recognized as a Galois field by
     Octave and other matrices will be converted to the same Galois
     field when used in an arithmetic operation with a Galois field.

     See also: isprimitive, primpoly


File: comms.info,  Node: gftable,  Next: gfweight,  Prev: gf,  Up: Function Reference

9.1.49 gftable
--------------

 -- Function File: gftable (M, PRIMPOLY)

     This function exists for compatibility with matlab.  As the Octave
     Galois fields store a copy of the lookup tables for every field in
     use internally, there is no need to use this function

     See also: gf


File: comms.info,  Node: gfweight,  Next: golombdeco,  Prev: gftable,  Up: Function Reference

9.1.50 gfweight
---------------

 -- Function File: W = gfweight (GEN)
 -- Function File: W = gfweight (GEN, "gen")
 -- Function File: W = gfweight (PAR, "par")
 -- Function File: W = gfweight (P, n)

     Calculate the minimum weight or distance of a linear block code.
     The code can be either defined by its generator or parity check
     matrix, or its generator polynomial.  By default if the first
     argument is a matrix, it is assumed to be the generator matrix of
     the code.  The type of the matrix can be defined by a flag "gen"
     for the generator matrix or "par" for the parity check matrix

     If the first argument is a vector, it is assumed that it defines
     the generator polynomial of the code.  In this case a second
     argument is required that defines the codeword length

     See also: hammgen, cyclpoly, bchpoly


File: comms.info,  Node: golombdeco,  Next: golombenco,  Prev: gfweight,  Up: Function Reference

9.1.51 golombdeco
-----------------

 -- Function File: golombdeco (CODE, M)

     Returns the Golomb decoded signal vector using CODE and M
     Compulsory m is need to be specified.  A restrictions is that a
     signal set must strictly be non-negative.  The value of code is a
     cell array of row-vectors which have the encoded Golomb value for a
     single sample.  The Golomb algorithm is used to encode the "code"
     and only that can be meaningfully decoded.  CODE is assumed to have
     been of format generated by the function 'golombenco'.  Also the
     parameter M need to be a non-zero number, unless which it makes
     divide-by-zero errors This function works backward the Golomb
     algorithm see 'golombenco' for more details on that Reference:
     Solomon Golomb, Run length Encodings, 1966 IEEE Trans Info Theory

     An example of the use of 'golombdeco' is
          golombdeco (golombenco (1:4, 2), 2)
              => [1 2 3 4]
     See also: golombenco


File: comms.info,  Node: golombenco,  Next: hammgen,  Prev: golombdeco,  Up: Function Reference

9.1.52 golombenco
-----------------

 -- Function File: golombenco (SIG, M)

     Returns the Golomb coded signal as cell array Also total length of
     output code in bits can be obtained This function uses a M need to
     be supplied for encoding signal vector into a Golomb coded vector.
     A restrictions is that a signal set must strictly be non-negative.
     Also the parameter M need to be a non-zero number, unless which it
     makes divide-by-zero errors The Golomb algorithm [1], is used to
     encode the data into unary coded quotient part which is represented
     as a set of 1's separated from the K-part (binary) using a zero.
     This scheme doesn't need any kind of dictionaries, it is a
     parameterized prefix codes Implementation is close to O(N^2), but
     this implementation *may be* sluggish, though correct.  Details of
     the scheme are, to encode the remainder(r of number N) using the
     floor(log2(m)) bits when rem is in range 0:(2^ceil(log2(m)) - N),
     and encode it as r+(2^ceil(log2(m)) - N), using total of
     2^ceil(log2(m)) bits in other instance it doesn't belong to case 1.
     Quotient is coded simply just using the unary code.  Also according
     to [2] Golomb codes are optimal for sequences using the Bernoulli
     probability model: P(n)=p^n-1.q & p+q=1, and when M=[1/log2(p)], or
     P=2^(1/M)

     Reference: 1.  Solomon Golomb, Run length Encodings, 1966 IEEE
     Trans Info' Theory.  2.  Khalid Sayood, Data Compression, 3rd
     Edition

     An example of the use of 'golombenco' is
          golombenco (1:4, 2)
              => {[0 1], [1 0 0], [1 0 1], [1 1 0 0]}
          golombenco (1:10, 2)
              => {[0 1], [1 0 0], [1 0 1], [1 1 0 0],
                  [1 1 0 1], [1 1 1 0 0], [1 1 1 0 1], [1 1 1 1 0 0],
                  [1 1 1 1 0 1], [1 1 1 1 1 0 0]}
     See also: golombdeco


File: comms.info,  Node: hammgen,  Next: helscanintrlv,  Prev: golombenco,  Up: Function Reference

9.1.53 hammgen
--------------

 -- Function File: H = hammgen (M)
 -- Function File: H = hammgen (M, P)
 -- Function File: [H, G] = hammgen (...)
 -- Function File: [H, G, N, K] = hammgen (...)

     Produce the parity check and generator matrices of a Hamming code.
     The variable M defines the [N,K] Hamming code where 'N = 2 ^ M - 1'
     and 'K = N - M' M must be between 3 and 16

     The parity check matrix is generated relative to the primitive
     polynomial of GF(2^M).  If P is specified the default primitive
     polynomial of GF(2^M) is overridden.  P must be a valid primitive
     polynomial of the correct order for GF(2^M)

     The parity check matrix is returned in the M by N matrix H, and if
     requested the generator matrix is returned in the K by N matrix G

     See also: gen2par


File: comms.info,  Node: helscanintrlv,  Next: huffmandeco,  Prev: hammgen,  Up: Function Reference

9.1.54 helscanintrlv
--------------------

 -- Function File: OUTDATA = helscanintrlv (DATA, NROWS, NCOLS, NSHIFT)
     NROWS-by-NCOLS See also: helscandeintrlv


File: comms.info,  Node: huffmandeco,  Next: huffmandict,  Prev: helscanintrlv,  Up: Function Reference

9.1.55 huffmandeco
------------------

 -- Function File: SIG = huffmandeco (HCODE, DICT)
     Decode signal encoded by 'huffmanenco'

     This function uses a dict built from the 'huffmandict' and uses it
     to decode a signal list into a Huffman list.  A restriction is that
     HCODE is expected to be a binary code

     The returned SIG set that strictly belongs in the range '[1,N]'
     with 'N = length (DICT)'.  Also DICT can only be from the
     'huffmandict' routine.  Whenever decoding fails, those signal
     values a re indicated by '-1', and we successively try to restart
     decoding from the next bit that hasn't failed in decoding,
     ad-infinitum.  An example of the use of 'huffmandeco' is:

          hd    = huffmandict (1:4, [0.5 0.25 0.15 0.10]);
          hcode = huffmanenco (1:4, hd);
          back  = huffmandeco (hcode, hd)
              => [1 2 3 4]
     See also: huffmandict, huffmanenco


File: comms.info,  Node: huffmandict,  Next: huffmanenco,  Prev: huffmandeco,  Up: Function Reference

9.1.56 huffmandict
------------------

 -- Function File: huffmandict (SYMB, PROB)
 -- Function File: huffmandict (SYMB, PROB, TOGGLE)
 -- Function File: huffmandict (SYMB, PROB, TOGGLE, MINVAR)

     Builds a Huffman code, given a probability list.  The Huffman codes
     per symbol are output as a list of strings-per-source symbol.  A
     zero probability symbol is NOT assigned any codeword as this symbol
     doesn't occur in practice anyway

     TOGGLE is an optional argument with values 1 or 0, that starts
     building a code based on 1s or 0s, defaulting to 0.  Also MINVAR is
     a boolean value that is useful in choosing if you want to optimize
     buffer for transmission in the applications of Huffman coding,
     however it doesn't affect the type or average codeword length of
     the generated code.  An example of the use of 'huffmandict' is

          huffmandict (symbols, [0.5 0.25 0.15 0.1], 1)
              => {[0], [1 0], [1 1 1], [1 1 0]}
          huffmandict (symbols, 0.25 * ones (1,4), 1)
              => {[1 1], [1 0], [0 1], [0 0]}

          prob = [0.5 0 0.25 0.15 0.1];
          dict = huffmandict (1:5, prob, 1);
          entropy (prob)
              => 2.3219
          laverage (dict, prob)
              => 1.8500

          x = [0.2 0.4 0.2 0.1 0.1];
          huffmandict (1, x, 0, true)
              => {[1 0], [0 0], [1 1], [0 1 0], [0 1 1]}
          huffmandict (1, x)
              => {[0 1], [1], [0 0 1], [0 0 0 0], [0 0 0 1]}

     Reference: Dr.Rao's course EE5351 Digital Video Coding, at
     UT-Arlington See also: huffmandeco, huffmanenco


File: comms.info,  Node: huffmanenco,  Next: ifft,  Prev: huffmandict,  Up: Function Reference

9.1.57 huffmanenco
------------------

 -- Function File: huffmanenco (SIG, DICT)

     Returns the Huffman encoded signal using DICT.  This function uses
     a DICT built from the 'huffmandict' and uses it to encode a signal
     list into a Huffman list.  A restrictions is that a signal set must
     strictly belong in the range '[1,N]' with 'N = length (dict)' Also
     DICT can only be from the 'huffmandict' routine An example of the
     use of 'huffmanenco' is

          hd = huffmandict (1:4, [0.5 0.25 0.15 0.10]);
          huffmanenco (1:4, hd)
              => [1 0 1 0 0 0 0 0 1]
     See also: huffmandict, huffmandeco


File: comms.info,  Node: ifft,  Next: intrlv,  Prev: huffmanenco,  Up: Function Reference

9.1.58 ifft
-----------

 -- Function File: ifft (X)

     If X is a column vector, finds the IFFT over the primitive element
     of the Galois Field of X.  If X is in the Galois Field GF(2^M),
     then X must have '2^M - 1' elements See also: ifft


File: comms.info,  Node: intrlv,  Next: inv,  Prev: ifft,  Up: Function Reference

9.1.59 intrlv
-------------

 -- Function File: INTRLVD = intrlv (DATA, ELEMENTS)
     Interleaved elements of DATA according to ELEMENTS See also:
     deintrlv


File: comms.info,  Node: inv,  Next: inverse,  Prev: intrlv,  Up: Function Reference

9.1.60 inv
----------

 -- Loadable Function: [X, RCOND] = inv (A)
     Compute the inverse of the square matrix A.  Return an estimate of
     the reciprocal condition number if requested, otherwise warn of an
     ill-conditioned matrix if the reciprocal condition number is small


File: comms.info,  Node: inverse,  Next: isequal,  Prev: inv,  Up: Function Reference

9.1.61 inverse
--------------

 -- Loadable Function: [X, RCOND] = inverse (A)
     See inv


File: comms.info,  Node: isequal,  Next: isgalois,  Prev: inverse,  Up: Function Reference

9.1.62 isequal
--------------

 -- Function File: isequal (X1, X2, ...)
     Return true if all of X1, X2, ... are equal See also:
     isequalwithequalnans


File: comms.info,  Node: isgalois,  Next: isprimitive,  Prev: isequal,  Up: Function Reference

9.1.63 isgalois
---------------

 -- Loadable Function: isgalois (EXPR)
     Return 1 if the value of the expression EXPR is a Galois Field.


File: comms.info,  Node: isprimitive,  Next: istrellis,  Prev: isgalois,  Up: Function Reference

9.1.64 isprimitive
------------------

 -- Loadable Function: Y = isprimitive (A)
     Returns 1 is the polynomial represented by A is a primitive
     polynomial of GF(2).  Otherwise it returns zero.

     See also: gf, primpoly


File: comms.info,  Node: istrellis,  Next: lloyds,  Prev: isprimitive,  Up: Function Reference

9.1.65 istrellis
----------------

 -- Function File: istrellis (T)
 -- Function File: [STATUS, TEXT] = istrellis (T)

     Return true if T is a valid trellis structure

     If called with two output arguments, TEXT contains a string
     indicating a reason if STATUS is false or an empty string if STATUS
     is true

     See also: poly2trellis, struct


File: comms.info,  Node: lloyds,  Next: log,  Prev: istrellis,  Up: Function Reference

9.1.66 lloyds
-------------

 -- Function File: [TABLE, CODES] = lloyds (SIG, INIT_CODES)
 -- Function File: [TABLE, CODES] = lloyds (SIG, LEN)
 -- Function File: [TABLE, CODES] = lloyds (SIG, ..., TOL)
 -- Function File: [TABLE, CODES] = lloyds (SIG, ..., TOL, TYPE)
 -- Function File: [TABLE, CODES, DIST] = lloyds (...)
 -- Function File: [TABLE, CODES, DIST, RELDIST] = lloyds (...)

     Optimize the quantization table and codes to reduce distortion.
     This is based on the article by Lloyd

     S. Lloyd _Least squared quantization in PCM_, IEEE Trans Inform
     Theory, Mar 1982, no 2, p129-137

     which describes an iterative technique to reduce the quantization
     error by making the intervals of the table such that each interval
     has the same area under the PDF of the training signal SIG.  The
     initial codes to try can either be given in the vector INIT_CODES
     or as scalar LEN.  In the case of a scalar the initial codes will
     be an equi-spaced vector of length LEN between the minimum and
     maximum value of the training signal

     The stopping criteria of the iterative algorithm is given by

          abs(DIST(n) - DIST(n-1)) < max(TOL, abs(EPS*max(SIG))

     By default TOL is 1.e-7.  The final input argument determines how
     the updated table is created.  By default the centroid of the
     values of the training signal that fall within the interval
     described by CODES are used to update TABLE.  If TYPE is any other
     string than "centroid", this behavior is overridden and TABLE is
     updated as follows

          TABLE = (CODE(2:length(CODE)) + CODE(1:length(CODE-1))) / 2

     The optimized values are returned as TABLE and CODE.  In addition
     the distortion of the optimized codes representing the training
     signal is returned as DIST.  The relative distortion in the final
     iteration is also returned as RELDIST

     See also: quantiz


File: comms.info,  Node: log,  Next: lu,  Prev: lloyds,  Up: Function Reference

9.1.67 log
----------

 -- Loadable Function: log (X)
     Compute the natural logarithm for each element of X for a Galois
     array


File: comms.info,  Node: lu,  Next: lz77deco,  Prev: log,  Up: Function Reference

9.1.68 lu
---------

 -- Loadable Function: [L, U, P] = lu (A)
     Compute the LU decomposition of A in a Galois Field.  The result is
     returned in a permuted form, according to the optional return value
     P.  For example, given the matrix 'a = gf ([1, 2; 3, 4], 3)',

          [l, u, p] = lu (a)

     returns

          l =
          GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

          Array elements =

             1   0
             6   1

          u =
          GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

          Array elements =

             3   4
             0   7

          p =

          Permutation Matrix

             0   1
             1   0


     Such that 'P * A = L * U'.  If the argument P is not included then
     the permutations are applied to L so that 'A = L * U'.  L is then a
     pseudo- lower triangular matrix.  The matrix A can be rectangular


File: comms.info,  Node: lz77deco,  Next: lz77enco,  Prev: lu,  Up: Function Reference

9.1.69 lz77deco
---------------

 -- Function File: M = lz77deco (C, ALPH, LA, N)
     Lempel-Ziv 77 source algorithm decoding implementation.  Where

     M
          message decoded (1xN)
     C
          encoded message (Mx3)
     ALPH
          size of alphabet
     LA
          lookahead buffer size
     N
          sliding window buffer size
     See also: lz77enco


File: comms.info,  Node: lz77enco,  Next: matdeintrlv,  Prev: lz77deco,  Up: Function Reference

9.1.70 lz77enco
---------------

 -- Function File: C = lz77enco (M, ALPH, LA, N)
     Lempel-Ziv 77 source algorithm implementation.  Where

     C
          encoded message (Mx3)
     ALPH
          size of alphabet
     LA
          lookahead buffer size
     N
          sliding window buffer size
     See also: lz77deco


File: comms.info,  Node: matdeintrlv,  Next: matintrlv,  Prev: lz77enco,  Up: Function Reference

9.1.71 matdeintrlv
------------------

 -- Function File: INTRLVD = matdeintrlv (DATA, NROWS, NCOLS)
     Restore elements of DATA with a temporary matrix of size
     NROWS-by-NCOLS See also: matintrlv


File: comms.info,  Node: matintrlv,  Next: minpol,  Prev: matdeintrlv,  Up: Function Reference

9.1.72 matintrlv
----------------

 -- Function File: INTRLVD = matintrlv (DATA, NROWS, NCOLS)
     Interleaved elements of DATA with a temporary matrix of size
     NROWS-by-NCOLS See also: matdeintrlv


File: comms.info,  Node: minpol,  Next: modmap,  Prev: matintrlv,  Up: Function Reference

9.1.73 minpol
-------------

 -- Function File: minpol (V)

     Finds the minimum polynomial for elements of a Galois Field.  For a
     vector V with N components, representing N values in a Galois Field
     GF(2^M), return the minimum polynomial in GF(2) representing those
     values


File: comms.info,  Node: modmap,  Next: oct2dec,  Prev: minpol,  Up: Function Reference

9.1.74 modmap
-------------

 -- Function File: modmap (METHOD, ...)
 -- Function File: y = modmap (X, FD, FS, "ask", M)
 -- Function File: y = modmap (X, FD, FS, "fsk", M, TONE)
 -- Function File: y = modmap (X, FD, FS, "msk")
 -- Function File: y = modmap (X, FD, FS, "psk", M)
 -- Function File: y = modmap (X, FD, FS, "qask", M)
 -- Function File: y = modmap (X, FD, FS, "qask/cir", NSIG, AMP, PHS)
 -- Function File: y = modmap (X, FD, FS, "qask/arb", INPHASE, QUADR)
 -- Function File: y = modmap (X, FD, FS, "qask/arb", MAP)

     Mapping of a digital signal to an analog signal.  With no output
     arguments 'modmap' plots the constellation of the mapping.  In this
     case the first argument must be the string METHOD defining one of
     "ask", "fsk", "msk", "qask", "qask/cir" or "qask/arb".  The
     arguments following the string METHOD are generally the same as
     those after the corresponding string in the function call without
     output arguments The exception is 'modmap ("msk", FD)'

     With an output argument, Y is the complex mapped analog signal.  In
     this case the arguments X, FD and FS are required.  The variable X
     is the digital signal to be mapped, FD is the sampling rate of the
     of digital signal and the FS is the sampling rate of the analog
     signal.  It is required that 'FS/FD' is an integer

     The available mapping of the digital signal are

     "ask"
          Amplitude shift keying
     "fsk"
          Frequency shift keying
     "msk"
          Minimum shift keying
     "psk"
          Phase shift keying
     "qask"
     "qsk"
     "qam"
          Quadrature amplitude shift keying

     In addition the "qask", "qsk" and "qam" method can be modified with
     the flags "/cir" or "/arb".  That is "qask/cir" and "qask/arb", etc
     are valid methods and give circular- and arbitrary-qask mappings
     respectively

     The additional argument M is the order of the modulation to use M
     must be larger than the largest element of X.  The variable TONE is
     the FSK tone to use in the modulation

     For "qask/cir", the additional arguments are the same as for
     'apkconst', and you are referred to 'apkconst' for the definitions
     of the additional variables

     For "qask/arb", the additional arguments INPHASE and QUADR give the
     in-phase and quadrature components of the mapping, in a similar
     mapping to the outputs of 'qaskenco' with one argument.  Similar
     MAP represents the in-phase and quadrature components of the
     mapping as the real and imaginary parts of the variable MAP See
     also: demodmap, dmodce, amodce, apkconst, qaskenco


File: comms.info,  Node: oct2dec,  Next: pamdemod,  Prev: modmap,  Up: Function Reference

9.1.75 oct2dec
--------------

 -- Function File: D = oct2dec (C)

     Convert octal to decimal values

     Each element of the octal matrix C is converted to a decimal value

     See also: base2dec, bin2dec, dec2bin


File: comms.info,  Node: pamdemod,  Next: pammod,  Prev: oct2dec,  Up: Function Reference

9.1.76 pamdemod
---------------

 -- Function File: Y = pamdemod (X, M)
 -- Function File: Y = pamdemod (X, M, PHI)
 -- Function File: Y = pamdemod (X, M, PHI, TYPE)

     Demodulates a pulse amplitude modulated signal X into an
     information sequence of integers in the range '[0 ... M-1]' PHI
     controls the initial phase and TYPE controls the constellation
     mapping.  If TYPE is set to "Bin" will result in binary encoding,
     in contrast, if set to "Gray" will give Gray encoding An example of
     Gray-encoded 8-PAM is

          d = randint (1, 1e4, 8);
          y = pammod (d, 8, 0, "gray");
          z = awgn (y, 20);
          d_est = pamdemod (z, 8, 0, "gray");
          plot (z, "rx")
          biterr (d, d_est)
     See also: pammod


File: comms.info,  Node: pammod,  Next: poly2trellis,  Prev: pamdemod,  Up: Function Reference

9.1.77 pammod
-------------

 -- Function File: Y = pammod (X, M)
 -- Function File: Y = pammod (X, M, PHI)
 -- Function File: Y = pammod (X, M, PHI, TYPE)

     Modulates an information sequence of integers X in the range '[0
     ... M-1]' onto a pulse amplitude modulated signal Y PHI controls
     the initial phase and TYPE controls the constellation mapping.  If
     TYPE is set to "Bin" will result in binary encoding, in contrast,
     if set to "Gray" will give Gray encoding An example of Gray-encoded
     8-PAM is

          d = randint (1, 1e4, 8);
          y = pammod (d, 8, 0, "gray");
          z = awgn (y, 20);
          plot (z, "rx")
     See also: pamdemod


File: comms.info,  Node: poly2trellis,  Next: primpoly,  Prev: pammod,  Up: Function Reference

9.1.78 poly2trellis
-------------------

 -- Function File: T = poly2trellis (M, G)

     Convert convolutional code generator polynomials into trellis form

     The arguments M and G together describe a rate k/n feedforward
     convolutional encoder.  The output T is a trellis structure
     describing the same encoder with the fields listed below

     The vector M is a k-by-1 array containing the lengths of each of
     the shift registers for the k input bits to the encoder

     The matrix G is a k-by-n octal-value matrix describing the
     generation of each of the n outputs from each of the k inputs.  For
     a particular entry of G, the least-significant bit corresponds to
     the most-delayed input bit in the kth shift-register

     The returned trellis structure contains the following fields:

     'numInputSymbols'
          The number of k-bit input symbols possible, i.e.  2^k

     'numOutputSymbols'
          The number of n-bit output symbols possible, i.e.  2^n

     'numStates'
          The number of states in the trellis

     'nextStates'
          The state transition table for the trellis.  The ith row
          contains the indices of the states reachable from the (i-1)th
          state for each possible input symbol

     'outputs'
          A table of octal-encoded output values for the trellis.  The
          ith row contains values representing the output symbols
          produced in the (i-1)th state for each possible input symbol

     Input symbols, output symbols, and encoder states are all
     interpreted with the lowest indices being the most significant bits

     References:

     [1] S. Lin and D. J. Costello, "Convolutional codes," in 'Error
     Control Coding', 2nd ed.  Upper Saddle River, NJ: Pearson, 2004,
     ch.  11, pp.  453-513

     See also: istrellis


File: comms.info,  Node: primpoly,  Next: prod,  Prev: poly2trellis,  Up: Function Reference

9.1.79 primpoly
---------------

 -- Loadable Function: Y = primpoly (M)
 -- Loadable Function: Y = primpoly (M, OPT)
 -- Loadable Function: Y = primpoly (..., "nodisplay\")
     Finds the primitive polynomials in GF(2^M).

     The first form of this function returns the default primitive
     polynomial of GF(2^M).  This is the minimum primitive polynomial of
     the field.  The polynomial representation is printed and an integer
     representation of the polynomial is returned

     The call 'primpoly (M, OPT)' returns one or more primitive
     polynomials.  The output of the function is dependent of the value
     of OPT.  Valid values of OPT are:

     '\"all\"'
          Returns all of the primitive polynomials of GF(2^M)
     '\"min\"'
          Returns the minimum primitive polynomial of GF(2^M)
     '\"max\"'
          Returns the maximum primitive polynomial of GF(2^M)
     K
          Returns the primitive polynomials having exactly K non-zero
          terms

     The call 'primpoly (..., \"nodisplay\")' disables the output of the
     polynomial forms of the primitives.  The return value is not
     affected.

     See also: gf, isprimitive


File: comms.info,  Node: prod,  Next: pskdemod,  Prev: primpoly,  Up: Function Reference

9.1.80 prod
-----------

 -- Loadable Function: prod (X, DIM)
     Product of elements along dimension DIM of Galois array.  If DIM is
     omitted, it defaults to 1 (column-wise products)


File: comms.info,  Node: pskdemod,  Next: pskmod,  Prev: prod,  Up: Function Reference

9.1.81 pskdemod
---------------

 -- Function File: Y = pamdemod (X, M)
 -- Function File: Y = pamdemod (X, M, PHI)
 -- Function File: Y = pamdemod (X, M, PHI, TYPE)

     Demodulates a complex-baseband phase shift keying modulated signal
     into an information sequence of integers in the range '[0 ...
     M-1]'.  PHI controls the initial phase and TYPE controls the
     constellation mapping.  If TYPE is set to "Bin" will result in
     binary encoding, in contrast, if set to "Gray" will give Gray
     encoding.  An example of Gray-encoded 8-PSK is

          d = randint (1, 1e3, 8);
          y = pskmod (d, 8, 0, "gray");
          z = awgn (y, 20);
          d_est = pskdemod (z, 8, 0, "gray");
          plot (z, "rx")
          biterr (d, d_est)
     See also: pskmod


File: comms.info,  Node: pskmod,  Next: qamdemod,  Prev: pskdemod,  Up: Function Reference

9.1.82 pskmod
-------------

 -- Function File: Y = pskmod (X, M)
 -- Function File: Y = pskmod (X, M, PHI)
 -- Function File: Y = pskmod (X, M, PHI, TYPE)

     Modulates an information sequence of integers X in the range '[0
     ... M-1]' onto a complex baseband phase shift keying modulated
     signal Y.  PHI controls the initial phase and TYPE controls the
     constellation mapping.  If TYPE is set to "Bin" will result in
     binary encoding, in contrast, if set to "Gray" will give Gray
     encoding.  An example of Gray-encoded QPSK is

          d = randint (1, 5e3, 4);
          y = pskmod (d, 4, 0, "gray");
          z = awgn (y, 30);
          plot (z, "rx")
     See also: pskdemod


File: comms.info,  Node: qamdemod,  Next: qammod,  Prev: pskmod,  Up: Function Reference

9.1.83 qamdemod
---------------

 -- Function File: qamdemod (X, M)
     Create the QAM demodulation of x with a size of alphabet m See
     also: qammod, pskmod, pskdemod


File: comms.info,  Node: qammod,  Next: qaskdeco,  Prev: qamdemod,  Up: Function Reference

9.1.84 qammod
-------------

 -- Function File: qammod (X, M)
     Create the QAM modulation of x with a size of alphabet m See also:
     qamdemod, pskmod, pskdemod


File: comms.info,  Node: qaskdeco,  Next: qaskenco,  Prev: qammod,  Up: Function Reference

9.1.85 qaskdeco
---------------

 -- Function File: MSG = qaskdeco (C, M)
 -- Function File: MSG = qaskdeco (INPHASE, QUADR, M)
 -- Function File: MSG = qaskdeco (..., MNMX)

     Demaps an analog signal using a square QASK constellation.  The
     input signal maybe either a complex variable C, or as two real
     variables INPHASE and QUADR representing the in-phase and
     quadrature components of the signal

     The argument M must be a positive integer power of 2.  By default
     the same constellation as created in 'qaskenco' is used by
     'qaskdeco' If is possible to change the values of the minimum and
     maximum of the in-phase and quadrature components of the
     constellation to account for linear changes in the signal values in
     the received signal.  The variable MNMX is a 2-by-2 matrix of the
     following form

               |    min in-phase       ,    max in-phase       |
               |    min quadrature     ,    max quadrature     |

     If 'sqrt (M)' is an integer, then 'qaskenco' uses a Gray mapping.
     Otherwise, an attempt is made to create a nearly square mapping
     with a minimum Hamming distance between adjacent constellation
     points See also: qaskenco


File: comms.info,  Node: qaskenco,  Next: qfunc,  Prev: qaskdeco,  Up: Function Reference

9.1.86 qaskenco
---------------

 -- Function File: qaskenco (M)
 -- Function File: qaskenco (MSG, M)
 -- Function File: Y = qaskenco (...)
 -- Function File: [INPHASE, QUADR] = qaskenco (...)

     Map a digital signal using a square QASK constellation.  The
     argument M must be a positive integer power of 2.  With two input
     arguments the variable MSG represents the message to be encoded.
     The values of MSG must be between 0 and 'M-1'.  In all cases
     'qaskenco (M)' is equivalent to 'qaskenco (1:M, M)'

     Three types of outputs can be created depending on the number of
     output arguments.  That is

     No output arguments
          In this case 'qaskenco' plots the constellation.  Only the
          points in MSG are plotted, which in the case of a single input
          argument is all constellation points
     A single output argument
          The returned variable is a complex variable representing the
          in-phase and quadrature components of the mapped message MSG.
          With, a single input argument this effectively gives the
          mapping from symbols to constellation points
     Two output arguments
          This is the same as one output argument, expect that the
          in-phase and quadrature components are returned explicitly.
          That is

               c = qaskenco (msg, m);
               [a, b] = qaskenco (msg, m);
               all (c == a + 1i*b)
                   => 1

     If 'sqrt (M)' is an integer, then 'qaskenco' uses a Gray mapping.
     Otherwise, an attempt is made to create a nearly square mapping
     with a minimum Hamming distance between adjacent constellation
     points See also: qaskdeco


File: comms.info,  Node: qfunc,  Next: qfuncinv,  Prev: qaskenco,  Up: Function Reference

9.1.87 qfunc
------------

 -- Function File: Y = qfunc (X)
     Compute the Q function See also: erfc, erf


File: comms.info,  Node: qfuncinv,  Next: quantiz,  Prev: qfunc,  Up: Function Reference

9.1.88 qfuncinv
---------------

 -- Function File: Y = qfuncinv (X)
     Compute the inverse Q function See also: erfc, erf


File: comms.info,  Node: quantiz,  Next: randdeintrlv,  Prev: qfuncinv,  Up: Function Reference

9.1.89 quantiz
--------------

 -- Function File: QIDX = quantiz (X, TABLE)
 -- Function File: [QIDX, Q] = quantiz (X, TABLE, CODES)
 -- Function File: [ QIDX, Q, D] = quantiz (...)

     Quantization of an arbitrary signal relative to a partitioning

     'qidx = quantiz (x, table)'
          Determine position of x in strictly monotonic table.  The
          first interval, using index 0, corresponds to x <= table(1)
          Subsequent intervals are table(i-1) < x <= table(i)

     '[qidx, q] = quantiz (x, table, codes)'
          Associate each interval of the table with a code.  Use
          codes(1) for x <= table(1) and codes(n+1) for table(n) < x <=
          table(n+1)

     '[qidx, q, d] = quantiz (...)'
          Compute distortion as mean squared distance of x from the
          corresponding quantization values


File: comms.info,  Node: randdeintrlv,  Next: randerr,  Prev: quantiz,  Up: Function Reference

9.1.90 randdeintrlv
-------------------

 -- Function File: INTRLVD = randdeintrlv (DATA, STATE)
     Restore elements of DATA with a random permutation See also:
     randintrlv, intrlv, deintrlv


File: comms.info,  Node: randerr,  Next: randint,  Prev: randdeintrlv,  Up: Function Reference

9.1.91 randerr
--------------

 -- Function File: B = randerr (N)
 -- Function File: B = randerr (N, M)
 -- Function File: B = randerr (N, M, ERR)
 -- Function File: B = randerr (N, M, ERR, SEED)

     Generate a matrix of random bit errors.  The size of the matrix is
     N rows by M columns.  By default M is equal to N Bit errors in the
     matrix are indicated by a 1

     The variable ERR determines the number of errors per row.  By
     default the return matrix B has exactly one bit error per row If
     ERR is a scalar, there each row of B has exactly this number of
     errors per row.  If ERR is a vector then each row has a number of
     errors that is in this vector.  Each number of errors has an equal
     probability.  If ERR is a matrix with two rows, then the first row
     determines the number of errors and the second their probabilities

     The variable SEED allows the random number generator to be seeded
     with a fixed value.  The initial seed will be restored when
     returning


File: comms.info,  Node: randint,  Next: randintrlv,  Prev: randerr,  Up: Function Reference

9.1.92 randint
--------------

 -- Function File: B = randint (N)
 -- Function File: B = randint (N, M)
 -- Function File: B = randint (N, M, RANGE)
 -- Function File: B = randint (N, M, RANGE, SEED)

     Generate a matrix of random binary numbers.  The size of the matrix
     is N rows by M columns.  By default M is equal to N

     The range in which the integers are generated will is determined by
     the variable RANGE.  If RANGE is an integer, the value will lie in
     the range [0,RANGE-1], or [RANGE+1,0] if RANGE is negative.  If
     RANGE contains two elements the integers will lie within these two
     elements, inclusive.  By default RANGE is assumed to be [0:1]

     The variable SEED allows the random number generator to be seeded
     with a fixed value.  The initial seed will be restored when
     returning


File: comms.info,  Node: randintrlv,  Next: randsrc,  Prev: randint,  Up: Function Reference

9.1.93 randintrlv
-----------------

 -- Function File: INTRLVD = randintrlv (DATA, STATE)
     Interleaves elements of DATA with a random permutation See also:
     intrlv, deintrlv


File: comms.info,  Node: randsrc,  Next: rank,  Prev: randintrlv,  Up: Function Reference

9.1.94 randsrc
--------------

 -- Function File: B = randsrc (N)
 -- Function File: B = randsrc (N, M)
 -- Function File: B = randsrc (N, M, ALPHABET)
 -- Function File: B = randsrc (N, M, ALPHABET, SEED)

     Generate a matrix of random symbols.  The size of the matrix is N
     rows by M columns.  By default M is equal to N

     The variable ALPHABET can be either a row vector or a matrix with
     two rows.  When ALPHABET is a row vector the symbols returned in B
     are chosen with equal probability from ALPHABET.  When ALPHABET has
     two rows, the second row determines the probability with which each
     of the symbols is chosen.  The sum of the probabilities must equal
     1.  By default ALPHABET is [-1 1]

     The variable SEED allows the random number generator to be seeded
     with a fixed value.  The initial seed will be restored when
     returning


File: comms.info,  Node: rank,  Next: reedmullerdec,  Prev: randsrc,  Up: Function Reference

9.1.95 rank
-----------

 -- Loadable Function: D = rank (A)
     Compute the rank of the Galois array A by counting the independent
     rows and columns


File: comms.info,  Node: reedmullerdec,  Next: reedmullerenc,  Prev: rank,  Up: Function Reference

9.1.96 reedmullerdec
--------------------

 -- Function File: reedmullerdec (VV, G, R, M)

     Decode the received code word VV using the RM-generator matrix G,
     of order R, M, returning the code-word C. We use the standard
     majority logic vote method due to Irving S. Reed.  The received
     word has to be a matrix of column size equal to to code-word size
     (i.e 2^m).  Each row is treated as a separate received word

     The second return value is the message M got from C

     G is obtained from definition type construction of Reed-Muller
     code, of order R, length 2^M.  Use the function reedmullergen, for
     the generator matrix for the (R,M) order RM code

     Faster code constructions (also easier) exist, but since finding
     permutation order of the basis vectors, is important, we stick with
     the standard definitions.  To use decoder function reedmullerdec,
     you need to use this specific generator function

     see: Lin & Costello, Ch.4, "Error Control Coding", 2nd Ed, Pearson

          g = reedmullergen (2, 4);
          msg = rand (1, 11) > 0.5;
          c = mod (msg * g, 2);
          [dec_c, dec_m] = reedmullerdec (c, g, 2, 4)
     See also: reedmullergen, reedmullerenc


File: comms.info,  Node: reedmullerenc,  Next: reedmullergen,  Prev: reedmullerdec,  Up: Function Reference

9.1.97 reedmullerenc
--------------------

 -- Function File: reedmullerenc (MSG, R, M)

     Definition type construction of Reed-Muller code, of order R,
     length 2^M.  This function returns the generator matrix for the
     said order RM code

     Encodes the given message word/block, of column size k,
     corresponding to the RM(R,M), and outputs a code matrix C, on each
     row with corresponding codeword The second return value is the G,
     which is generator matrix used for this code

          msg = rand (10, 11) > 0.5;
          [c, g] = reedmullerenc (msg, 2, 4);
     See also: reedmullerdec, reedmullergen


File: comms.info,  Node: reedmullergen,  Next: reshape,  Prev: reedmullerenc,  Up: Function Reference

9.1.98 reedmullergen
--------------------

 -- Function File: reedmullergen (R, M)

     Definition type construction of Reed-Muller code, of order R,
     length 2^M.  This function returns the generator matrix for the
     said order RM code

     RM(r,m) codes are characterized by codewords, 'sum ( (m,0) + (m,1)
     + ... + (m,r)' Each of the codeword is got through spanning the
     space, using the finite set of m-basis codewords Each codeword is
     2^M elements long see: Lin & Costello, "Error Control Coding", 2nd
     Ed

     Faster code constructions (also easier) exist, but since finding
     permutation order of the basis vectors, is important, we stick with
     the standard definitions.  To use decoder function reedmullerdec,
     you need to use this specific generator function

          g = reedmullergen (2, 4);
     See also: reedmullerdec, reedmullerenc


File: comms.info,  Node: reshape,  Next: ricedeco,  Prev: reedmullergen,  Up: Function Reference

9.1.99 reshape
--------------

 -- Loadable Function: reshape (A, M, N)
     Return a matrix with M rows and N columns whose elements are taken
     from the Galois array A.  To decide how to order the elements,
     Octave pretends that the elements of a matrix are stored in
     column-major order (like Fortran arrays are stored)

     For example,

          reshape (gf ([1, 2, 3, 4], 3), 2, 2)
          ans =
          GF(2^3) array. Primitive Polynomial = D^3+D+1 (decimal 11)

          Array elements =

             1   3
             2   4


     The 'reshape' function is equivalent to

          retval = gf (zeros (m, n), a.m, a.prim_poly);
          retval(:) = a;

     but it is somewhat less cryptic to use 'reshape' instead of the
     colon operator.  Note that the total number of elements in the
     original matrix must match the total number of elements in the new
     matrix See also: :


File: comms.info,  Node: ricedeco,  Next: riceenco,  Prev: reshape,  Up: Function Reference

9.1.100 ricedeco
----------------

 -- Function File: ricedeco (CODE, K)

     Returns the Rice decoded signal vector using CODE and K Compulsory
     K is need to be specified A restrictions is that a signal set must
     strictly be non-negative The value of code is a cell array of
     row-vectors which have the encoded rice value for a single sample.
     The Rice algorithm is used to encode the "code" and only that can
     be meaningfully decoded.  CODE is assumed to have been of format
     generated by the function 'riceenco'

     Reference: Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info Theory

     An example of the use of 'ricedeco' is
          ricedeco (riceenco (1:4, 2), 2)
              => [1 2 3 4]
     See also: riceenco


File: comms.info,  Node: riceenco,  Next: rledeco,  Prev: ricedeco,  Up: Function Reference

9.1.101 riceenco
----------------

 -- Function File: riceenco (SIG, K)

     Returns the Rice encoded signal using K or optimal K Default
     optimal K is chosen between 0-7.  Currently no other way to
     increase the range except to specify explicitly.  Also returns K
     parameter used (in case it were to be chosen optimally) and LTOT
     the total length of output code in bits This function uses a K if
     supplied or by default chooses the optimal K for encoding signal
     vector into a rice coded vector A restrictions is that a signal set
     must strictly be non-negative The Rice algorithm is used to encode
     the data into unary coded quotient part which is represented as a
     set of 1's separated from the K-part (binary) using a zero.  This
     scheme doesn't need any kind of dictionaries and its close to O(N),
     but this implementation *may be* sluggish, though correct

     Reference: Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info' Theory

     An example of the use of 'riceenco' is
          riceenco (1:4)
              => {[0 1], [1 0 0], [1 0 1], [1 1 0 0]}
          riceenco (1:10, 2)
              => {[0 0 1], [0 1 0], [0 1 1], [1 0 0 0],
                  [1 0 0 1], [1 0 1 0], [1 0 1 1], [1 1 0 0 0],
                  [1 1 0 0 1], [1 1 0 1 0]}
     See also: ricedeco


File: comms.info,  Node: rledeco,  Next: rleenco,  Prev: riceenco,  Up: Function Reference

9.1.102 rledeco
---------------

 -- Function File: rledeco (MESSAGE)

     Returns decoded run-length MESSAGE.  The RLE encoded MESSAGE has to
     be in the form of a row-vector.  The message format (encoded RLE)
     is like repetition [factor, value]+

     An example use of 'rledeco' is
          message = [1 5 2 4 3 1];
          rledeco (message)
              => [5 4 4 1 1 1]
     See also: rledeco


File: comms.info,  Node: rleenco,  Next: roots,  Prev: rledeco,  Up: Function Reference

9.1.103 rleenco
---------------

 -- Function File: rleenco (MESSAGE)

     Returns run-length encoded MESSAGE.  The RLE form is built from
     MESSAGE.  The original MESSAGE has to be in the form of a
     row-vector.  The encoded MESSAGE format (encoded RLE) is like
     [repetition factor]+, values

     An example use of 'rleenco' is
          message = [5 4 4 1 1 1]
          rleenco (message)
              => [1 5 2 4 3 1];
     See also: rleenco


File: comms.info,  Node: roots,  Next: rsdec,  Prev: rleenco,  Up: Function Reference

9.1.104 roots
-------------

 -- Function File: roots (V)

     For a vector V with N components, return the roots of the
     polynomial over a Galois Field

          v(1) * z^(N-1) + ... + v(N-1) * z + v(N)

     The number of roots returned and their value will be determined by
     the order and primitive polynomial of the Galois Field


File: comms.info,  Node: rsdec,  Next: rsdecof,  Prev: roots,  Up: Function Reference

9.1.105 rsdec
-------------

 -- Loadable Function: MSG = rsdec (CODE, N, K)
 -- Loadable Function: MSG = rsdec (CODE, N, K, G)
 -- Loadable Function: MSG = rsdec (CODE, N, K, FCR, PRIM)
 -- Loadable Function: MSG = rsdec (..., PARPOS)
 -- Loadable Function: [MSG, NERR] = rsdec (...)
 -- Loadable Function: [MSG, NERR, CCODE] = rsdec (...)
     Decodes the message contained in CODE using a [N,K] Reed-Solomon
     code.  The variable CODE must be a Galois array with N columns and
     an arbitrary number of rows.  Each row of CODE represents a single
     block to be decoded by the Reed-Solomon coder.  The decoded message
     is returned in the variable MSG containing K columns and the same
     number of rows as CODE.

     If N does not equal '2^M-1', where m is an integer, then a shorten
     Reed-Solomon decoding is used where zeros are added to the start of
     each row to obtain an allowable codeword length.  The returned MSG
     has these prepending zeros stripped.

     By default the generator polynomial used in the Reed-Solomon coding
     is based on the properties of the Galois Field in which MSG is
     given.  This default generator polynomial can be overridden by a
     polynomial in G.  Suitable generator polynomials can be constructed
     with 'rsgenpoly'.  FCR is an integer value, and it is taken to be
     the first consecutive root of the generator polynomial.  The
     variable PRIM is then the primitive element used to construct the
     generator polynomial.  By default FCR and PRIM are both 1.  It is
     significantly faster to specify the generator polynomial in terms
     of FCR and PRIM, since G is converted to this form in any case.

     By default the parity symbols are placed at the end of the coded
     message.  The variable PARPOS controls this positioning and can
     take the values '"beginning\"' or '\"end\"'.  If the parity symbols
     are at the end, the message is treated with the most-significant
     symbol first, otherwise the message is treated with the
     least-significant symbol first.  See also: gf, rsenc, rsgenpoly


File: comms.info,  Node: rsdecof,  Next: rsenc,  Prev: rsdec,  Up: Function Reference

9.1.106 rsdecof
---------------

 -- Function File: rsdecof (IN, OUT)
 -- Function File: rsdecof (IN, OUT, T)

     Decodes an ASCII file using a Reed-Solomon coder.  The input file
     is defined by IN and the result is written to the output file OUT
     The type of coding to use is determined by whether the input file
     is 7- or 8-bit.  If the input file is 7-bit, the default coding is
     [127,117] while the default coding for an 8-bit file is a [255,
     235].  This allows for 5 or 10 error characters in 127 or 255
     symbols to be corrected respectively.  The number of errors that
     can be corrected can be overridden by the variable T

     If the file is not an integer multiple of the message size (127 or
     255) in length, then the file is padded with the EOT (ASCII
     character 4) character before decoding

     See also: rsencof


File: comms.info,  Node: rsenc,  Next: rsencof,  Prev: rsdecof,  Up: Function Reference

9.1.107 rsenc
-------------

 -- Loadable Function: CODE = rsenc (MSG, N, K)
 -- Loadable Function: CODE = rsenc (MSG, N, K, G)
 -- Loadable Function: CODE = rsenc (MSG, N, K, FCR, PRIM)
 -- Loadable Function: CODE = rsenc (..., PARPOS)
     Encodes the message MSG using a [N,K] Reed-Solomon coding.  The
     variable MSG is a Galois array with K columns and an arbitrary
     number of rows.  Each row of MSG represents a single block to be
     coded by the Reed-Solomon coder.  The coded message is returned in
     the Galois array CODE containing N columns and the same number of
     rows as MSG.

     The use of 'rsenc' can be seen in the following short example.

          m = 3; n = 2^m -1; k = 3;
          msg = gf ([1 2 3; 4 5 6], m);
          code = rsenc (msg, n, k);

     If N does not equal '2^M-1', where m is an integer, then a shorten
     Reed-Solomon coding is used where zeros are added to the start of
     each row to obtain an allowable codeword length.  The returned CODE
     has these prepending zeros stripped.

     By default the generator polynomial used in the Reed-Solomon coding
     is based on the properties of the Galois Field in which MSG is
     given.  This default generator polynomial can be overridden by a
     polynomial in G.  Suitable generator polynomials can be constructed
     with 'rsgenpoly'.  FCR is an integer value, and it is taken to be
     the first consecutive root of the generator polynomial.  The
     variable PRIM is then the primitive element used to construct the
     generator polynomial, such that

     G = (X - A^B) * (X - A^(B+PRIM)) * ...  * (X - A^(B+2*T*PRIM-1)).

     where B is equal to 'FCR * PRIM'.  By default FCR and PRIM are both
     1.

     By default the parity symbols are placed at the end of the coded
     message.  The variable PARPOS controls this positioning and can
     take the values '"beginning\"' or '\"end\"'.  See also: gf, rsdec,
     rsgenpoly


File: comms.info,  Node: rsencof,  Next: rsgenpoly,  Prev: rsenc,  Up: Function Reference

9.1.108 rsencof
---------------

 -- Function File: rsencof (IN, OUT)
 -- Function File: rsencof (IN, OUT, T)
 -- Function File: rsencof (..., PAD)

     Encodes an ASCII file using a Reed-Solomon coder.  The input file
     is defined by IN and the result is written to the output file OUT
     The type of coding to use is determined by whether the input file
     is 7- or 8-bit.  If the input file is 7-bit, the default coding is
     [127,117] while the default coding for an 8-bit file is a [255,
     235].  This allows for 5 or 10 error characters in 127 or 255
     symbols to be corrected respectively.  The number of errors that
     can be corrected can be overridden by the variable T

     If the file is not an integer multiple of the message size (127 or
     255) in length, then the file is padded with the EOT (ASCII
     character 4) characters before coding.  Whether these characters
     are written to the output is defined by the PAD variable.  Valid
     values for PAD are "pad" (the default) and "nopad", which write or
     not the padding respectively

     See also: rsdecof


File: comms.info,  Node: rsgenpoly,  Next: scatterplot,  Prev: rsencof,  Up: Function Reference

9.1.109 rsgenpoly
-----------------

 -- Function File: G = rsgenpoly (N, K)
 -- Function File: G = rsgenpoly (N, K, P)
 -- Function File: G = rsgenpoly (N, K, P, B, S)
 -- Function File: G = rsgenpoly (N, K, P, B)
 -- Function File: [G, T] = rsgenpoly (...)

     Creates a generator polynomial for a Reed-Solomon coding with
     message length of K and codelength of N.  N must be greater than K
     and their difference must be even.  The generator polynomial is
     returned on G as a polynomial over the Galois Field GF(2^M) where N
     is equal to '2^M-1'.  If M is not integer the next highest integer
     value is used and a generator for a shorten Reed-Solomon code is
     returned

     The elements of G represent the coefficients of the polynomial in
     descending order.  If the length of G is lg, then the generator
     polynomial is given by

          G(0) * x^(lg-1) + G(1) * x^(lg-2) + ... + G(lg-1) * x + G(lg)

     If P is defined then it is used as the primitive polynomial of the
     Galois Field GF(2^M).  The default primitive polynomial will be
     used if P is equal to []

     The variables B and S determine the form of the generator
     polynomial in the following manner

          G = (X - A^(B*S)) * (X - A^((B+1)*S)) * ... * (X - A^((B+2*T-1)*S))

     where T is '(N-K)/2', and A is the primitive element of the Galois
     Field.  Therefore B is the first consecutive root of the generator
     polynomial and S is the primitive element to generate the
     polynomial roots

     If requested the variable T, which gives the error correction
     capability of the Reed-Solomon code See also: gf, rsenc, rsdec


File: comms.info,  Node: scatterplot,  Next: shannonfanodeco,  Prev: rsgenpoly,  Up: Function Reference

9.1.110 scatterplot
-------------------

 -- Function File: scatterplot (X)
 -- Function File: scatterplot (X, N)
 -- Function File: scatterplot (X, N, OFF)
 -- Function File: scatterplot (X, N, OFF, STR)
 -- Function File: scatterplot (X, N, OFF, STR, H)
 -- Function File: H = scatterplot (...)

     Display the scatter plot of a signal.  The signal X can be either
     in one of three forms

     A real vector
          In this case the signal is assumed to be real and represented
          by the vector X.  The scatterplot is plotted along the x axis
          only
     A complex vector
          In this case the in-phase and quadrature components of the
          signal are plotted separately on the x and y axes respectively
     A matrix with two columns
          In this case the first column represents the in-phase and the
          second the quadrature components of a complex signal and are
          plotted on the x and y axes respectively

     Each point of the scatter plot is assumed to be separated by N
     elements in the signal.  The first element of the signal to plot is
     determined by OFF.  By default N is 1 and OFF is 0

     The string STR is a plot style string (example "r+"), and by
     default is the default gnuplot point style

     The figure handle to use can be defined by H.  If H is not given,
     then the next available figure handle is used.  The figure handle
     used in returned on HOUT See also: eyediagram


File: comms.info,  Node: shannonfanodeco,  Next: shannonfanodict,  Prev: scatterplot,  Up: Function Reference

9.1.111 shannonfanodeco
-----------------------

 -- Function File: shannonfanodeco (HCODE, DICT)

     Returns the original signal that was Shannon-Fano encoded.  The
     signal was encoded using 'shannonfanoenco'.  This function uses a
     dict built from the 'shannonfanodict' and uses it to decode a
     signal list into a Shannon-Fano list.  Restrictions include hcode
     is expected to be a binary code; returned signal set that strictly
     belongs in the 'range [1,N]', with 'N = length (dict)'.  Also dict
     can only be from the 'shannonfanodict (...)' routine.  Whenever
     decoding fails, those signal values are indicated by -1, and we
     successively try to restart decoding from the next bit that hasn't
     failed in decoding, ad-infinitum

     An example use of 'shannonfanodeco' is
          hd = shannonfanodict (1:4, [0.5 0.25 0.15 0.10]);
          hcode = shannonfanoenco (1:4, hd)
              => hcode = [0 1 0 1 1 0 1 1 1 0]
          shannonfanodeco (hcode, hd)
              => [1 2 3 4]
     See also: shannonfanoenco, shannonfanodict


File: comms.info,  Node: shannonfanodict,  Next: shannonfanoenco,  Prev: shannonfanodeco,  Up: Function Reference

9.1.112 shannonfanodict
-----------------------

 -- Function File: shannonfanodict (SYMBOLS, SYMBOL_PROBABILITES)

     Returns the code dictionary for source using Shannon-Fano algorithm
     Dictionary is built from SYMBOL_PROBABILITIES using the
     Shannon-Fano scheme.  Output is a dictionary cell-array, which are
     codewords, and correspond to the order of input probability

          cw = shannonfanodict (1:4, [0.5 0.25 0.15 0.1]);
          assert (redundancy (cw, [0.5 0.25 0.15 0.1]), 0.25841, 0.001)
          shannonfanodict (1:5, [0.35 0.17 0.17 0.16 0.15])
          shannonfanodict (1:8, [8 7 6 5 5 4 3 2] / 40)
     See also: shannonfanoenc, shannonfanodec


File: comms.info,  Node: shannonfanoenco,  Next: sqrt,  Prev: shannonfanodict,  Up: Function Reference

9.1.113 shannonfanoenco
-----------------------

 -- Function File: shannonfanoenco (HCODE, DICT)

     Returns the Shannon-Fano encoded signal using DICT This function
     uses a DICT built from the 'shannonfanodict' and uses it to encode
     a signal list into a Shannon-Fano code Restrictions include a
     signal set that strictly belongs in the 'range [1,N]' with 'N =
     length (dict)'.  Also dict can only be from the 'shannonfanodict'
     routine An example use of 'shannonfanoenco' is

          hd = shannonfanodict (1:4, [0.5 0.25 0.15 0.10]);
          shannonfanoenco (1:4, hd)
              => [0 1 0 1 1 0 1 1 1 0]
     See also: shannonfanodeco, shannonfanodict


File: comms.info,  Node: sqrt,  Next: sum,  Prev: shannonfanoenco,  Up: Function Reference

9.1.114 sqrt
------------

 -- Loadable Function: sqrt (X)
     Compute the square root of X, element by element, in a Galois Field
     See also: exp


File: comms.info,  Node: sum,  Next: sumsq,  Prev: sqrt,  Up: Function Reference

9.1.115 sum
-----------

 -- Loadable Function: sum (X, DIM)
     Sum of elements along dimension DIM of Galois array.  If DIM is
     omitted, it defaults to 1 (column-wise sum)


File: comms.info,  Node: sumsq,  Next: symerr,  Prev: sum,  Up: Function Reference

9.1.116 sumsq
-------------

 -- Loadable Function: sumsq (X, DIM)
     Sum of squares of elements along dimension DIM of Galois array If
     DIM is omitted, it defaults to 1 (column-wise sum of squares)

     This function is equivalent to computing
          gsum (x .* conj (x), dim)
     but it uses less memory


File: comms.info,  Node: symerr,  Next: syndtable,  Prev: sumsq,  Up: Function Reference

9.1.117 symerr
--------------

 -- Function File: [NUM, RATE] = symerr (A, B)
 -- Function File: [NUM, RATE] = symerr (..., FLAG)
 -- Function File: [NUM, RATE IND] = symerr (...)

     Compares two matrices and returns the number of symbol errors and
     the symbol error rate.  The variables A and B can be either:

     Both matrices
          In this case both matrices must be the same size and then by
          default the return values NUM and RATE are the overall number
          of symbol errors and the overall symbol error rate
     One column vector
          In this case the column vector is used for symbol error
          comparison column-wise with the matrix.  The returned values
          NUM and RATE are then row vectors containing the number of
          symbol errors and the symbol error rate for each of the
          column-wise comparisons.  The number of rows in the matrix
          must be the same as the length of the column vector
     One row vector
          In this case the row vector is used for symbol error
          comparison row-wise with the matrix.  The returned values NUM
          and RATE are then column vectors containing the number of
          symbol errors and the symbol error rate for each of the
          row-wise comparisons.  The number of columns in the matrix
          must be the same as the length of the row vector

     This behavior can be overridden with the variable FLAG.  FLAG can
     take the value "column-wise", "row-wise" or "overall".  A
     column-wise comparison is not possible with a row vector and
     visa-versa


File: comms.info,  Node: syndtable,  Next: systematize,  Prev: symerr,  Up: Function Reference

9.1.118 syndtable
-----------------

 -- Loadable Function: T = syndtable (H)
     Create the syndrome decoding table from the parity check matrix H.
     Each row of the returned matrix T represents the error vector in a
     received symbol for a certain syndrome.  The row selected is
     determined by a conversion of the syndrome to an integer
     representation, and using this to reference each row of T.  See
     also: hammgen, cyclgen


File: comms.info,  Node: systematize,  Next: vec2mat,  Prev: syndtable,  Up: Function Reference

9.1.119 systematize
-------------------

 -- Function File: systematize (G)

     Given G, extract P parity check matrix.  Assume row-operations in
     GF(2) G is of size KxN, when decomposed through row-operations into
     a I of size KxK identity matrix, and a parity check matrix P of
     size Kx(N-K)

     Most arbitrary code with a given generator matrix G, can be
     converted into its systematic form using this function

     This function returns 2 values, first is default being GX the
     systematic version of the G matrix, and then the parity check
     matrix P

          g = [1 1 1 1; 1 1 0 1; 1 0 0 1];
          [gx, p] = systematize (g);
              => gx = [1 0 0 1; 0 1 0 0; 0 0 1 0];
              => p = [1 0 0];
     See also: bchpoly, biterr


File: comms.info,  Node: vec2mat,  Next: wgn,  Prev: systematize,  Up: Function Reference

9.1.120 vec2mat
---------------

 -- Function File: M = vec2mat (V, C)
 -- Function File: M = vec2mat (V, C, D)
 -- Function File: [M, ADD] = vec2mat (...)

     Converts the vector V into a C column matrix with row priority
     arrangement and with the final column padded with the value D to
     the correct length.  By default D is 0.  The amount of padding
     added to the matrix is returned in ADD


File: comms.info,  Node: wgn,  Prev: vec2mat,  Up: Function Reference

9.1.121 wgn
-----------

 -- Function File: Y = wgn (M, N, P)
 -- Function File: Y = wgn (M, N, P, IMP)
 -- Function File: Y = wgn (M, N, P, IMP, SEED)
 -- Function File: Y = wgn (..., TYPE)
 -- Function File: Y = wgn (..., OUTPUT)

     Returns a M-by-N matrix Y of white Gaussian noise.  P specifies the
     power of the output noise, which is assumed to be referenced to an
     impedance of 1 Ohm, unless IMP explicitly defines the impedance

     If SEED is defined then the randn function is seeded with this
     value

     The arguments TYPE and OUTPUT must follow the above numerical
     arguments, but can be specified in any order.  TYPE specifies the
     units of P, and can be "dB", "dBW", "dBm" or "linear".  "dB" is in
     fact the same as "dBW" and is keep as a misnomer of Matlab.  The
     units of "linear" are in Watts

     The OUTPUT variable should be either "real" or "complex".  If the
     output is complex then the power P is divided equally between the
     real and imaginary parts

     See also: randn, awgn



Tag Table:
Node: Top71
Node: Introduction376
Node: Random Signals911
Node: Signal Creation1584
Node: Signal Analysis9779
Node: Source Coding13793
Node: Quantization14016
Node: PCM Coding16263
Node: Arithmetic Coding16614
Node: Dynamic Range Compression16864
Node: Block Coding18070
Node: Data Formats18625
Node: Binary Block Codes20818
Node: BCH Codes26397
Node: Reed-Solomon Codes29071
Node: Representation of Reed-Solomon Messages29324
Node: Creating and Decoding Messages31248
Node: Shortened Reed-Solomon Codes35256
Node: Convolutional Coding36418
Node: Trellis Structure36889
Node: Convolutional Encoding38692
Node: Modulations39962
Node: Special Filters40255
Node: Galois Fields40404
Node: Galois Field Basics40605
Node: Creating Galois Fields42724
Node: Primitive Polynomials44851
Node: Accessing Internal Fields47394
Node: Function Overloading49024
Node: Known Problems50731
Node: Manipulating Galois Fields52625
Node: Expressions manipulation and assignment52988
Node: Unary operations56380
Node: Arithmetic operations57134
Node: Comparison operations60330
Node: Polynomial manipulations61527
Node: Linear Algebra66602
Node: Signal Processing68658
Node: Function Reference71708
Node: ademodce80516
Node: amdemod82690
Node: ammod82992
Node: amodce83291
Node: apkconst85220
Node: awgn86958
Node: bchdeco88193
Node: bchenco90430
Node: bchpoly92057
Node: bi2de95278
Node: biterr96091
Node: bsc98085
Node: comms98328
Node: compand99871
Node: conv101140
Node: convenc101547
Node: convmtx102629
Node: cosets103365
Node: cyclgen103694
Node: cyclpoly104931
Node: de2bi106102
Node: decode107306
Node: deconv112022
Node: deintrlv112489
Node: demodmap112743
Node: det115241
Node: dftmtx115440
Node: diag116115
Node: dpcmdeco116865
Node: dpcmenco117382
Node: dpcmopt118587
Node: egolaydec120166
Node: egolayenc121390
Node: egolaygen122025
Node: encode122433
Node: exp125923
Node: eyediagram126142
Node: fft127761
Node: fibodeco128087
Node: fiboenco129097
Node: fibosplitstream130360
Node: filter131239
Node: fmdemod132414
Node: fmmod132725
Node: gen2par133027
Node: genqamdemod133590
Node: genqammod133970
Node: gf134663
Node: gftable135679
Node: gfweight136064
Node: golombdeco137016
Node: golombenco138106
Node: hammgen140082
Node: helscanintrlv140999
Node: huffmandeco141264
Node: huffmandict142303
Node: huffmanenco144016
Node: ifft144753
Node: intrlv145098
Node: inv145346
Node: inverse145718
Node: isequal145900
Node: isgalois146152
Node: isprimitive146392
Node: istrellis146723
Node: lloyds147181
Node: log149198
Node: lu149417
Node: lz77deco150427
Node: lz77enco150892
Node: matdeintrlv151318
Node: matintrlv151622
Node: minpol151924
Node: modmap152308
Node: oct2dec155057
Node: pamdemod155371
Node: pammod156227
Node: poly2trellis157006
Node: primpoly158944
Node: prod160216
Node: pskdemod160498
Node: pskmod161373
Node: qamdemod162171
Node: qammod162436
Node: qaskdeco162697
Node: qaskenco164012
Node: qfunc165805
Node: qfuncinv166007
Node: quantiz166225
Node: randdeintrlv167163
Node: randerr167459
Node: randint168578
Node: randintrlv169512
Node: randsrc169792
Node: rank170769
Node: reedmullerdec171021
Node: reedmullerenc172356
Node: reedmullergen173100
Node: reshape174093
Node: ricedeco175110
Node: riceenco175972
Node: rledeco177406
Node: rleenco177911
Node: roots178461
Node: rsdec178894
Node: rsdecof181089
Node: rsenc182045
Node: rsencof184094
Node: rsgenpoly185294
Node: scatterplot187054
Node: shannonfanodeco188633
Node: shannonfanodict189825
Node: shannonfanoenco190624
Node: sqrt191415
Node: sum191661
Node: sumsq191925
Node: symerr192329
Node: syndtable194024
Node: systematize194570
Node: vec2mat195446
Node: wgn195947

End Tag Table
